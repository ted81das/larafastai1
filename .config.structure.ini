# Set the root directory path
$rootDir = "c:/laragon/www/larafast1"

# Create Models directory and files
New-Item -Path "$rootDir/app/Models" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Models/Workflow.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Models/WorkflowNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Models/AgentDynamicConfig.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Models/KnowledgeDocument.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Models/ExecutionLog.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Models/WorkflowExecution.php" -ItemType File -Force

# Create HTTP Controllers and Requests
New-Item -Path "$rootDir/app/Http/Controllers" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Http/Controllers/WorkflowController.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Http/Controllers/WorkflowExecutionController.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Http/Controllers/WebhookController.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Http/Controllers/AgentDynamicController.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Http/Controllers/RagChatController.php" -ItemType File -Force

# Create HTTP Requests
New-Item -Path "$rootDir/app/Http/Requests" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Http/Requests/StoreWorkflowRequest.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Http/Requests/ExecuteWorkflowRequest.php" -ItemType File -Force

# Create Services directories
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/WebhookNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/HttpNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/AgentNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/ConditionNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/TransformNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/SchedulerNode.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/NodeTypes/ReturnNode.php" -ItemType File -Force

# Create Workflow base files
New-Item -Path "$rootDir/app/Services/Workflow/NodeRegistry.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/WorkflowEngine.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Workflow/VariableResolver.php" -ItemType File -Force

# Create Agent services
New-Item -Path "$rootDir/app/Services/Agent" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Services/Agent/AgentFactory.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Agent/DynamicAgentProxy.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/Agent/ModelRegistry.php" -ItemType File -Force

# Create LLM services
New-Item -Path "$rootDir/app/Services/LLM" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Services/LLM/PrismAdapter.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/LLM/OpenAIAdapter.php" -ItemType File -Force

# Create RAG services
New-Item -Path "$rootDir/app/Services/RAG" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Services/RAG/LlphantService.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/RAG/DocumentProcessor.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/RAG/VectorStoreService.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Services/RAG/EmbeddingService.php" -ItemType File -Force

# Create Filament Resources
New-Item -Path "$rootDir/app/Filament/Resources" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Filament/Resources/WorkflowResource.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Filament/Resources/WorkflowNodeResource.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Filament/Resources/AgentDynamicConfigResource.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Filament/Resources/KnowledgeDocumentResource.php" -ItemType File -Force

# Create Filament Pages
New-Item -Path "$rootDir/app/Filament/Pages" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Filament/Pages/WorkflowBuilder.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Filament/Pages/TestWorkflow.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Filament/Pages/TestRagChat.php" -ItemType File -Force

# Create Jobs
New-Item -Path "$rootDir/app/Jobs" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Jobs/ExecuteWorkflow.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Jobs/ProcessDocument.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Jobs/ScheduledWorkflow.php" -ItemType File -Force

# Create Providers
New-Item -Path "$rootDir/app/Providers" -ItemType Directory -Force
New-Item -Path "$rootDir/app/Providers/LlphantServiceProvider.php" -ItemType File -Force
New-Item -Path "$rootDir/app/Providers/WorkflowServiceProvider.php" -ItemType File -Force

# Create database migrations
New-Item -Path "$rootDir/database/migrations" -ItemType Directory -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000001_create_workflows_table.php" -ItemType File -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000002_create_workflow_nodes_table.php" -ItemType File -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000003_create_agent_dynamic_configs_table.php" -ItemType File -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000004_create_knowledge_documents_table.php" -ItemType File -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000005_create_workflow_executions_table.php" -ItemType File -Force
New-Item -Path "$rootDir/database/migrations/2023_01_01_000006_create_execution_logs_table.php" -ItemType File -Force

# Create Vue pages and components
# Workflows
New-Item -Path "$rootDir/resources/js/Pages/Workflows" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Pages/Workflows/Index.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Workflows/Create.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Workflows/Edit.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Workflows/Builder.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Workflows/Execution.vue" -ItemType File -Force

# Agents
New-Item -Path "$rootDir/resources/js/Pages/Agents" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Pages/Agents/Index.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Agents/Create.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Agents/Edit.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Agents/Chat.vue" -ItemType File -Force

# Knowledge
New-Item -Path "$rootDir/resources/js/Pages/Knowledge" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Pages/Knowledge/Index.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Pages/Knowledge/Upload.vue" -ItemType File -Force

# Components - Workflow Builder
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder/Canvas.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder/NodeList.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder/NodeConfig.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder/SequenceView.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Builder/NodeCard.vue" -ItemType File -Force

# Components - Workflow Nodes
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/WebhookNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/HttpNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/AgentNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/ConditionNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/TransformNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/SchedulerNode.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Nodes/ReturnNode.vue" -ItemType File -Force

# Components - Workflow Execution
New-Item -Path "$rootDir/resources/js/Components/Workflow/Execution" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Execution/ExecutionView.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Workflow/Execution/NodeExecution.vue" -ItemType File -Force

# Components - Agent
New-Item -Path "$rootDir/resources/js/Components/Agent" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Components/Agent/AgentForm.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Agent/ModelSelector.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Agent/ToolSelector.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Agent/ChatInterface.vue" -ItemType File -Force

# Components - Knowledge
New-Item -Path "$rootDir/resources/js/Components/Knowledge" -ItemType Directory -Force
New-Item -Path "$rootDir/resources/js/Components/Knowledge/DocumentUploader.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Knowledge/DocumentList.vue" -ItemType File -Force
New-Item -Path "$rootDir/resources/js/Components/Knowledge/RagTester.vue" -ItemType File -Force

# Output confirmation message
Write-Host "Larafast1 directory structure and files created successfully!" -ForegroundColor Green





├── app/
│   ├── Models/
│   │   ├── Workflow.php                     # Workflow model
│   │   ├── WorkflowNode.php                 # Node model
│   │   ├── AgentDynamicConfig.php           # Dynamic agent config
│   │   ├── KnowledgeDocument.php            # Document storage
│   │   ├── ExecutionLog.php                 # Workflow execution logs
│   │   └── WorkflowExecution.php            # Execution history
│   ├── Http/
│   │   ├── Controllers/
│   │   │   ├── WorkflowController.php       # Workflow CRUD
│   │   │   ├── WorkflowExecutionController.php # Execute workflows
│   │   │   ├── WebhookController.php        # Receive webhook triggers
│   │   │   ├── AgentDynamicController.php   # Agent management
│   │   │   └── RagChatController.php        # RAG-enabled chat
│   │   └── Requests/
│   │       ├── StoreWorkflowRequest.php
│   │       └── ExecuteWorkflowRequest.php
│   ├── Services/
│   │   ├── Workflow/
│   │   │   ├── NodeTypes/                   # Node implementations
│   │   │   │   ├── WebhookNode.php
│   │   │   │   ├── HttpNode.php
│   │   │   │   ├── AgentNode.php
│   │   │   │   ├── ConditionNode.php
│   │   │   │   ├── TransformNode.php
│   │   │   │   ├── SchedulerNode.php
│   │   │   │   └── ReturnNode.php
│   │   │   ├── NodeRegistry.php             # Available node types
│   │   │   ├── WorkflowEngine.php           # Execution engine
│   │   │   └── VariableResolver.php         # Handles variable references
│   │   ├── Agent/
│   │   │   ├── AgentFactory.php             # Dynamic agent creation
│   │   │   ├── DynamicAgentProxy.php        # Agent proxy
│   │   │   └── ModelRegistry.php            # Available models
│   │   ├── LLM/
│   │   │   ├── PrismAdapter.php             # Prism integration
│   │   │   └── OpenAIAdapter.php            # OpenAI integration
│   │   └── RAG/
│   │       ├── LlphantService.php           # llphant integration
│   │       ├── DocumentProcessor.php        # Process documents
│   │       ├── VectorStoreService.php       # Qdrant integration
│   │       └── EmbeddingService.php         # Embedding generation
│   ├── Filament/
│   │   ├── Resources/
│   │   │   ├── WorkflowResource.php         # Workflow management
│   │   │   ├── WorkflowNodeResource.php     # Node management
│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management
│   │   │   └── KnowledgeDocumentResource.php  # Document management
│   │   └── Pages/
│   │       ├── WorkflowBuilder.php          # Custom builder page
│   │       ├── TestWorkflow.php             # Test workflow page
│   │       └── TestRagChat.php              # Test RAG chat
│   ├── Jobs/
│   │   ├── ExecuteWorkflow.php              # Run workflow
│   │   ├── ProcessDocument.php              # Process documents for RAG
│   │   └── ScheduledWorkflow.php            # Run scheduled workflows
│   └── Providers/
│       ├── LlphantServiceProvider.php       # RAG services
│       └── WorkflowServiceProvider.php      # Workflow components
├── database/
│   └── migrations/
│       ├── 2023_xx_xx_create_workflows_table.php
│       ├── 2023_xx_xx_create_workflow_nodes_table.php
│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php
│       ├── 2023_xx_xx_create_knowledge_documents_table.php
│       ├── 2023_xx_xx_create_workflow_executions_table.php
│       └── 2023_xx_xx_create_execution_logs_table.php
└── resources/
    ├── js/
    │   ├── Pages/
    │   │   ├── Workflows/
    │   │   │   ├── Index.vue                # List workflows
    │   │   │   ├── Create.vue               # Create workflow
    │   │   │   ├── Edit.vue                 # Edit workflow
    │   │   │   ├── Builder.vue              # Visual builder
    │   │   │   └── Execution.vue            # Execution history
    │   │   ├── Agents/
    │   │   │   ├── Index.vue                # List agents
    │   │   │   ├── Create.vue               # Create agent
    │   │   │   ├── Edit.vue                 # Edit agent
    │   │   │   └── Chat.vue                 # Chat with agent
    │   │   └── Knowledge/
    │   │       ├── Index.vue                # Doc management 
    │   │       └── Upload.vue               # Upload documents
    │   └── Components/
    │       ├── Workflow/
    │       │   ├── Builder/
    │       │   │   ├── Canvas.vue           # Main builder canvas
    │       │   │   ├── NodeList.vue         # Available nodes
    │       │   │   ├── NodeConfig.vue       # Node configuration
    │       │   │   ├── SequenceView.vue     # Sequential node view
    │       │   │   └── NodeCard.vue         # Individual node
    │       │   ├── Nodes/                   # Node-specific components
    │       │   │   ├── WebhookNode.vue
    │       │   │   ├── HttpNode.vue
    │       │   │   ├── AgentNode.vue
    │       │   │   ├── ConditionNode.vue
    │       │   │   ├── TransformNode.vue
    │       │   │   ├── SchedulerNode.vue
    │       │   │   └── ReturnNode.vue
    │       │   └── Execution/
    │       │       ├── ExecutionView.vue    # Execution details
    │       │       └── NodeExecution.vue    # Node execution info
    │       ├── Agent/
    │       │   ├── AgentForm.vue            # Create/edit agent
    │       │   ├── ModelSelector.vue        # Select LLM model
    │       │   ├── ToolSelector.vue         # Select agent tools
    │       │   └── ChatInterface.vue        # Streaming chat UI
    │       └── Knowledge/
    │           ├── DocumentUploader.vue     # Upload documents
    │           ├── DocumentList.vue         # List documents
    │           └── RagTester.vue            # Test RAG





this repository is a vue inertia repository with LaraGent agents.. i want to implement a multinode visual workflow builder system with mutliple workflow nodes which will call HTTP API or a defined LaraGent agent and the reposnse received will be available for all the subsequent sequential nodes to process(not available for previous nodes in the sequence)... the responses will be individual fields of json decoded from responses.. each individua fields can be available in the subsequent nodes... the first node has to be mandatorily a webhook node with a associated webhook url where to receive incoming payload or a scheduler node (run at schedule) and the last node will be a return node that will return the output to the webhook call Workflow Builder System: Vue/Inertia.js Implementation

I want code that implements a workflow builder system using Vue with Inertia.js, allowing users to create, view, and edit automated workflows with a drag-and-drop interface. Let me explain the key components:

Database Structure

The system uses two main tables:

Workflows Table:

Stores basic workflow information (name, status, webhook details)

Links to users and teams

Contains a webhook URL and secret for external triggers

Includes a JSON template for final responses

Workflow Nodes Table:

Represents individual steps in a workflow

Each node has a type, position, and configuration

Includes input/output mapping to connect nodes together

React Components

1. Index Page 

Displays a list of all workflows in a table

Shows each workflow's name, webhook URL, and status

Provides links to create new workflows or edit existing ones

Uses Shadcn UI components for styling

2. Builder Page

The main workflow editing interface - this should allow sequentially creating nodes and linking them in sequence first second so on so forth.. 

Divided into three columns:

Left sidebar: Available node types to add

Middle section: Current workflow nodes in sequence

Right sidebar: Configuration for the selected node

Manages state for nodes and selections

Handles form submission to create/update workflows

3. NodeList Component 

Implements drag-and-drop functionality

Displays each node in the workflow sequence

Allows reordering of nodes through drag and drop

Handles node selection for configuration

4. NodeConfig Component 

Dynamic configuration panel that changes based on node type

For webhook nodes: Defines output fields

For HTTP nodes: Configures URL, method, and other HTTP request details

Shows available variables from previous nodes that can be used in the current node

Key Functionality

Workflow Creation/Editing: Users can create new workflows or edit existing ones

Node Management: Add, configure, and reorder workflow nodes

Variable Passing: Output from one node can be used as input in subsequent nodes

Drag-and-Drop Interface: Visual workflow building with intuitive UI

Type-Specific Configuration: Different node types have custom configuration odptions

This implementation provides a full-featured, visual workflow builder that allows technical and non-technical users to create complex automated processes through the UI.

I'll help you implement the necessary Filament resources, pages, and routes for your workflow builder in a multi-tenant SaaS environment. User should be able to test out the webhook and node sequence by receiving sample paylod on webhook url and then going step by step into each. First generate the code strategy for this with directory structure high lighting where to add the files..  
larafast1
 




Context
— 14 new items
Request Failed: context deadline exceeded
Below is a possible directory structure and example code demonstrating how to implement a visual workflow builder in a Vue/Inertia.js + Laravel application (aka "larafast1") with a multi-tenant approach in mind. This example shows the gist of how you might organize models, migrations, controllers, and Vue pages/components to accomplish your goal.

Directory Structure
app/
└── Http/
└── Controllers/
└── WorkflowController.php
│
├── Models/
│ ├── Workflow.php
│ └── WorkflowNode.php
│
└── Providers/
└── AppServiceProvider.php (for multi-tenant logic if needed)

database/ └── migrations/ ├── 2023_10_09_000000_create_workflows_table.php └── 2023_10_09_000001_create_workflow_nodes_table.php

resources/ └── js/ ├── Components/ │ └── Workflow/ │ ├── NodeList.vue │ └── NodeConfig.vue └── Pages/ └── Workflows/ ├── Index.vue └── Builder.vue

routes/ └── web.php

Migrations
Create the “workflows” table:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('workflows', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->boolean('active')->default(true);
            $table->string('webhook_url')->nullable();
            $table->string('webhook_secret')->nullable();
            $table->json('final_response_template')->nullable();
            // For multi-tenant usage (e.g. "team_id" or "tenant_id")
            $table->unsignedBigInteger('team_id')->nullable();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::dropIfExists('workflows');
    }
};

Copy

Apply

database\migrations\2023_10_09_000000_create_workflows_table.php
Create the “workflow_nodes” table:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('workflow_nodes', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->cascadeOnDelete();
            $table->string('type'); // e.g. "webhook", "http", "scheduler", "return"
            $table->integer('sequence')->default(1);
            $table->json('config')->nullable();    // Node-specific configuration
            $table->json('inputs')->nullable();    // Mapped from previous node outputs
            $table->json('outputs')->nullable();   // Defines what outputs this node has
            $table->timestamps();
        });
    }

    public function down()
    {
        Schema::dropIfExists('workflow_nodes');
    }
};

Copy

Apply

database\migrations\2023_10_09_000001_create_workflow_nodes_table.php
Models
Workflow model:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Workflow extends Model
{
    protected $fillable = [
        'name',
        'active',
        'webhook_url',
        'webhook_secret',
        'final_response_template',
        'team_id',
        'user_id',
    ];

    protected $casts = [
        'final_response_template' => 'json',
    ];

    public function nodes(): HasMany
    {
        return $this->hasMany(WorkflowNode::class);
    }
}

Copy

Apply

app\Models\Workflow.php
WorkflowNode model:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class WorkflowNode extends Model
{
    protected $fillable = [
        'workflow_id',
        'type',
        'sequence',
        'config',
        'inputs',
        'outputs',
    ];

    protected $casts = [
        'config' => 'json',
        'inputs' => 'json',
        'outputs' => 'json',
    ];

    public function workflow(): BelongsTo
    {
        return $this->belongsTo(Workflow::class);
    }
}

Copy

Apply

app\Models\WorkflowNode.php
Controller
WorkflowController (handles listing, creation, and editing of workflows):

<?php

namespace App\Http\Controllers;

use App\Models\Workflow;
use App\Models\WorkflowNode;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Redirect;

class WorkflowController extends Controller
{
    public function index()
    {
        $workflows = Workflow::with('nodes')->paginate(10);

        return Inertia::render('Workflows/Index', [
            'workflows' => $workflows,
        ]);
    }

    public function create()
    {
        return Inertia::render('Workflows/Builder', [
            'workflow' => null,
        ]);
    }

    public function store(Request $request)
    {
        $data = $request->validate([
            'name' => 'required|string',
            'active' => 'boolean',
            'webhook_url' => 'nullable|string',
            'webhook_secret' => 'nullable|string',
            'final_response_template' => 'nullable|array',
            'nodes' => 'required|array',
        ]);

        $workflow = Workflow::create([
            'name' => $data['name'],
            'active' => $data['active'] ?? true,
            'webhook_url' => $data['webhook_url'] ?? null,
            'webhook_secret' => $data['webhook_secret'] ?? null,
            'final_response_template' => $data['final_response_template'] ?? [],
            'user_id' => auth()->id(),
        ]);

        // Attach nodes
        foreach ($data['nodes'] as $index => $nodeData) {
            $workflow->nodes()->create([
                'type'     => $nodeData['type'],
                'sequence' => $index + 1,
                'config'   => $nodeData['config'] ?? [],
                'inputs'   => $nodeData['inputs'] ?? [],
                'outputs'  => $nodeData['outputs'] ?? [],
            ]);
        }

        return Redirect::route('workflows.index');
    }

    public function edit(Workflow $workflow)
    {
        $workflow->load('nodes');

        return Inertia::render('Workflows/Builder', [
            'workflow' => $workflow,
        ]);
    }

    public function update(Request $request, Workflow $workflow)
    {
        $data = $request->validate([
            'name' => 'required|string',
            'active' => 'boolean',
            'webhook_url' => 'nullable|string',
            'webhook_secret' => 'nullable|string',
            'final_response_template' => 'nullable|array',
            'nodes' => 'required|array',
        ]);

        $workflow->update([
            'name' => $data['name'],
            'active' => $data['active'] ?? true,
            'webhook_url' => $data['webhook_url'] ?? null,
            'webhook_secret' => $data['webhook_secret'] ?? null,
            'final_response_template' => $data['final_response_template'] ?? [],
        ]);

        // Remove old nodes and re-create them
        $workflow->nodes()->delete();
        foreach ($data['nodes'] as $index => $nodeData) {
            $workflow->nodes()->create([
                'type'     => $nodeData['type'],
                'sequence' => $index + 1,
                'config'   => $nodeData['config'] ?? [],
                'inputs'   => $nodeData['inputs'] ?? [],
                'outputs'  => $nodeData['outputs'] ?? [],
            ]);
        }

        return Redirect::route('workflows.index');
    }
}

Copy

Apply

app\Http\Controllers\WorkflowController.php
Routes
Add routes to routes/web.php:

<?php

use App\Http\Controllers\WorkflowController;
use Illuminate\Support\Facades\Route;

Route::group(['middleware' => ['auth']], function () {
    Route::get('workflows', [WorkflowController::class, 'index'])->name('workflows.index');
    Route::get('workflows/create', [WorkflowController::class, 'create'])->name('workflows.create');
    Route::post('workflows', [WorkflowController::class, 'store'])->name('workflows.store');
    Route::get('workflows/{workflow}/edit', [WorkflowController::class, 'edit'])->name('workflows.edit');
    Route::put('workflows/{workflow}', [WorkflowController::class, 'update'])->name('workflows.update');
});

Copy

Apply

routes\web.php
Vue (Inertia) Pages and Components
A) Index Page – displays all workflows in a table:

<template>
  <div class="p-4">
    <h1 class="text-xl font-bold mb-4">Workflows</h1>

    <a href="{{ route('workflows.create') }}"
       class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600">
      Create New Workflow
    </a>

    <div class="mt-4">
      <table class="w-full border">
        <thead>
          <tr class="bg-gray-100">
            <th class="py-2 px-4 text-left">Name</th>
            <th class="py-2 px-4 text-left">Webhook URL</th>
            <th class="py-2 px-4 text-left">Active</th>
            <th class="py-2 px-4"></th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="workflow in workflows.data" :key="workflow.id" class="border-b">
            <td class="py-2 px-4">{{ workflow.name }}</td>
            <td class="py-2 px-4">{{ workflow.webhook_url }}</td>
            <td class="py-2 px-4">
              <span :class="['px-2 py-1 rounded text-sm', workflow.active ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700']">
                {{ workflow.active ? 'Yes' : 'No' }}
              </span>
            </td>
            <td class="py-2 px-4 text-right">
              <a :href="route('workflows.edit', workflow.id)"
                 class="px-2 py-1 rounded bg-indigo-500 text-white hover:bg-indigo-600">
                Edit
              </a>
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="mt-4">
      <!-- Simple pagination controls -->
      <button
        v-if="workflows.links.prev"
        @click="$inertia.visit(workflows.links.prev)"
        class="px-4 py-2 rounded bg-gray-200 mr-2"
      >
        Prev
      </button>
      <button
        v-if="workflows.links.next"
        @click="$inertia.visit(workflows.links.next)"
        class="px-4 py-2 rounded bg-gray-200"
      >
        Next
      </button>
    </div>
  </div>
</template>

<script setup>
import { defineProps } from 'vue'

const props = defineProps({
  workflows: Object
})
</script>

Copy

Apply

resources\js\Pages\Workflows\Index.vue
B) Builder Page – the main workflow editor:

<template>
  <div class="p-4">
    <h1 class="text-xl font-bold mb-4">
      {{ workflow ? 'Edit Workflow' : 'Create Workflow' }}
    </h1>

    <form @submit.prevent="submitForm">
      <div class="mb-4">
        <label class="block mb-1 font-semibold">Name</label>
        <input v-model="form.name" type="text" class="w-full p-2 rounded border" />
      </div>

      <div class="mb-4">
        <label class="block mb-1 font-semibold">Webhook URL</label>
        <input v-model="form.webhook_url" type="text" class="w-full p-2 rounded border" />
      </div>

      <div class="flex space-x-4">
        <div class="bg-gray-50 p-4 w-1/4 border rounded">
          <!-- Left Sidebar: node types -->
          <h2 class="font-semibold mb-2">Node Types</h2>
          <ul>
            <li v-for="type in nodeTypes" :key="type"
                class="mb-2 cursor-pointer px-2 py-1 bg-green-100 hover:bg-green-200 text-green-800 rounded"
                @click="addNode(type)">
              {{ type }}
            </li>
          </ul>
        </div>

        <div class="bg-white p-4 w-1/2 border rounded">
          <!-- Middle Section: NodeList (sequential) -->
          <NodeList
            :nodes="form.nodes"
            @change="(updatedNodes) => form.nodes = updatedNodes"
            @selectNode="selectNode"
          />
        </div>

        <div class="bg-gray-50 p-4 w-1/4 border rounded">
          <!-- Right Sidebar: NodeConfig -->
          <NodeConfig
            v-if="selectedNodeIndex !== null"
            :node="form.nodes[selectedNodeIndex]"
            :available-vars="getAvailableVars(selectedNodeIndex)"
            @updateNodeConfig="updateNodeConfig"
          />
        </div>
      </div>

      <div class="mt-4">
        <button type="submit" class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600">
          Save
        </button>
      </div>
    </form>
  </div>
</template>

<script setup>
import { reactive, ref

Copy

Apply

resources\js\Pages\Workflows\Builder.vue
geerate the full code for all Vue componentes (builder, index, dashboard, NodeList, nodeConfig




Context
— none fetched
Let me generate full code for all Vue components for this workflow builder system. Based on the context and the request, I'll create:

Builder.vue - The main workflow editor
Index.vue - List of all workflows
Dashboard.vue - Overview dashboard
NodeList.vue - Component to manage the workflow nodes sequence
NodeConfig.vue - Component to configure individual nodes
I'll ensure these are fully functional with Vue 3 composition API and styled appropriately.

Full Vue Component Code for Workflow Builder System
Here's the complete code for all the requested Vue components needed for your workflow builder system:

1. Index.vue - Workflow Listing Page
<template>
  <div class="p-6 space-y-6">
    <div class="flex justify-between items-center">
      <h1 class="text-2xl font-bold text-gray-900">Workflows</h1>
      <Link :href="route('workflows.create')" class="inline-flex items-center px-4 py-2 bg-indigo-600 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-indigo-700 focus:bg-indigo-700 active:bg-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150">
        <PlusIcon class="w-5 h-5 mr-2" />
        Create Workflow
      </Link>
    </div>

    <div class="bg-white shadow-md rounded-lg overflow-hidden">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Webhook URL</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nodes</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Updated</th>
            <th scope="col" class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <tr v-for="workflow in workflows.data" :key="workflow.id" class="hover:bg-gray-50">
            <td class="px-6 py-4 whitespace-nowrap">
              <div class="text-sm font-medium text-gray-900">{{ workflow.name }}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <div v-if="workflow.webhook_url" class="flex items-center">
                <span class="text-sm text-gray-500 truncate max-w-xs">{{ workflow.webhook_url }}</span>
                <button @click="copyToClipboard(workflow.webhook_url)" class="ml-2 text-gray-400 hover:text-gray-600">
                  <ClipboardIcon class="w-4 h-4" />
                </button>
              </div>
              <div v-else class="text-sm text-gray-500">No webhook</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <span :class="[
                'px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full',
                workflow.active ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
              ]">
                {{ workflow.active ? 'Active' : 'Inactive' }}
              </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
              {{ workflow.nodes.length }}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
              {{ formatDate(workflow.updated_at) }}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
              <div class="flex justify-end space-x-2">
                <Link :href="route('workflows.edit', workflow.id)" class="text-indigo-600 hover:text-indigo-900">
                  <PencilIcon class="w-5 h-5" />
                </Link>
                <button @click="confirmDelete(workflow)" class="text-red-600 hover:text-red-900">
                  <TrashIcon class="w-5 h-5" />
                </button>
                <Link :href="route('workflows.test', workflow.id)" class="text-gray-600 hover:text-gray-900">
                  <BeakerIcon class="w-5 h-5" />
                </Link>
              </div>
            </td>
          </tr>
          <tr v-if="workflows.data.length === 0">
            <td colspan="6" class="px-6 py-4 text-center text-sm text-gray-500">
              No workflows found. Click "Create Workflow" to get started.
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Pagination -->
    <div v-if="workflows.meta && workflows.meta.last_page > 1" class="flex items-center justify-between px-4 py-3 bg-white border-t border-gray-200 sm:px-6">
      <div class="flex justify-between flex-1 sm:hidden">
        <Link :href="workflows.links.prev" :class="[!workflows.links.prev ? 'opacity-50 cursor-not-allowed' : '', 'relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50']">
          Previous
        </Link>
        <Link :href="workflows.links.next" :class="[!workflows.links.next ? 'opacity-50 cursor-not-allowed' : '', 'ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50']">
          Next
        </Link>
      </div>
      <div class="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
        <div>
          <p class="text-sm text-gray-700">
            Showing
            <span class="font-medium">{{ workflows.meta.from }}</span>
            to
            <span class="font-medium">{{ workflows.meta.to }}</span>
            of
            <span class="font-medium">{{ workflows.meta.total }}</span>
            results
          </p>
        </div>
        <div>
          <nav class="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
            <Link
              v-for="(link, i) in workflows.meta.links"
              :key="i"
              :href="link.url"
              :class="[
                link.active ? 'bg-indigo-50 border-indigo-500 text-indigo-600' : 'bg-white border-gray-300 text-gray-500 hover:bg-gray-50',
                'relative inline-flex items-center px-4 py-2 border text-sm font-medium'
              ]"
              v-html="link.label"
            />
          </nav>
        </div>
      </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <ConfirmModal
      v-if="workflowToDelete"
      :show="!!workflowToDelete"
      @close="workflowToDelete = null"
      @confirm="deleteWorkflow"
    >
      <template #title>Delete Workflow</template>
      <template #content>
        Are you sure you want to delete the workflow <strong>{{ workflowToDelete?.name }}</strong>? This action cannot be undone.
      </template>
    </ConfirmModal>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { Link, router } from '@inertiajs/vue3';
import { 
  PlusIcon, 
  PencilIcon, 
  TrashIcon, 
  ClipboardIcon,
  BeakerIcon
} from '@heroicons/vue/24/outline';
import ConfirmModal from '@/Components/ConfirmModal.vue';

const props = defineProps({
  workflows: Object,
});

const workflowToDelete = ref(null);

const formatDate = (dateString) => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  }).format(date);
};

const copyToClipboard = (text) => {
  navigator.clipboard.writeText(text);
  // Optional: add toast notification
};

const confirmDelete = (workflow) => {
  workflowToDelete.value = workflow;
};

const deleteWorkflow = () => {
  router.delete(route('workflows.destroy', workflowToDelete.value.id), {
    onSuccess: () => {
      workflowToDelete.value = null;
    },
  });
};
</script>

Copy

Apply

resources\js\Pages\Workflows\Index.vue
2. Builder.vue - Workflow Editor Page
<template>
  <div class="h-screen flex flex-col">
    <!-- Top Navigation -->
    <div class="bg-white border-b border-gray-200 shadow-sm px-6 py-4">
      <div class="flex justify-between items-center">
        <div class="flex items-center space-x-4">
          <Link :href="route('workflows.index')" class="inline-flex items-center text-gray-500 hover:text-gray-700">
            <ArrowLeftIcon class="w-5 h-5 mr-1" />
            Back to Workflows
          </Link>
          <h1 class="text-xl font-semibold text-gray-900">
            {{ workflow ? 'Edit Workflow: ' + workflow.name : 'Create New Workflow' }}
          </h1>
        </div>
        <div class="flex items-center space-x-3">
          <button 
            @click="saveWorkflow" 
            class="inline-flex items-center px-4 py-2 bg-indigo-600 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150"
            :disabled="processing"
          >
            <span v-if="processing">Saving...</span>
            <span v-else>Save Workflow</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
      <!-- Left Sidebar - Node Types -->
      <div class="w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto">
        <div class="p-4">
          <h2 class="text-sm font-medium text-gray-500 uppercase tracking-wider">Workflow Details</h2>
          <div class="mt-2 space-y-3">
            <div>
              <label for="name" class="block text-sm font-medium text-gray-700">Name</label>
              <input 
                id="name" 
                v-model="formState.name" 
                type="text" 
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                placeholder="My Workflow"
              />
            </div>
            
            <div>
              <label for="active" class="flex items-center">
                <input 
                  id="active" 
                  v-model="formState.active" 
                  type="checkbox" 
                  class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <span class="ml-2 text-sm text-gray-700">Active</span>
              </label>
            </div>
          </div>
        </div>

        <div class="px-4 py-3 border-t border-gray-200">
          <h2 class="text-sm font-medium text-gray-500 uppercase tracking-wider">Node Types</h2>
          <div class="mt-2 space-y-2">
            <div
              v-for="nodeType in nodeTypes"
              :key="nodeType.type"
              class="flex items-center p-2 rounded-md cursor-pointer hover:bg-gray-100"
              :class="{ 'opacity-50': !canAddNodeType(nodeType) }"
              @click="canAddNodeType(nodeType) && addNode(nodeType)"
            >
              <div class="flex-shrink-0 h-8 w-8 flex items-center justify-center rounded-md" :class="nodeType.bgClass">
                <component :is="nodeType.icon" class="h-5 w-5" :class="nodeType.iconClass" />
              </div>
              <div class="ml-3">
                <p class="text-sm font-medium text-gray-700">{{ nodeType.label }}</p>
                <p class="text-xs text-gray-500">{{ nodeType.description }}</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Middle - Node List -->
      <div class="flex-1 bg-white p-6 overflow-y-auto">
        <div v-if="formState.nodes.length === 0" class="h-full flex items-center justify-center">
          <div class="text-center">
            <DocumentIcon class="mx-auto h-12 w-12 text-gray-400" />
            <h3 class="mt-2 text-sm font-medium text-gray-900">No nodes yet</h3>
            <p class="mt-1 text-sm text-gray-500">Get started by adding a webhook or scheduler node</p>
          </div>
        </div>
        <NodeList 
          v-else
          :nodes="formState.nodes" 
          :selected-node-index="selectedNodeIndex"
          @select-node="selectNode"
          @remove-node="removeNode"
          @reorder-nodes="reorderNodes"
        />
      </div>

      <!-- Right Sidebar - Node Configuration -->
      <div class="w-96 bg-gray-50 border

Copy

Apply

resources\js\Pages\Workflows\Builder.vue
continue the previous code and complete...




Context
— none fetched
Let me continue with the Builder.vue component and complete all the remaining components as requested.

Let me continue and complete all the requested components:

2. Builder.vue (continued)
      <!-- Right Sidebar - Node Configuration -->
      <div class="w-96 bg-gray-50 border-l border-gray-200 overflow-y-auto">
        <div v-if="selectedNodeIndex !== null" class="p-4">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-sm font-medium text-gray-500 uppercase tracking-wider">
              Configure {{ getNodeTypeLabel(formState.nodes[selectedNodeIndex].type) }}
            </h2>
            <button 
              @click="() => selectedNodeIndex = null" 
              class="text-gray-400 hover:text-gray-600"
            >
              <XMarkIcon class="h-5 w-5" />
            </button>
          </div>
          
          <NodeConfig 
            :node="formState.nodes[selectedNodeIndex]"
            :node-index="selectedNodeIndex"
            :available-variables="getAvailableVariables(selectedNodeIndex)"
            @update:node="updateNodeConfig"
          />
        </div>
        <div v-else class="p-4">
          <div class="text-center py-10">
            <CogIcon class="mx-auto h-12 w-12 text-gray-400" />
            <h3 class="mt-2 text-sm font-medium text-gray-900">No node selected</h3>
            <p class="mt-1 text-sm text-gray-500">Select a node to configure its settings</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, reactive, onMounted } from 'vue';
import { Link, router } from '@inertiajs/vue3';
import { 
  ArrowLeftIcon, 
  DocumentIcon, 
  CogIcon,
  XMarkIcon,
  GlobeAltIcon,
  ClockIcon,
  ArrowPathIcon,
  CodeBracketIcon,
  CloudIcon
} from '@heroicons/vue/24/outline';
import NodeList from '@/Components/Workflow/NodeList.vue';
import NodeConfig from '@/Components/Workflow/NodeConfig.vue';

const props = defineProps({
  workflow: Object,
  errors: Object,
});

const nodeTypes = [
  {
    type: 'webhook',
    label: 'Webhook Trigger',
    description: 'Start workflow with a webhook call',
    icon: GlobeAltIcon,
    bgClass: 'bg-blue-100',
    iconClass: 'text-blue-600',
    isStarter: true,
    max: 1, // Max one webhook node per workflow
  },
  {
    type: 'scheduler',
    label: 'Scheduler',
    description: 'Run workflow on a schedule',
    icon: ClockIcon,
    bgClass: 'bg-purple-100',
    iconClass: 'text-purple-600',
    isStarter: true,
    max: 1, // Max one scheduler node per workflow
  },
  {
    type: 'http',
    label: 'HTTP Request',
    description: 'Make HTTP calls to external APIs',
    icon: CloudIcon,
    bgClass: 'bg-green-100',
    iconClass: 'text-green-600',
    isStarter: false,
  },
  {
    type: 'agent',
    label: 'LaraGent Agent',
    description: 'Execute a LaraGent agent task',
    icon: ArrowPathIcon,
    bgClass: 'bg-orange-100',
    iconClass: 'text-orange-600',
    isStarter: false,
  },
  {
    type: 'code',
    label: 'Custom Code',
    description: 'Run custom PHP code',
    icon: CodeBracketIcon,
    bgClass: 'bg-gray-100',
    iconClass: 'text-gray-600',
    isStarter: false,
  },
  {
    type: 'return',
    label: 'Return Response',
    description: 'Configure response data',
    icon: ArrowLeftIcon,
    bgClass: 'bg-indigo-100',
    iconClass: 'text-indigo-600',
    isStarter: false,
    max: 1, // Max one return node per workflow
  }
];

const processing = ref(false);
const selectedNodeIndex = ref(null);

// Initialize form state
const formState = reactive({
  name: props.workflow?.name || '',
  active: props.workflow?.active ?? true,
  webhook_url: props.workflow?.webhook_url || '',
  webhook_secret: props.workflow?.webhook_secret || '',
  final_response_template: props.workflow?.final_response_template || {},
  nodes: []
});

// Initialize nodes from existing workflow or create default starter
onMounted(() => {
  if (props.workflow?.nodes && props.workflow.nodes.length > 0) {
    formState.nodes = [...props.workflow.nodes];
  }
});

// Get the label for a node type
const getNodeTypeLabel = (type) => {
  const nodeType = nodeTypes.find(nt => nt.type === type);
  return nodeType ? nodeType.label : type;
};

// Check if a specific node type can be added
const canAddNodeType = (nodeType) => {
  // If node type has a max limit, check if we've reached it
  if (nodeType.max !== undefined) {
    const currentCount = formState.nodes.filter(node => node.type === nodeType.type).length;
    if (currentCount >= nodeType.max) return false;
  }
  
  // Starter nodes (webhook, scheduler) must be the first node
  if (nodeType.isStarter && formState.nodes.length > 0) {
    // Only allow if there are no other starter nodes
    const hasStarterNode = formState.nodes.some(node => 
      nodeTypes.find(nt => nt.type === node.type)?.isStarter
    );
    return !hasStarterNode;
  }
  
  // Return node should be the last node
  if (nodeType.type === 'return' && formState.nodes.length > 0) {
    // Check if there's already a return node
    const hasReturnNode = formState.nodes.some(node => node.type === 'return');
    return !hasReturnNode;
  }
  
  return true;
};

// Add a new node
const addNode = (nodeType) => {
  // Create new node with default config based on type
  const newNode = {
    type: nodeType.type,
    sequence: formState.nodes.length,
    config: getDefaultConfigForNodeType(nodeType.type),
    inputs: {},
    outputs: {}
  };
  
  formState.nodes.push(newNode);
  selectedNodeIndex.value = formState.nodes.length - 1;
};

// Get default configuration for a node type
const getDefaultConfigForNodeType = (type) => {
  switch (type) {
    case 'webhook':
      return { 
        path: generateRandomPath(),
      };
    case 'scheduler':
      return { 
        frequency: 'daily',
        time: '00:00',
      };
    case 'http':
      return { 
        url: '',
        method: 'GET',
        headers: {},
        body: {}
      };
    case 'agent':
      return { 
        agent_id: null,
        inputs: {}
      };
    case 'code':
      return {
        code: '<?php\n\n// Input data is available in $data variable\n// Return an array of outputs\nreturn [\n  "result" => $data["input"] ?? null\n];'
      };
    case 'return':
      return {
        status_code: 200,
        headers: {},
        body: {}
      };
    default:
      return {};
  }
};

// Generate a random path for webhook URL
const generateRandomPath = () => {
  return Math.random().toString(36).substring(2, 15);
};

// Remove a node
const removeNode = (index) => {
  formState.nodes.splice(index, 1);
  if (selectedNodeIndex.value === index) {
    selectedNodeIndex.value = null;
  } else if (selectedNodeIndex.value > index) {
    selectedNodeIndex.value--;
  }
};

// Select a node for editing
const selectNode = (index) => {
  selectedNodeIndex.value = index;
};

// Update node configuration
const updateNodeConfig = (updatedNode) => {
  if (selectedNodeIndex.value !== null) {
    formState.nodes[selectedNodeIndex.value] = { ...updatedNode };
  }
};

// Reorder nodes (after drag and drop)
const reorderNodes = (newOrder) => {
  formState.nodes = newOrder;
};

// Get available variables from previous nodes
const getAvailableVariables = (nodeIndex) => {
  const variables = [];
  
  // Only include variables from nodes that come before the current one
  for (let i = 0; i < nodeIndex; i++) {
    const node = formState.nodes[i];
    const nodeType = nodeTypes.find(nt => nt.type === node.type);
    
    // Add node outputs as variables
    const outputs = node.outputs || {};
    Object.keys(outputs).forEach(key => {
      variables.push({
        name: `${i+1}.${key}`,
        description: outputs[key]?.description || key,
        source: {
          nodeIndex: i,
          nodeType: node.type,
          nodeLabel: nodeType?.label || node.type,
          outputKey: key
        }
      });
    });
    
    // Special handling for specific node types
    if (node.type === 'webhook') {
      variables.push({
        name: `${i+1}.payload`,
        description: 'The full webhook payload',
        source: {
          nodeIndex: i,
          nodeType: 'webhook',
          nodeLabel: 'Webhook Trigger',
          outputKey: 'payload'
        }
      });
    }
  }
  
  return variables;
};

// Save the workflow
const saveWorkflow = () => {
  processing.value = true;
  
  // Clean up form data
  const formData = {
    name: formState.name,
    active: formState.active,
    webhook_url: formState.webhook_url,
    webhook_secret: formState.webhook_secret,
    final_response_template: formState.final_response_template,
    nodes: formState.nodes
  };
  
  if (props.workflow) {
    // Update existing workflow
    router.put(route('workflows.update', props.workflow.id), formData, {
      onSuccess: () => {
        processing.value = false;
      },
      onError: () => {
        processing.value = false;
      }
    });
  } else {
    // Create new workflow
    router.post(route('workflows.store'), formData, {
      onSuccess: () => {
        processing.value = false;
      },
      onError: () => {
        processing.value = false;
      }
    });
  }
};
</script>

Copy

Apply

resources\js\Pages\Workflows\Builder.vue
3. NodeList.vue - Component for managing workflow nodes
<template>
  <div class="space-y-4">
    <div
      v-for="(node, index) in nodes"
      :key="index"
      class="border rounded-lg shadow-sm overflow-hidden transition duration-150"
      :class="{
        'border-indigo-500 ring-2 ring-indigo-200': selectedNodeIndex === index,
        'border-gray-200 hover:border-gray-300': selectedNodeIndex !== index
      }"
    >
      <div
        class="px-4 py-3 bg-white cursor-pointer flex items-center justify-between"
        @click="$emit('select-node', index)"
      >
        <div class="flex items-center space-x-3">
          <div class="flex items-center justify-center h-8 w-8 rounded-md" :class="getNodeTypeStyle(node.type).bgClass">
            <component :is="getNodeTypeStyle(node.type).icon" class="h-5 w-5" :class="getNodeTypeStyle(node.type).iconClass" />
          </div>
          <div class="flex flex-col">
            <div class="flex items-center">
              <span class="font-medium text-gray-900">{{ index + 1 }}. {{ getNodeTypeLabel(node.type) }}</span>
              <span v-if="getNodeName(node)" class="ml-2 text-sm text-gray-500">
                {{ getNodeName(node) }}
              </span>
            </div>
            <span class="text-xs text-gray-500">{{ getNodeDescription(node) }}</span>
          </div>
        </div>
        
        <div class="flex items-center space-x-2">
          <button
            v-if="index > 0 && !isStarterNode(nodes[index-1]) && !isReturnNode(node)"
            @click.stop="moveNodeUp(index)"
            class="text-gray-400 hover:text-gray-600 p-1"
            title="Move up"
          >
            <ChevronUpIcon class="h-5 w-5" />
          </button>
          <button
            v-if="index < nodes.length - 1 && !isReturnNode(node) && !isStarterNode(node)"
            @click.stop="moveNodeDown(index)"
            class="text-gray-400 hover:text-gray-600 p-1"
            title="Move down"
          >
            <ChevronDownIcon class="h-5 w-5" />
          </button>
          <button
            v-if="!isRequiredNode(node)"
            @click.stop="$emit('remove-node', index)"
            class="text-gray-400 hover:text-red-600 p-1"
            title="Remove node"
          >
            <TrashIcon class="h-5 w-5" />
          </button>
        </div>
      </div>
      
      <!-- Simple preview of node configuration -->
      <div
        v-if="selectedNodeIndex === index"
        class="px-4 py-3 bg-gray-50 border-t border-gray-200 text-sm"
      >
        <div class="text-gray-500">Selected - Configure this node in the panel on the right</div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { 
  ChevronUpIcon, 
  ChevronDownIcon,
  TrashIcon,
  GlobeAltIcon,
  ClockIcon,
  ArrowPathIcon,
  CodeBracketIcon,
  CloudIcon,
  ArrowLeftIcon
} from '@heroicons/vue/24/outline';

const props = defineProps({
  nodes: {
    type: Array,
    required: true
  },
  selectedNodeIndex: {
    type: Number,
    default: null
  }
});

const emit = defineEmits(['select-node', 'remove-node', 'reorder-nodes']);

// Node type mapping for UI display
const nodeTypeStyles = {
  webhook: {
    icon: GlobeAltIcon,
    bgClass: 'bg-blue-100

Copy

Apply

resources\js\Components\Workflow\NodeList.vue
continue from above and complete the code for resources\js\Components\Workflow\NodeList.vue 




Context
— none fetched
I need to continue the NodeList.vue component from where it was cut off. Let me pick up from the node type styles, complete the component, and ensure it has all the required functionality for managing workflow nodes.

Let me continue the NodeList.vue component:

    icon: GlobeAltIcon,
    bgClass: 'bg-blue-100',
    iconClass: 'text-blue-600',
    label: 'Webhook Trigger'
  },
  scheduler: {
    icon: ClockIcon,
    bgClass: 'bg-purple-100',
    iconClass: 'text-purple-600',
    label: 'Scheduler'
  },
  http: {
    icon: CloudIcon,
    bgClass: 'bg-green-100',
    iconClass: 'text-green-600',
    label: 'HTTP Request'
  },
  agent: {
    icon: ArrowPathIcon,
    bgClass: 'bg-orange-100',
    iconClass: 'text-orange-600',
    label: 'LaraGent Agent'
  },
  code: {
    icon: CodeBracketIcon,
    bgClass: 'bg-gray-100',
    iconClass: 'text-gray-600',
    label: 'Custom Code'
  },
  return: {
    icon: ArrowLeftIcon,
    bgClass: 'bg-indigo-100',
    iconClass: 'text-indigo-600',
    label: 'Return Response'
  }
};

// Get node type styling
const getNodeTypeStyle = (type) => {
  return nodeTypeStyles[type] || {
    icon: CodeBracketIcon,
    bgClass: 'bg-gray-100',
    iconClass: 'text-gray-600'
  };
};

// Get node type display name
const getNodeTypeLabel = (type) => {
  return nodeTypeStyles[type]?.label || type;
};

// Get a readable name for the node based on its configuration
const getNodeName = (node) => {
  switch (node.type) {
    case 'webhook':
      return node.config?.path ? `/${node.config.path}` : '';
    case 'scheduler':
      if (node.config?.frequency) {
        return `${node.config.frequency}${node.config.time ? ` at ${node.config.time}` : ''}`;
      }
      return '';
    case 'http':
      if (node.config?.method && node.config?.url) {
        return `${node.config.method} ${node.config.url.substring(0, 30)}${node.config.url.length > 30 ? '...' : ''}`;
      }
      return '';
    case 'agent':
      return node.config?.agent_name || `Agent #${node.config?.agent_id || '?'}`;
    default:
      return '';
  }
};

// Get a description for the node based on its configuration
const getNodeDescription = (node) => {
  switch (node.type) {
    case 'webhook':
      return 'Receives external webhook requests';
    case 'scheduler':
      return `Runs ${node.config?.frequency || 'on schedule'}`;
    case 'http':
      return node.config?.url 
        ? `Calls ${node.config.url.substring(0, 40)}${node.config.url.length > 40 ? '...' : ''}`
        : 'Makes an HTTP request';
    case 'agent':
      return 'Executes a LaraGent agent';
    case 'code':
      return 'Executes custom PHP code';
    case 'return':
      return `Returns response with status ${node.config?.status_code || 200}`;
    default:
      return '';
  }
};

// Check if node is a starter node (webhook or scheduler)
const isStarterNode = (node) => {
  return node.type === 'webhook' || node.type === 'scheduler';
};

// Check if node is a return node
const isReturnNode = (node) => {
  return node.type === 'return';
};

// Check if node is required in the workflow
const isRequiredNode = (node) => {
  // First node (starter) and last node (if it's a return) are required
  if (props.nodes.length === 0) return false;
  
  if (props.nodes[0] === node && isStarterNode(node)) {
    return true;
  }
  
  if (props.nodes[props.nodes.length - 1] === node && isReturnNode(node)) {
    return true;
  }
  
  return false;
};

// Move a node up in the sequence
const moveNodeUp = (index) => {
  if (index <= 0) return;
  
  const updatedNodes = [...props.nodes];
  const temp = updatedNodes[index];
  updatedNodes[index] = updatedNodes[index - 1];
  updatedNodes[index - 1] = temp;
  
  emit('reorder-nodes', updatedNodes);
  
  // Update selected node index if necessary
  if (props.selectedNodeIndex === index) {
    emit('select-node', index - 1);
  } else if (props.selectedNodeIndex === index - 1) {
    emit('select-node', index);
  }
};

// Move a node down in the sequence
const moveNodeDown = (index) => {
  if (index >= props.nodes.length - 1) return;
  
  const updatedNodes = [...props.nodes];
  const temp = updatedNodes[index];
  updatedNodes[index] = updatedNodes[index + 1];
  updatedNodes[index + 1] = temp;
  
  emit('reorder-nodes', updatedNodes);
  
  // Update selected node index if necessary
  if (props.selectedNodeIndex === index) {
    emit('select-node', index + 1);
  } else if (props.selectedNodeIndex === index + 1) {
    emit('select-node', index);
  }
};
</script>

Copy

Apply

resources\js\Components\Workflow\NodeList.vue
Now let me provide the NodeConfig.vue component to complete your workflow builder system:

<template>
  <div class="space-y-6">
    <!-- Different configuration UI based on node type -->
    <template v-if="node.type === 'webhook'">
      <WebhookNodeConfig 
        :node="node" 
        @update:node="updateNode" 
      />
    </template>
    
    <template v-else-if="node.type === 'scheduler'">
      <SchedulerNodeConfig 
        :node="node" 
        @update:node="updateNode" 
      />
    </template>
    
    <template v-else-if="node.type === 'http'">
      <HttpNodeConfig 
        :node="node" 
        :available-variables="availableVariables"
        @update:node="updateNode" 
      />
    </template>
    
    <template v-else-if="node.type === 'agent'">
      <AgentNodeConfig 
        :node="node" 
        :available-variables="availableVariables"
        @update:node="updateNode" 
      />
    </template>
    
    <template v-else-if="node.type === 'code'">
      <CodeNodeConfig 
        :node="node" 
        :available-variables="availableVariables"
        @update:node="updateNode" 
      />
    </template>
    
    <template v-else-if="node.type === 'return'">
      <ReturnNodeConfig 
        :node="node" 
        :available-variables="availableVariables"
        @update:node="updateNode" 
      />
    </template>
    
    <!-- Outputs section for all node types -->
    <div class="border-t border-gray-200 pt-4 mt-4">
      <h3 class="text-sm font-medium text-gray-900 mb-2">Outputs</h3>
      <p class="text-xs text-gray-500 mb-4">
        Define the output fields this node will provide to subsequent nodes
      </p>
      
      <div class="space-y-3">
        <div v-for="(output, key) in nodeOutputs" :key="key" class="flex items-center">
          <div class="flex-1">
            <input 
              v-model="output.name" 
              type="text" 
              class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              placeholder="Output name"
              @input="updateOutputName(key, output.name)"
            />
          </div>
          
          <div class="flex-1 ml-2">
            <input 
              v-model="output.description" 
              type="text" 
              class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              placeholder="Description"
            />
          </div>
          
          <button
            @click="removeOutput(key)"
            class="ml-2 text-gray-400 hover:text-red-600 p-1"
          >
            <XMarkIcon class="h-5 w-5" />
          </button>
        </div>
        
        <button
          @click="addOutput"
          class="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
        >
          <PlusIcon class="h-4 w-4 mr-1" />
          Add Output
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { XMarkIcon, PlusIcon } from '@heroicons/vue/24/outline';
import WebhookNodeConfig from './NodeConfigs/WebhookNodeConfig.vue';
import SchedulerNodeConfig from './NodeConfigs/SchedulerNodeConfig.vue';
import HttpNodeConfig from './NodeConfigs/HttpNodeConfig.vue';
import AgentNodeConfig from './NodeConfigs/AgentNodeConfig.vue';
import CodeNodeConfig from './NodeConfigs/CodeNodeConfig.vue';
import ReturnNodeConfig from './NodeConfigs/ReturnNodeConfig.vue';

const props = defineProps({
  node: {
    type: Object,
    required: true
  },
  nodeIndex: {
    type: Number,
    required: true
  },
  availableVariables: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['update:node']);

// Local copy of node outputs for editing
const nodeOutputs = ref({});

// Initialize node outputs
onMounted(() => {
  if (props.node.outputs) {
    nodeOutputs.value = { ...props.node.outputs };
  }
  
  // Add default outputs based on node type
  if (Object.keys(nodeOutputs.value).length === 0) {
    addDefaultOutputs();
  }
});

// Add default outputs based on node type
const addDefaultOutputs = () => {
  switch (props.node.type) {
    case 'webhook':
      nodeOutputs.value['payload'] = { 
        name: 'payload', 
        description: 'The full webhook payload'
      };
      break;
    case 'http':
      nodeOutputs.value['response'] = {
        name: 'response',
        description: 'The full HTTP response'
      };
      nodeOutputs.value['body'] = {
        name: 'body',
        description: 'The response body'
      };
      nodeOutputs.value['status'] = {
        name: 'status',
        description: 'The HTTP status code'
      };
      break;
    case 'agent':
      nodeOutputs.value['result'] = {
        name: 'result',
        description: 'The agent execution result'
      };
      break;
    case 'code':
      nodeOutputs.value['result'] = {
        name: 'result',
        description: 'The code execution result'
      };
      break;
  }
  
  // Update the node with default outputs
  updateNode();
};

// Add a new output
const addOutput = () => {
  const newKey = `output_${Date.now()}`;
  nodeOutputs.value[newKey] = {
    name: '',
    description: ''
  };
};

// Remove an output
const removeOutput = (key) => {
  const updatedOutputs = { ...nodeOutputs.value };
  delete updatedOutputs[key];
  nodeOutputs.value = updatedOutputs;
  updateNode();
};

// Update an output's name (and key)
const updateOutputName = (oldKey, newName) => {
  if (!newName) return;
  
  // If name changed, update the key
  if (oldKey !== newName && nodeOutputs.value[oldKey]) {
    const updatedOutputs = {};
    
    // Create new key with same value
    Object.keys(nodeOutputs.value).forEach(key => {
      if (key === oldKey) {
        updatedOutputs[newName] = {
          ...nodeOutputs.value[key],
          name: newName
        };
      } else {
        updatedOutputs[key] = nodeOutputs.value[key];
      }
    });
    
    nodeOutputs.value = updatedOutputs;
    updateNode();
  }
};

// Update the node when configuration changes
const updateNode = () => {
  emit('update:node', {
    ...props.node,
    outputs: { ...nodeOutputs.value }
  });
};
</script>

Copy

Apply

resources\js\Components\Workflow\NodeConfig.vue
Now let's create some of the individual node type configuration components:

<template>
  <div class="space-y-4">
    <div>
      <label class="block text-sm font-medium text-gray-700">Webhook Path</label>
      <div class="mt-1 flex rounded-md shadow-sm">
        <span class="inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 sm:text-sm">
          /webhook/
        </span>
        <input
          v-model="config.path"
          type="text"
          class="flex-1 min-w-0 block w-full px-3 py-2 rounded-none rounded-r-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
          placeholder="unique-path-name"
          @input="updateConfig"
        />
      </div>
      <p class="mt-1 text-xs text-gray-500">
        The full webhook URL will be: {{ webhookFullUrl }}
      </p>
    </div>
    
    <div>
      <label class="block text-sm font-medium text-gray-700">Webhook Secret</label>
      <div class="mt-1 flex rounded-md shadow-sm">
        <input
          v-model="config.secret"
          type="text"
          class="flex-1 min-w-0 block w-

Copy

Apply

resources\js\Components\Workflow\NodeConfigs\WebhookNodeConfig.vue
contine from above and complete the code for resources\js\Components\Workflow\NodeConfig.vue




Context
— none fetched
It looks like I was in the middle of implementing the WebhookNodeConfig.vue component, which is one of the sub-components used by NodeConfig.vue. Let me continue with that code and then complete any remaining components needed for the workflow builder system.

I need to:

Complete WebhookNodeConfig.vue
Provide other node configuration components (SchedulerNodeConfig, HttpNodeConfig, etc.)
I'll structure this properly so all the components work together seamlessly.

Let me continue with the node configuration components:

          v-model="config.secret"
          type="text"
          class="flex-1 min-w-0 block w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
          placeholder="Optional: Add a secret key to validate webhooks"
          @input="updateConfig"
        />
        <button
          @click="generateSecret"
          type="button"
          class="inline-flex items-center px-3 py-2 border border-l-0 border-gray-300 bg-gray-50 text-gray-500 rounded-r-md hover:bg-gray-100 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
        >
          Generate
        </button>
      </div>
      <p class="mt-1 text-xs text-gray-500">
        Use this secret to validate incoming webhook requests
      </p>
    </div>
    
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1">Webhook Method</label>
      <div class="flex space-x-2">
        <label v-for="method in ['POST', 'GET', 'PUT', 'DELETE']" :key="method" class="inline-flex items-center">
          <input 
            type="radio" 
            :value="method" 
            v-model="config.method"
            class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"
            @change="updateConfig"
          />
          <span class="ml-2 text-sm text-gray-700">{{ method }}</span>
        </label>
      </div>
    </div>
  </div>
</template>

<script setup>
import { reactive, computed } from 'vue';

const props = defineProps({
  node: {
    type: Object,
    required: true
  }
});

const emit = defineEmits(['update:node']);

// Create a reactive copy of node.config
const config = reactive({
  path: props.node.config?.path || '',
  secret: props.node.config?.secret || '',
  method: props.node.config?.method || 'POST',
});

// Compute the full webhook URL
const webhookFullUrl = computed(() => {
  const baseUrl = window.location.origin;
  return `${baseUrl}/api/webhook/${config.path}`;
});

// Generate a random secret
const generateSecret = () => {
  const bytes = new Uint8Array(32);
  window.crypto.getRandomValues(bytes);
  config.secret = Array.from(bytes)
    .map(byte => byte.toString(16).padStart(2, '0'))
    .join('');
  
  updateConfig();
};

// Update the node configuration
const updateConfig = () => {
  emit('update:node', {
    ...props.node,
    config: { ...config }
  });
};
</script>

Copy

Apply

resources\js\Components\Workflow\NodeConfigs\WebhookNodeConfig.vue
<template>
  <div class="space-y-4">
    <div>
      <label class="block text-sm font-medium text-gray-700">Schedule Frequency</label>
      <select
        v-model="config.frequency"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        @change="updateConfig"
      >
        <option value="minutely">Every Minute</option>
        <option value="hourly">Hourly</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="monthly">Monthly</option>
        <option value="custom">Custom (CRON)</option>
      </select>
    </div>
    
    <div v-if="config.frequency === 'weekly'">
      <label class="block text-sm font-medium text-gray-700">Day of Week</label>
      <select
        v-model="config.day_of_week"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        @change="updateConfig"
      >
        <option value="0">Sunday</option>
        <option value="1">Monday</option>
        <option value="2">Tuesday</option>
        <option value="3">Wednesday</option>
        <option value="4">Thursday</option>
        <option value="5">Friday</option>
        <option value="6">Saturday</option>
      </select>
    </div>
    
    <div v-if="config.frequency === 'monthly'">
      <label class="block text-sm font-medium text-gray-700">Day of Month</label>
      <select
        v-model="config.day_of_month"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        @change="updateConfig"
      >
        <option v-for="day in 31" :key="day" :value="day">{{ day }}</option>
      </select>
    </div>
    
    <div v-if="['daily', 'weekly', 'monthly'].includes(config.frequency)">
      <label class="block text-sm font-medium text-gray-700">Time</label>
      <input
        v-model="config.time"
        type="time"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        @input="updateConfig"
      />
    </div>
    
    <div v-if="config.frequency === 'custom'">
      <label class="block text-sm font-medium text-gray-700">CRON Expression</label>
      <input
        v-model="config.cron"
        type="text"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        placeholder="* * * * *"
        @input="updateConfig"
      />
      <p class="mt-1 text-xs text-gray-500">
        Standard CRON expression format (minute hour day-of-month month day-of-week)
      </p>
    </div>
  </div>
</template>

<script setup>
import { reactive } from 'vue';

const props = defineProps({
  node: {
    type: Object,
    required: true
  }
});

const emit = defineEmits(['update:node']);

// Create a reactive copy of node.config
const config = reactive({
  frequency: props.node.config?.frequency || 'daily',
  time: props.node.config?.time || '00:00',
  day_of_week: props.node.config?.day_of_week || '1',
  day_of_month: props.node.config?.day_of_month || '1',
  cron: props.node.config?.cron || '* * * * *',
});

// Update the node configuration
const updateConfig = () => {
  emit('update:node', {
    ...props.node,
    config: { ...config }
  });
};
</script>

Copy

Apply

resources\js\Components\Workflow\NodeConfigs\SchedulerNodeConfig.vue
<template>
  <div class="space-y-4">
    <div>
      <label class="block text-sm font-medium text-gray-700">Request URL</label>
      <input
        v-model="config.url"
        type="text"
        class="mt-1 block w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
        placeholder="https://api.example.com/endpoint"
        @input="updateConfig"
      />
      <p class="mt-1 text-xs text-gray-500">
        You can use variables from previous nodes using <code>{variable_name}</code> syntax
      </p>
    </div>
    
    <div>
      <label class="block text-sm font-medium text-gray-700">HTTP Method</label>
      <select
        v-model="config.method"
        class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
        @change="updateConfig"
      >
        <option value="GET">GET</option>
        <option value="POST">POST</option>
        <option value="PUT">PUT</option>
        <option value="PATCH">PATCH</option>
        <option value="DELETE">DELETE</option>
      </select>
    </div>
    
    <div class="border-t border-gray-200 pt-4">
      <h3 class="text-sm font-medium text-gray-900 mb-2">Headers</h3>
      <div class="space-y-2">
        <div v-for="(header, index) in headers" :key="index" class="flex items-center space-x-2">
          <input
            v-model="header.key"
            type="text"
            class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder="Header Name"
            @input="updateHeaders"
          />
          <input
            v-model="header.value"
            type="text"
            class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            placeholder="Value"
            @input="updateHeaders"
          />
          <button
            @click="removeHeader(index)"
            type="button"
            class="inline-flex items-center p-1 border border-transparent rounded-full text-gray-400 hover:text-red-500 focus:outline-none"
          >
            <XMarkIcon class="h-5 w-5" />
          </button>
        </div>
        <button
          @click="addHeader"
          type="button"
          class="inline-flex items-center px-3 py-1 border border-gray-300 text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
        >
          <PlusIcon class="h-4 w-4 mr-1" />
          Add Header
        </button>
      </div>
    </div>
    
    <div v-if="['POST', 'PUT', 'PATCH'].includes(config.method)" class="border-t border-gray-200 pt-4">
      <h3 class="text-sm font-medium text-gray-900 mb-2">Request Body</h3>
      <div class="space-y-3">
        <div>
          <label class="block text-sm font-medium text-gray-700">Body Type</label>
          <select
            v-model="config.bodyType"
            class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
            @change="updateConfig"
          >
            <option value="json">JSON</option>
            <option value="form">Form Data</option>
            <option value="raw">Raw</option>
          </select>
        </div>
        
        <template v-if="config.bodyType === 'json'">
          <div class="space-y-2">
            <div v-for="(param, index) in bodyParams" :key="index" class="flex items-center space-x-2">
              <input
                v-model="param.key"
                type="text"
                class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                placeholder="Key"
                @input="updateBodyParams"
              />
              <div class="w-full relative">
                <input
                  v-model="param.value"
                  type="text"
                  class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                  placeholder="Value or {variable}"
                  @input="updateBodyParams"
                />
                <div v-if="availableVariables.length > 0" class="absolute inset-y-0 right-0 flex items-center pr-2">
                  <select
                    @change="insertVariable($event, param, 'value')"
                    class="h-full py-0 pl-1 pr-7 border-transparent bg-transparent text-gray-500 sm:text-sm rounded-md"
                  >
                    <option value="">Insert variable...</option>
                    <option v-for="variable in availableVariables" :key="variable.name" :value="variable.name">
                      {{ variable.name }}
                    </option>
                  </select>
                </div>
              </div>
              <button
                @click="removeBodyParam(index)"
                type="button"
                class="inline-flex items-center p-1 border border-transparent rounded-full text-gray-400 hover:text-red-500 focus:outline-none"
              >
                <XMarkIcon class="h-5 w-5" />
              </button>
            </div>
            <button
              @click="addBodyParam"
              type="button"
              class="inline-flex items-center px-3 py-1 border border-gray-300 text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              <PlusIcon class="h-4 w-4 mr-1" />
              Add Parameter
            </button>

Copy

Apply

resources\js\Components\Workflow\NodeConfigs\HttpNodeConfig.vue
continue from above and complete the code for resources\js\Components\Workflow\HttpNodeConfig.vue




Context
— none fetched
Let me continue implementing the HttpNodeConfig.vue component. I need to:

Complete the template portion for the different body types
Add the script section with reactive state
Add methods for handling the various node config operations
Let me complete the HttpNodeConfig.vue component:

            </button>
          </div>
        </template>
        
        <template v-if="config.bodyType === 'form'">
          <div class="space-y-2">
            <div v-for="(param, index) in bodyParams" :key="index" class="flex items-center space-x-2">
              <input
                v-model="param.key"
                type="text"
                class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                placeholder="Field name"
                @input="updateBodyParams"
              />
              <div class="w-full relative">
                <input
                  v-model="param.value"
                  type="text"
                  class="w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                  placeholder="Value or {variable}"
                  @input="updateBodyParams"
                />
                <div v-if="availableVariables.length > 0" class="absolute inset-y-0 right-0 flex items-center pr-2">
                  <select
                    @change="insertVariable($event, param, 'value')"
                    class="h-full py-0 pl-1 pr-7 border-transparent bg-transparent text-gray-500 sm:text-sm rounded-md"
                  >
                    <option value="">Insert variable...</option>
                    <option v-for="variable in availableVariables" :key="variable.name" :value="variable.name">
                      {{ variable.name }}
                    </option>
                  </select>
                </div>
              </div>
              <button
                @click="removeBodyParam(index)"
                type="button"
                class="inline-flex items-center p-1 border border-transparent rounded-full text-gray-400 hover:text-red-500 focus:outline-none"
              >
                <XMarkIcon class="h-5 w-5" />
              </button>
            </div>
            <button
              @click="addBodyParam"
              type="button"
              class="inline-flex items-center px-3 py-1 border border-gray-300 text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              <PlusIcon class="h-4 w-4 mr-1" />
              Add Field
            </button>
          </div>
        </template>
        
        <template v-if="config.bodyType === 'raw'">
          <div class="space-y-2">
            <div>
              <label class="block text-sm font-medium text-gray-700">Content Type</label>
              <select
                v-model="config.rawContentType"
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                @change="updateConfig"
              >
                <option value="application/json">JSON (application/json)</option>
                <option value="text/plain">Text (text/plain)</option>
                <option value="application/xml">XML (application/xml)</option>
                <option value="application/javascript">JavaScript (application/javascript)</option>
                <option value="text/html">HTML (text/html)</option>
              </select>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">Raw Body</label>
              <textarea
                v-model="config.rawBody"
                rows="5"
                class="mt-1 block w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                placeholder="Enter raw request body"
                @input="updateConfig"
              ></textarea>
            </div>
            <div v-if="availableVariables.length > 0">
              <label class="block text-sm font-medium text-gray-700">Insert Variable</label>
              <div class="mt-1 flex rounded-md shadow-sm">
                <select
                  @change="insertVariableToRawBody($event)"
                  class="block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                >
                  <option value="">Select a variable...</option>
                  <option v-for="variable in availableVariables" :key="variable.name" :value="variable.name">
                    {{ variable.name }} - {{ variable.description }}
                  </option>
                </select>
                <button
                  @click="insertSelectedVariable"
                  type="button"
                  class="inline-flex items-center px-3 py-2 border border-l-0 border-gray-300 bg-gray-50 text-gray-500 rounded-r-md hover:bg-gray-100 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                >
                  Insert
                </button>
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>
    
    <div class="border-t border-gray-200 pt-4">
      <h3 class="text-sm font-medium text-gray-900 mb-2">Advanced Options</h3>
      <div class="space-y-3">
        <div>
          <label class="flex items-center">
            <input 
              type="checkbox"
              v-model="config.followRedirects"
              class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
              @change="updateConfig"
            />
            <span class="ml-2 text-sm text-gray-700">Follow Redirects</span>
          </label>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-gray-700">Timeout (seconds)</label>
          <input
            v-model.number="config.timeout"
            type="number"
            min="1"
            max="300"
            class="mt-1 block w-full px-3 py-2 rounded-md border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
            @input="updateConfig"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { reactive, ref, onMounted } from 'vue';
import { XMarkIcon, PlusIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  node: {
    type: Object,
    required: true
  },
  availableVariables: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['update:node']);

// Create a reactive copy of node.config
const config = reactive({
  url: props.node.config?.url || '',
  method: props.node.config?.method || 'GET',
  bodyType: props.node.config?.bodyType || 'json',
  rawContentType: props.node.config?.rawContentType || 'application/json',
  rawBody: props.node.config?.rawBody || '',
  followRedirects: props.node.config?.followRedirects !== false,
  timeout: props.node.config?.timeout || 30,
});

// Headers and body parameters
const headers = ref([]);
const bodyParams = ref([]);
const selectedVariable = ref('');

// Initialize headers and body params from config
onMounted(() => {
  // Convert headers object to array of key-value pairs
  if (props.node.config?.headers && typeof props.node.config.headers === 'object') {
    headers.value = Object.entries(props.node.config.headers).map(([key, value]) => ({ key, value }));
  }
  
  if (headers.value.length === 0) {
    headers.value.push({ key: '', value: '' });
  }
  
  // Convert body params object to array of key-value pairs
  if (props.node.config?.body && typeof props.node.config.body === 'object') {
    bodyParams.value = Object.entries(props.node.config.body).map(([key, value]) => ({ key, value }));
  }
  
  if (bodyParams.value.length === 0 && ['POST', 'PUT', 'PATCH'].includes(config.method)) {
    bodyParams.value.push({ key: '', value: '' });
  }
});

// Update the node configuration
const updateConfig = () => {
  const headersObj = {};
  headers.value.forEach(header => {
    if (header.key.trim() !== '') {
      headersObj[header.key] = header.value;
    }
  });
  
  const bodyObj = {};
  if (['POST', 'PUT', 'PATCH'].includes(config.method) && config.bodyType === 'json') {
    bodyParams.value.forEach(param => {
      if (param.key.trim() !== '') {
        bodyObj[param.key] = param.value;
      }
    });
  }
  
  emit('update:node', {
    ...props.node,
    config: {
      ...config,
      headers: headersObj,
      body: config.bodyType === 'json' || config.bodyType === 'form' ? bodyObj : undefined,
    }
  });
};

// Update headers
const updateHeaders = () => {
  // Ensure there's always an empty row at the end for new headers
  if (headers.value.every(header => header.key.trim() !== '' && header.value.trim() !== '')) {
    headers.value.push({ key: '', value: '' });
  }
  
  updateConfig();
};

// Add a new header
const addHeader = () => {
  headers.value.push({ key: '', value: '' });
};

// Remove a header
const removeHeader = (index) => {
  headers.value.splice(index, 1);
  if (headers.value.length === 0) {
    headers.value.push({ key: '', value: '' });
  }
  updateConfig();
};

// Update body parameters
const updateBodyParams = () => {
  // Ensure there's always an empty row at the end for new params
  if (bodyParams.value.every(param => param.key.trim() !== '')) {
    bodyParams.value.push({ key: '', value: '' });
  }
  
  updateConfig();
};

// Add a new body parameter
const addBodyParam = () => {
  bodyParams.value.push({ key: '', value: '' });
};

// Remove a body parameter
const removeBodyParam = (index) => {
  bodyParams.value.splice(index, 1);
  if (bodyParams.value.length === 0) {
    bodyParams.value.push({ key: '', value: '' });
  }
  updateConfig();
};

// Insert a variable into a field
const insertVariable = (event, param, field) => {
  if (event.target.value) {
    param[field] = param[field] || '';
    param[field] += `{${event.target.value}}`;
    updateBodyParams();
    event.target.value = ''; // Reset the select
  }
};

// Insert a variable into the raw body textarea
const insertVariableToRawBody = (event) => {
  selectedVariable.value = event.target.value;
  event.target.value = ''; // Reset the select
};

// Insert the selected variable into the raw body
const insertSelectedVariable = () => {
  if (selectedVariable.value) {
    const variableText = `{${selectedVariable.value}}`;
    const textarea = document.querySelector('textarea');
    const startPos = textarea.selectionStart;
    const endPos = textarea.selectionEnd;
    
    config.rawBody = config.rawBody.substring(0, startPos) 
                     + variableText 
                     + config.rawBody.substring(endPos);
    
    updateConfig();
    selectedVariable.value = '';
  }
};
</script>

Copy

Apply

resources\js\Components\Workflow\NodeConfigs\HttpNodeConfig.vue
Now let me create the Dashboard.vue component to complete the workflow builder system:

<template>
  <div class="p-6 space-y-8">
    <div class="flex justify-between items-center">
      <h1 class="text-2xl font-bold text-gray-900">Workflow Dashboard</h1>
      <Link :href="route('workflows.index')" class="inline-flex items-center px-4 py-2 bg-indigo-600 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-indigo-700 focus:bg-indigo-700 active:bg-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150">
        Manage Workflows
      </Link>
    </div>

    <!-- Stats Cards -->
    <div class="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-4">
      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="px-4 py-5 sm:p-6">
          <div class="flex items-center">
            <div class="flex-shrink-0 bg-indigo-500 rounded-md p-3">
              <DocumentDuplicateIcon class="h-6 w-6 text-white" />
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Total Workflows</dt>
                <dd class="flex items-baseline">
                  <div class="text-2xl font-semibold text-gray-900">{{ stats.total_workflows }}</div>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="px-4 py-5 sm:p-6">
          <div class="flex items-center">
            <div class="flex-shrink-0 bg-green-500 rounded-md p-3">
              <CheckCircleIcon class="h-6 w-6 text-white" />
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Active Workflows</dt>
                <dd class="flex items-baseline">
                  <div class="text-2xl font-semibold text-gray-900">{{ stats.active_workflows }}</div>
                </dd>

Copy

Apply

resources\js\Pages\Workflows\Dashboard.vue
please continue from above and complete the code for resources\js\Pages\Workflows\Dashboard.vue




Context
— none fetched
I need to continue the Workflows Dashboard.vue component. I should complete:

The rest of the stats cards
The recent executions section
The most active workflows section
Add the script section with necessary imports and data setup
Let me make sure to structure this properly to match the existing code style.

Let me continue the Workflows Dashboard.vue component:

                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="px-4 py-5 sm:p-6">
          <div class="flex items-center">
            <div class="flex-shrink-0 bg-yellow-500 rounded-md p-3">
              <ClockIcon class="h-6 w-6 text-white" />
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Executions Today</dt>
                <dd class="flex items-baseline">
                  <div class="text-2xl font-semibold text-gray-900">{{ stats.executions_today }}</div>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="px-4 py-5 sm:p-6">
          <div class="flex items-center">
            <div class="flex-shrink-0 bg-blue-500 rounded-md p-3">
              <BoltIcon class="h-6 w-6 text-white" />
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Total Executions</dt>
                <dd class="flex items-baseline">
                  <div class="text-2xl font-semibold text-gray-900">{{ stats.total_executions }}</div>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Dashboard Content -->
    <div class="grid grid-cols-1 gap-6 lg:grid-cols-2">
      <!-- Recent Executions -->
      <div class="bg-white shadow rounded-lg">
        <div class="px-4 py-5 border-b border-gray-200 sm:px-6">
          <h3 class="text-lg font-medium leading-6 text-gray-900">Recent Executions</h3>
        </div>
        <div class="overflow-hidden">
          <ul v-if="recentExecutions.length > 0" class="divide-y divide-gray-200">
            <li v-for="execution in recentExecutions" :key="execution.id" class="px-4 py-4 sm:px-6 hover:bg-gray-50">
              <div class="flex items-center justify-between">
                <div class="truncate">
                  <div class="flex items-center">
                    <p class="font-medium text-indigo-600 truncate">{{ execution.workflow.name }}</p>
                    <div :class="`ml-2 flex-shrink-0 flex rounded-full px-2 py-0.5 text-xs font-medium ${getStatusClass(execution.status)}`">
                      {{ execution.status }}
                    </div>
                  </div>
                  <div class="mt-1 flex items-center text-sm text-gray-500">
                    <ClockIcon class="flex-shrink-0 mr-1.5 h-4 w-4 text-gray-400" />
                    <span>{{ formatDateTime(execution.created_at) }}</span>
                    <span v-if="execution.duration" class="ml-3">
                      ({{ formatDuration(execution.duration) }})
                    </span>
                  </div>
                </div>
                <div>
                  <Link :href="route('workflows.executions.show', execution.id)" class="inline-flex items-center px-3 py-1 border border-gray-300 text-sm leading-5 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Details
                  </Link>
                </div>
              </div>
            </li>
          </ul>
          <div v-else class="px-4 py-8 text-center text-gray-500">
            <InboxIcon class="mx-auto h-12 w-12 text-gray-400" />
            <h3 class="mt-2 text-sm font-medium text-gray-900">No executions yet</h3>
            <p class="mt-1 text-sm text-gray-500">Get started by creating and running your first workflow.</p>
          </div>
        </div>
        <div v-if="recentExecutions.length > 0" class="bg-gray-50 px-4 py-3 border-t border-gray-200 text-center">
          <Link :href="route('workflows.executions.index')" class="text-sm font-medium text-indigo-600 hover:text-indigo-500">
            View all executions
            <span aria-hidden="true">&rarr;</span>
          </Link>
        </div>
      </div>

      <!-- Most Active Workflows -->
      <div class="bg-white shadow rounded-lg">
        <div class="px-4 py-5 border-b border-gray-200 sm:px-6">
          <h3 class="text-lg font-medium leading-6 text-gray-900">Most Active Workflows</h3>
        </div>
        <div class="overflow-hidden">
          <ul v-if="activeWorkflows.length > 0" class="divide-y divide-gray-200">
            <li v-for="workflow in activeWorkflows" :key="workflow.id" class="px-4 py-4 sm:px-6 hover:bg-gray-50">
              <div class="flex items-center justify-between">
                <div class="truncate">
                  <div class="flex items-center">
                    <p class="font-medium text-indigo-600 truncate">{{ workflow.name }}</p>
                    <div v-if="workflow.active" class="ml-2 flex-shrink-0 flex rounded-full bg-green-100 px-2 py-0.5 text-xs font-medium text-green-800">
                      Active
                    </div>
                    <div v-else class="ml-2 flex-shrink-0 flex rounded-full bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-800">
                      Inactive
                    </div>
                  </div>
                  <div class="mt-1 flex items-center text-sm text-gray-500">
                    <ChartBarIcon class="flex-shrink-0 mr-1.5 h-4 w-4 text-gray-400" />
                    <span>{{ workflow.execution_count }} executions</span>
                    <span v-if="workflow.last_executed_at" class="ml-3">
                      Last run: {{ formatDate(workflow.last_executed_at) }}
                    </span>
                  </div>
                </div>
                <div>
                  <Link :href="route('workflows.edit', workflow.id)" class="inline-flex items-center px-3 py-1 border border-gray-300 text-sm leading-5 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Edit
                  </Link>
                </div>
              </div>
            </li>
          </ul>
          <div v-else class="px-4 py-8 text-center text-gray-500">
            <DocumentIcon class="mx-auto h-12 w-12 text-gray-400" />
            <h3 class="mt-2 text-sm font-medium text-gray-900">No workflows found</h3>
            <p class="mt-1 text-sm text-gray-500">Get started by creating your first workflow.</p>
            <div class="mt-6">
              <Link :href="route('workflows.create')" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                <PlusIcon class="-ml-1 mr-2 h-5 w-5" aria-hidden="true" />
                New Workflow
              </Link>
            </div>
          </div>
        </div>
        <div v-if="activeWorkflows.length > 0" class="bg-gray-50 px-4 py-3 border-t border-gray-200 text-center">
          <Link :href="route('workflows.index')" class="text-sm font-medium text-indigo-600 hover:text-indigo-500">
            View all workflows
            <span aria-hidden="true">&rarr;</span>
          </Link>
        </div>
      </div>
    </div>

    <!-- Quick Actions -->
    <div class="bg-white shadow rounded-lg overflow-hidden">
      <div class="px-4 py-5 border-b border-gray-200 sm:px-6">
        <h3 class="text-lg font-medium leading-6 text-gray-900">Quick Actions</h3>
      </div>
      <div class="px-4 py-5 sm:p-6">
        <div class="grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3">
          <Link :href="route('workflows.create')" class="relative rounded-lg border border-gray-300 bg-white px-6 py-5 shadow-sm flex items-center space-x-3 hover:border-gray-400 focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
            <div class="flex-shrink-0">
              <PlusIcon class="h-6 w-6 text-indigo-600" />
            </div>
            <div class="flex-1 min-w-0">
              <span class="absolute inset-0" aria-hidden="true"></span>
              <p class="text-sm font-medium text-gray-900">Create New Workflow</p>
              <p class="text-sm text-gray-500">Build a custom automation flow</p>
            </div>
          </Link>

          <Link :href="route('workflows.executions.index')" class="relative rounded-lg border border-gray-300 bg-white px-6 py-5 shadow-sm flex items-center space-x-3 hover:border-gray-400 focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
            <div class="flex-shrink-0">
              <ClockIcon class="h-6 w-6 text-yellow-500" />
            </div>
            <div class="flex-1 min-w-0">
              <span class="absolute inset-0" aria-hidden="true"></span>
              <p class="text-sm font-medium text-gray-900">View Execution History</p>
              <p class="text-sm text-gray-500">Monitor all workflow executions</p>
            </div>
          </Link>

          <Link :href="route('workflows.docs')" class="relative rounded-lg border border-gray-300 bg-white px-6 py-5 shadow-sm flex items-center space-x-3 hover:border-gray-400 focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
            <div class="flex-shrink-0">
              <DocumentTextIcon class="h-6 w-6 text-blue-500" />
            </div>
            <div class="flex-1 min-w-0">
              <span class="absolute inset-0" aria-hidden="true"></span>
              <p class="text-sm font-medium text-gray-900">Documentation</p>
              <p class="text-sm text-gray-500">Learn how to build workflows</p>
            </div>
          </Link>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { Link } from '@inertiajs/vue3';
import { 
  DocumentDuplicateIcon, 
  CheckCircleIcon, 
  ClockIcon, 
  BoltIcon,
  ChartBarIcon,
  DocumentIcon,
  InboxIcon,
  PlusIcon,
  DocumentTextIcon 
} from '@heroicons/vue/24/outline';

const props = defineProps({
  stats: {
    type: Object,
    default: () => ({
      total_workflows: 0,
      active_workflows: 0,
      executions_today: 0,
      total_executions: 0
    })
  },
  recentExecutions: {
    type: Array,
    default: () => []
  },
  activeWorkflows: {
    type: Array,
    default: () => []
  }
});

// Format date and time
const formatDateTime = (dateString) => {
  if (!dateString) return '';
  const date = new Date(dateString);
  return date.toLocaleString();
};

// Format date only
const formatDate = (dateString) => {
  if (!dateString) return '';
  const date = new Date(dateString);
  return date.toLocaleDateString();
};

// Format duration in milliseconds to readable string
const formatDuration = (milliseconds) => {
  if (!milliseconds) return '';
  
  const seconds = Math.floor(milliseconds / 1000);
  if (seconds < 60) {
    return `${seconds} sec`;
  }
  
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  if (minutes < 60) {
    return `${minutes}m ${remainingSeconds}s`;
  }
  
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  
  return `${hours}h ${remainingMinutes}m`;
};

// Get CSS class for execution status
const getStatusClass = (status) => {
  switch (status.toLowerCase()) {
    case 'success':
      return 'bg-green-100 text-green-800';
    case 'failed':
    case 'error':
      return 'bg-red-100 text-red-800';
    case 'running':
      return 'bg-blue-100 text-blue-800';
    case 'pending':
      return 'bg-yellow-100 text-yellow-800';
    default:
      return 'bg-gray-100 text-gray-800';
  }
};
</script>

Copy

Apply

resources\js\Pages\Workflows\Dashboard.vue
Let me also provide a simplified version of the CodeNodeConfig component to complete the workflow builder system:

At present LaraGent package is allowing creation of different agents using the agents class with properties for instruction and tooling or private methods to have fixed definition for the agents instruction, tool. However i want to create a Agentdynamic config model that will save the agent as a dynamic config with instruction, templarature, optional tools, model (including available Prism Models). AgentDynamicConfig will be stored in the database. When a new agent is created from front end saas user will select  instruction, templarature, optional tools, model (including available Prism Models) from dynamic drop drop down and it will be saved against saas user scope. Now for a chat completion or a workflow node in the above workflow Builder.js node saas user can select a dynamicagent created by itself from the drop down. Define the file directosy structure  with files required to achieve this in the existing laravel filament larafast repo. 




Context
— none fetched
Below is an example of how you could organize the new “AgentDynamicConfig” feature within your existing Laravel + Filament + LaraFast repo, referencing the existing directory structure and naming conventions. This includes:

• A new migration to create the agent_dynamic_configs table.
• A new Eloquent model (AgentDynamicConfig).
• A Filament resource for listing, creating, editing, and deleting dynamic configs.
• Usage in workflows, for example by referencing agent_dynamic_config_id in a node.

You can adapt class names, namespaces, or file paths to match your specific project’s conventions.

Migration: database/migrations/2023_10_01_000000_create_agent_dynamic_configs_table.php
Create the new table that stores the dynamic agent configurations:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('agent_dynamic_configs', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('user_id')->index(); // references the owner (SaaS user)
            $table->string('name'); // a name or label for the agent
            $table->text('instruction');
            $table->float('temperature')->default(0.7);
            $table->json('tools')->nullable(); // optional: store any tools required
            $table->string('model')->default('gpt-3.5-turbo'); // or “prism-model-x”
            $table->timestamps();

            // If you have users table:
            // $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('agent_dynamic_configs');
    }
};

Copy

Apply

database\migrations\2023_10_01_000000_create_agent_dynamic_configs_table.php
Eloquent Model: app/Models/AgentDynamicConfig.php
Create the model representing the agent dynamic config. Adjust the namespace as needed:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class AgentDynamicConfig extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'name',
        'instruction',
        'temperature',
        'tools',
        'model',
    ];

    protected $casts = [
        'tools' => 'array',
        'temperature' => 'float',
    ];

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

Copy

Apply

app\Models\AgentDynamicConfig.php
Filament Resource: app/Filament/Resources/AgentDynamicConfigResource.php
Create a Filament resource to manage these dynamic configs in the Filament admin panel:

<?php

namespace App\Filament\Resources;

use App\Filament\Resources\AgentDynamicConfigResource\Pages;
use App\Models\AgentDynamicConfig;
use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Resources\Table;

class AgentDynamicConfigResource extends Resource
{
    protected static ?string $model = AgentDynamicConfig::class;

    protected static ?string $navigationIcon = 'heroicon-o-cog';
    protected static ?string $navigationLabel = 'Dynamic Agents';
    protected static ?string $pluralModelLabel = 'Dynamic Agents';
    protected static ?string $modelLabel = 'Dynamic Agent';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->label('Agent Name')
                    ->required(),
                Forms\Components\Textarea::make('instruction')
                    ->label('Instruction')
                    ->rows(4)
                    ->required(),
                Forms\Components\TextInput::make('temperature')
                    ->default(0.7)
                    ->numeric()
                    ->step(0.1)
                    ->minValue(0)
                    ->maxValue(2.0),
                Forms\Components\Select::make('model')
                    ->options([
                        'gpt-3.5-turbo' => 'GPT 3.5 Turbo',
                        'gpt-4' => 'GPT-4',
                        'prism-model-alpha' => 'Prism Alpha',
                        'prism-model-beta' => 'Prism Beta',
                        // add more as needed
                    ])
                    ->label('Model')
                    ->default('gpt-3.5-turbo'),
                Forms\Components\Repeater::make('tools')
                    ->schema([
                        Forms\Components\TextInput::make('name')
                            ->label('Tool Name')
                            ->required(),
                        Forms\Components\TextInput::make('params')
                            ->label('Tool Params')
                            ->placeholder('JSON object or string')
                            ->hint('Optional parameters for the tool'),
                    ])
                    ->label('Tools')
                    ->collapsible()
                    ->default([]),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('name')
                    ->label('Agent Name')
                    ->searchable()
                    ->sortable(),
                Tables\Columns\TextColumn::make('model')
                    ->label('Model')
                    ->searchable()
                    ->sortable(),
                Tables\Columns\TextColumn::make('temperature')
                    ->sortable(),
                Tables\Columns\TextColumn::make('user.name')
                    ->label('User')
                    ->searchable()
                    ->sortable(),
                Tables\Columns\TextColumn::make('created_at')
                    ->label('Created')
                    ->dateTime()
                    ->sortable(),
            ])
            ->filters([
                // define any filters here
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }

    public static function getRelations(): array
    {
        return [
            // Define any relationship managers if needed
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ListAgentDynamicConfigs::route('/'),
            'create' => Pages\CreateAgentDynamicConfig::route('/create'),
            'edit' => Pages\EditAgentDynamicConfig::route('/{record}/edit'),
        ];
    }
}

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource.php
Resource Pages: app\Filament\Resources\AgentDynamicConfigResource\Pages
Within that directory, define the “List”, “Create”, and “Edit” pages. For the sake of brevity:

• ListAgentDynamicConfigs
• CreateAgentDynamicConfig
• EditAgentDynamicConfig

Example:

<?php

namespace App\Filament\Resources\AgentDynamicConfigResource\Pages;

use App\Filament\Resources\AgentDynamicConfigResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\ListRecords;

class ListAgentDynamicConfigs extends ListRecords
{
    protected static string $resource = AgentDynamicConfigResource::class;

    protected function getActions(): array
    {
        return [
            Actions\CreateAction::make(),
        ];
    }
}

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource\Pages\ListAgentDynamicConfigs.php
<?php

namespace App\Filament\Resources\AgentDynamicConfigResource\Pages;

use App\Filament\Resources\AgentDynamicConfigResource;
use Filament\Resources\Pages\CreateRecord;

class CreateAgentDynamicConfig extends CreateRecord
{
    protected static string $resource = AgentDynamicConfigResource::class;

    protected function mutateFormDataBeforeCreate(array $data): array
    {
        // Attach user_id automatically if needed
        $data['user_id'] = auth()->id();
        return $data;
    }
}

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource\Pages\CreateAgentDynamicConfig.php
<?php

namespace App\Filament\Resources\AgentDynamicConfigResource\Pages;

use App\Filament\Resources\AgentDynamicConfigResource;
use Filament\Resources\Pages\EditRecord;

class EditAgentDynamicConfig extends EditRecord
{
    protected static string $resource = AgentDynamicConfigResource::class;
}

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource\Pages\EditAgentDynamicConfig.php
Usage in Workflow Builder
Whenever you have a workflow node that needs to reference a user’s dynamic agent config, you can:

• Add a foreign key like agent_dynamic_config_id to your workflow node record or table.
• In your Filament form or Vue workflow builder, retrieve a list of dynamic agents for the authenticated user and display them in a dropdown.
• Allow the user to select which “dynamic agent” to use.

In your Vue workflow builder component (e.g., CodeNodeConfig.vue or AgentNodeConfig.vue), you might expose an endpoint that returns the user’s AgentDynamicConfig records. Then, store the selected “agentDynamicConfigId” in the node’s config, for example:

node config example: { ... agentDynamicConfigId: 7 ... }

Updated Directory Structure (Simplified View)
Below is a simplified view of the final folders and files needed for this feature (only showing new or modified files):

• database
└── migrations
└── 2023_10_01_000000_create_agent_dynamic_configs_table.php

• app
├── Models
│ └── AgentDynamicConfig.php
└── Filament
└── Resources
├── AgentDynamicConfigResource.php
└── AgentDynamicConfigResource
└── Pages
├── ListAgentDynamicConfigs.php
├── CreateAgentDynamicConfig.php
└── EditAgentDynamicConfig.php

• resources
└── js
└── Components
└── Workflow
├── NodeConfigs
│ └── AgentNodeConfig.vue (Adapt to load dynamic agents)
└── …

With this setup, you can store, list, and manage user-created agents (and their parameters) in the database, exposing them wherever you need—like in a workflow node configuration or open chat interface.

Review the above code, list enhancements possible and regenerate the code with the enhancements.. 




Context
— none fetched
Let me review the code I've generated for the AgentDynamicConfig feature and identify possible enhancements:

Multi-tenancy Support: The code already includes user_id for SaaS scoping, but we should make sure everything is properly scoped.

Permissions/Policies: We should add Filament policies to ensure users can only see their own agents.

API Endpoints: We need API endpoints for the Vue components to fetch available dynamic agents.

Integration with Workflow Nodes: Enhance the workflow node configs to display and use the dynamic agents.

Validation: Add more robust validation for the various fields.

Testing: Include test cases for the feature.

Preview Functionality: Allow previewing an agent without executing a full workflow.

Templates: Provide pre-defined templates for common agent configurations.

Usage Tracking: Track usage of dynamic agents for billing purposes.

Version History: Track changes to agent configurations.

Let me regenerate the code with these enhancements.

Enhanced AgentDynamicConfig Implementation
After reviewing the initial implementation, I've identified several enhancements to make this feature more robust, secure, and user-friendly. Here's an improved version:

Enhancements Added:
Multi-tenancy Support - Strengthened team/tenant isolation
Authorization Policies - Added proper permissions control
API Endpoints - Created endpoints for Vue components
Workflow Integration - Better integration with workflow nodes
Template Support - Pre-defined agent templates for users
Version History - Track changes to agent configurations
Validation - Enhanced validation for all model properties
Usage Tracking - Record agent usage statistics
Export/Import - Added ability to export/import agents
Preview Functionality - Test agents before using in workflows
Updated Directory Structure
├── app
│   ├── Filament
│   │   └── Resources
│   │       ├── AgentDynamicConfigResource.php
│   │       └── AgentDynamicConfigResource
│   │           ├── Pages
│   │           │   ├── CreateAgentDynamicConfig.php
│   │           │   ├── EditAgentDynamicConfig.php
│   │           │   ├── ListAgentDynamicConfigs.php
│   │           │   └── ViewAgentDynamicConfig.php
│   │           └── Widgets
│   │               └── AgentUsageStats.php
│   ├── Http
│   │   ├── Controllers
│   │   │   ├── Api
│   │   │   │   └── AgentDynamicConfigController.php
│   │   │   └── AgentPreviewController.php
│   │   └── Requests
│   │       └── AgentDynamicConfigRequest.php
│   ├── Models
│   │   ├── AgentDynamicConfig.php
│   │   └── AgentDynamicConfigHistory.php
│   └── Policies
│       └── AgentDynamicConfigPolicy.php
├── database
│   └── migrations
│       ├── 2023_10_01_000000_create_agent_dynamic_configs_table.php
│       └── 2023_10_01_000001_create_agent_dynamic_config_histories_table.php
└── resources
    └── js
        ├── Components
        │   └── Workflow
        │       └── NodeConfigs
        │           └── AgentNodeConfig.vue
        └── Pages
            └── Agents
                ├── AgentPreview.vue
                └── ExportImport.vue

Copy

Apply

Implementation Details
1. Migrations
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('agent_dynamic_configs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->text('instruction');
            $table->float('temperature')->default(0.7);
            $table->json('tools')->nullable();
            $table->string('model')->default('gpt-3.5-turbo');
            $table->boolean('is_public')->default(false);
            $table->boolean('is_template')->default(false);
            $table->integer('usage_count')->default(0);
            $table->timestamp('last_used_at')->nullable();
            $table->timestamps();
            
            $table->index(['team_id', 'user_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('agent_dynamic_configs');
    }
};

Copy

Apply

database\migrations\2023_10_01_000000_create_agent_dynamic_configs_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('agent_dynamic_config_histories', function (Blueprint $table) {
            $table->id();
            $table->foreignId('agent_dynamic_config_id')->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->text('instruction');
            $table->float('temperature')->default(0.7);
            $table->json('tools')->nullable();
            $table->string('model');
            $table->text('change_reason')->nullable();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('agent_dynamic_config_histories');
    }
};

Copy

Apply

database\migrations\2023_10_01_000001_create_agent_dynamic_config_histories_table.php
2. Models
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Facades\Auth;

class AgentDynamicConfig extends Model
{
    use HasFactory;

    protected $fillable = [
        'team_id',
        'user_id',
        'name',
        'instruction',
        'temperature',
        'tools',
        'model',
        'is_public',
        'is_template',
    ];

    protected $casts = [
        'tools' => 'array',
        'temperature' => 'float',
        'is_public' => 'boolean',
        'is_template' => 'boolean',
        'last_used_at' => 'datetime',
    ];

    public function user()
    {
        return $this->belongsTo(User::class);
    }
    
    public function team()
    {
        return $this->belongsTo(Team::class);
    }
    
    public function histories()
    {
        return $this->hasMany(AgentDynamicConfigHistory::class);
    }
    
    public function incrementUsage()
    {
        $this->increment('usage_count');
        $this->update(['last_used_at' => now()]);
    }
    
    public function createHistoryRecord(?string $reason = null)
    {
        return $this->histories()->create([
            'user_id' => Auth::id(),
            'instruction' => $this->instruction,
            'temperature' => $this->temperature,
            'tools' => $this->tools,
            'model' => $this->model,
            'change_reason' => $reason,
        ]);
    }
    
    public function scopeForCurrentTeam(Builder $query)
    {
        if (Auth::user()->currentTeam) {
            return $query->where('team_id', Auth::user()->currentTeam->id);
        }
        
        return $query->where('user_id', Auth::id());
    }
    
    public function scopeAvailableToUser(Builder $query)
    {
        return $query->where(function($q) {
            $q->where('user_id', Auth::id())
              ->orWhere('is_public', true)
              ->orWhere('is_template', true);
            
            if (Auth::user()->currentTeam) {
                $q->orWhere('team_id', Auth::user()->currentTeam->id);
            }
        });
    }
    
    // Export agent as array
    public function toExportArray()
    {
        return [
            'name' => $this->name,
            'instruction' => $this->instruction,
            'temperature' => $this->temperature,
            'tools' => $this->tools,
            'model' => $this->model,
        ];
    }
    
    // Create from import array
    public static function fromImportArray(array $data)
    {
        return self::create([
            'user_id' => Auth::id(),
            'team_id' => Auth::user()->currentTeam->id ?? null,
            'name' => $data['name'],
            'instruction' => $data['instruction'],
            'temperature' => $data['temperature'],
            'tools' => $data['tools'] ?? [],
            'model' => $data['model'],
        ]);
    }
}

Copy

Apply

app\Models\AgentDynamicConfig.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class AgentDynamicConfigHistory extends Model
{
    protected $fillable = [
        'user_id',
        'agent_dynamic_config_id',
        'instruction',
        'temperature',
        'tools',
        'model',
        'change_reason',
    ];

    protected $casts = [
        'tools' => 'array',
        'temperature' => 'float',
    ];

    public function agentDynamicConfig()
    {
        return $this->belongsTo(AgentDynamicConfig::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

Copy

Apply

app\Models\AgentDynamicConfigHistory.php
3. Policy
<?php

namespace App\Policies;

use App\Models\AgentDynamicConfig;
use App\Models\User;
use Illuminate\Auth\Access\HandlesAuthorization;

class AgentDynamicConfigPolicy
{
    use HandlesAuthorization;
    
    public function viewAny(User $user): bool
    {
        return true;
    }
    
    public function view(User $user, AgentDynamicConfig $agent): bool
    {
        // Users can view agents that:
        // 1. They created
        // 2. Are public templates
        // 3. Belong to their team
        return $user->id === $agent->user_id ||
               $agent->is_template ||
               $agent->is_public ||
               ($user->currentTeam && $user->currentTeam->id === $agent->team_id);
    }
    
    public function create(User $user): bool
    {
        return true;
    }
    
    public function update(User $user, AgentDynamicConfig $agent): bool
    {
        // Only owner or team members can edit
        return $user->id === $agent->user_id ||
               ($user->currentTeam && $user->currentTeam->id === $agent->team_id);
    }
    
    public function delete(User $user, AgentDynamicConfig $agent): bool
    {
        // Only owner can delete
        return $user->id === $agent->user_id;
    }
}

Copy

Apply

app\Policies\AgentDynamicConfigPolicy.php
4. Filament Resource
<?php

namespace App\Filament\Resources;

use App\Filament\Resources\AgentDynamicConfigResource\Pages;
use App\Filament\Resources\AgentDynamicConfigResource\Widgets;
use App\Models\AgentDynamicConfig;
use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Resources\Table;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Auth;

class AgentDynamicConfigResource extends Resource
{
    protected static ?string $model = AgentDynamicConfig::class;
    protected static ?string $navigationIcon = 'heroicon-o-chip';
    protected static ?string $navigationLabel = 'AI Agents';
    protected static ?string $pluralModelLabel = 'AI Agents';
    protected static ?string $modelLabel = 'AI Agent';
    protected static ?string $navigationGroup = 'Automation';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\Card::make([
                    Forms\Components\TextInput::make('name')
                        ->label('Agent Name')
                        ->required()
                        ->maxLength(255),
                        
                    Forms\Components\Textarea::make('instruction')
                        ->label('Agent Instructions')
                        ->rows(4)
                        ->required()
                        ->helperText('The system prompt that defines how the agent behaves'),
                        
                    Forms\Components\Select::make('model')
                        ->options([
                            'gpt-3.5-turbo' => 'GPT 3.5 Turbo',
                            'gpt-4' => 'GPT-4',
                            'gpt-4-turbo' => 'GPT-4 Turbo',
                            'prism-model-alpha' => 'Prism Alpha',
                            'prism-model-beta' => 'Prism Beta',
                            // Add more models as needed
                        ])
                        ->label('AI Model')
                        ->default('gpt-3.5-turbo')
                        ->required(),
                        
                    Forms\Components\Slider::make('temperature')
                        ->default(0.7)
                        ->min(0)
                        ->max(2)
                        ->step(0.1)
                        ->helperText('Higher values create more random responses (0-2)')
                        ->required(),
                ]),
                
                Forms\Components\Card::make([
                    Forms\Components\Repeater::make('tools')
                        ->schema([
                            Forms\Components\Select::make('type')
                                ->options([
                                    'function' => 'Function',
                                    'retrieval' => 'Retrieval',
                                    'code_interpreter' => 'Code Interpreter',
                                    'webhook' => 'Webhook',
                                    'custom' => 'Custom Tool',
                                ])
                                ->required(),
                                
                            Forms\Components\TextInput::make('name')
                                ->label('Tool Name')
                                ->required(),
                                
                            Forms\Components\KeyValue::make('parameters')
                                ->label('Parameters')
                                ->keyLabel('Parameter Name')
                                ->valueLabel('Description')
                                ->helperText('Define the parameters this tool accepts'),
                                
                            Forms\Components\Textarea::make('description')
                                ->label('Description')
                                ->rows(2)
                                ->helperText('Describe what this tool does and when to use it'),
                        ])
                        ->collapsible()
                        ->columns(2)
                        ->defaultItems(0),
                ]),
                
                Forms\Components\Card::make

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource.php
how can i enable prism server implementation so that the echolabsdev/prism package models are available in Laragent, echolabsdev/prism package allows to wrap around models from different foundation models with openai compatible APIS such as openai, groq, anthropic, deepseek, llama etc... so i want those models to be available in laragent through dynamic openAI client configuration 
current selection
 
larafast1
 




Context
— 13 new items
This question is asking how to integrate the echolabsdev/prism package's models into the LaraGent feature within LaraFast, enabling the use of multiple foundation models through a unified API.

From the codebase context provided, I can see some parts of the LaraFast application, particularly related to:

Controllers
Resources
Filament components
JavaScript components for a workflow builder
However, I don't see direct references to the echolabsdev/prism package or the LaraGent feature. I need to provide a solution to integrate the Prism package's models into the LaraGent feature.

The solution will likely involve:

Installing the echolabsdev/prism package
Configuring a way to dynamically select and configure models through the OpenAI-compatible API
Modifying any existing model selection interfaces to include these new options
Ensuring the service layer respects these model configurations
Let me formulate an answer based on typical Laravel application architecture and the bits of code I can see.

Integrating Prism Models with LaraGent in LaraFast
To enable the echolabsdev/prism package models in LaraGent through dynamic OpenAI client configuration, you'll need to modify several components of your application. Here's a step-by-step implementation guide:

1. Install the Prism Package
First, install the echolabsdev/prism package:

composer require echolabsdev/prism

Copy

Execute

2. Update Configuration Files
Create a new configuration file for Prism integration:

<?php

return [
    'enabled' => env('PRISM_ENABLED', true),
    
    'models' => [
        // OpenAI Models
        'gpt-3.5-turbo' => [
            'provider' => 'openai',
            'base_url' => env('OPENAI_API_URL', 'https://api.openai.com/v1'),
            'api_key' => env('OPENAI_API_KEY'),
        ],
        'gpt-4' => [
            'provider' => 'openai',
            'base_url' => env('OPENAI_API_URL', 'https://api.openai.com/v1'),
            'api_key' => env('OPENAI_API_KEY'),
        ],
        
        // Anthropic Models via Prism
        'claude-3-opus' => [
            'provider' => 'anthropic',
            'base_url' => env('ANTHROPIC_API_URL', 'https://api.anthropic.com'),
            'api_key' => env('ANTHROPIC_API_KEY'),
            'version' => '2023-06-01',
        ],
        'claude-3-sonnet' => [
            'provider' => 'anthropic',
            'base_url' => env('ANTHROPIC_API_URL', 'https://api.anthropic.com'),
            'api_key' => env('ANTHROPIC_API_KEY'),
            'version' => '2023-06-01',
        ],
        
        // Groq Models via Prism
        'llama3-8b-8192' => [
            'provider' => 'groq',
            'base_url' => env('GROQ_API_URL', 'https://api.groq.com/openai/v1'),
            'api_key' => env('GROQ_API_KEY'),
        ],
        'mixtral-8x7b-32768' => [
            'provider' => 'groq',
            'base_url' => env('GROQ_API_URL', 'https://api.groq.com/openai/v1'),
            'api_key' => env('GROQ_API_KEY'),
        ],
        
        // DeepSeek Models via Prism
        'deepseek-coder' => [
            'provider' => 'deepseek',
            'base_url' => env('DEEPSEEK_API_URL'),
            'api_key' => env('DEEPSEEK_API_KEY'),
        ],
        
        // Add other models as needed
    ],
    
    // Default model to use
    'default_model' => env('PRISM_DEFAULT_MODEL', 'gpt-3.5-turbo'),
];

Copy

Apply

config\prism.php
3. Create a Prism Service Provider
Create a service provider to register the Prism service:

<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use EchoLabsDev\Prism\PrismClient;

class PrismServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton('prism', function ($app) {
            return new PrismClient(config('prism.default_model'), config('prism.models'));
        });
        
        // Extend the existing AI service with Prism support
        $this->app->extend('larafast.ai', function ($service, $app) {
            $service->setPrismClient($app->make('prism'));
            return $service;
        });
    }

    public function boot()
    {
        $this->publishes([
            __DIR__.'/../../config/prism.php' => config_path('prism.php'),
        ], 'prism-config');
    }
}

Copy

Apply

app\Providers\PrismServiceProvider.php
Register this provider in config/app.php:

'providers' => [
    // Other providers...
    App\Providers\PrismServiceProvider::class,
],

Copy

Apply

4. Create a Dynamic Model Configuration Service
Create a service to manage dynamic model configurations:

<?php

namespace App\Services;

use App\Models\AgentDynamicConfig;
use EchoLabsDev\Prism\PrismClient;
use Illuminate\Support\Facades\Cache;

class AIModelConfigService
{
    protected $prismClient;
    
    public function __construct(PrismClient $prismClient)
    {
        $this->prismClient = $prismClient;
    }
    
    /**
     * Get all available models for selection
     */
    public function getAvailableModels(): array
    {
        return Cache::remember('ai_available_models', 3600, function () {
            // Combine models from all supported providers
            $models = config('prism.models');
            
            $formattedModels = [];
            foreach ($models as $modelId => $config) {
                $provider = $config['provider'] ?? 'unknown';
                $formattedModels[$modelId] = [
                    'id' => $modelId,
                    'name' => $this->formatModelName($modelId),
                    'provider' => $provider,
                    'provider_name' => ucfirst($provider),
                    'category' => $this->getModelCategory($modelId),
                ];
            }
            
            return $formattedModels;
        });
    }
    
    /**
     * Get client instance for a specific agent config
     */
    public function getClientForAgent(AgentDynamicConfig $agentConfig)
    {
        $modelId = $agentConfig->model;
        return $this->prismClient->withModel($modelId);
    }
    
    /**
     * Format a model ID into a human-readable name
     */
    protected function formatModelName(string $modelId): string
    {
        // Format model IDs into readable names
        $modelNames = [
            'gpt-3.5-turbo' => 'GPT-3.5 Turbo',
            'gpt-4' => 'GPT-4',
            'claude-3-opus' => 'Claude 3 Opus',
            'claude-3-sonnet' => 'Claude 3 Sonnet',
            'llama3-8b-8192' => 'Llama 3 (8B)',
            'mixtral-8x7b-32768' => 'Mixtral 8x7B',
            'deepseek-coder' => 'DeepSeek Coder',
            // Add more as needed
        ];
        
        return $modelNames[$modelId] ?? ucfirst(str_replace(['-', '_'], ' ', $modelId));
    }
    
    /**
     * Categorize a model
     */
    protected function getModelCategory(string $modelId): string
    {
        // Simple categorization based on model ID
        if (str_contains($modelId, 'gpt')) {
            return 'OpenAI';
        } elseif (str_contains($modelId, 'claude')) {
            return 'Anthropic';
        } elseif (str_contains($modelId, 'llama') || str_contains($modelId, 'mixtral')) {
            return 'Groq';
        } elseif (str_contains($modelId, 'deepseek')) {
            return 'DeepSeek';
        }
        
        return 'Other';
    }
}

Copy

Apply

app\Services\AIModelConfigService.php
5. Modify the AgentDynamicConfig Model
Update your AgentDynamicConfig model to work with the Prism package:

<?php

namespace App\Models;

use App\Services\AIModelConfigService;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\App;

class AgentDynamicConfig extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'team_id',
        'name',
        'instruction',
        'temperature',
        'tools',
        'model',
        'provider_settings',
        'is_public',
        'is_template',
    ];

    protected $casts = [
        'tools' => 'array',
        'provider_settings' => 'array',
        'temperature' => 'float',
        'is_public' => 'boolean',
        'is_template' => 'boolean',
    ];
    
    // Other methods...
    
    /**
     * Get a client instance for this agent
     */
    public function getClient()
    {
        $modelService = App::make(AIModelConfigService::class);
        return $modelService->getClientForAgent($this);
    }
    
    /**
     * Get provider-specific settings
     */
    public function getProviderSettings()
    {
        return $this->provider_settings ?? [];
    }
    
    /**
     * Returns the human-readable model name
     */
    public function getModelNameAttribute()
    {
        $models = App::make(AIModelConfigService::class)->getAvailableModels();
        return $models[$this->model]['name'] ?? $this->model;
    }
    
    /**
     * Returns the provider name for the selected model
     */
    public function getProviderNameAttribute()
    {
        $models = App::make(AIModelConfigService::class)->getAvailableModels();
        return $models[$this->model]['provider_name'] ?? 'Unknown';
    }
}

Copy

Apply

app\Models\AgentDynamicConfig.php
6. Update the Migration
Modify your migration to add the provider_settings field:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('agent_dynamic_configs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->text('instruction');
            $table->float('temperature')->default(0.7);
            $table->json('tools')->nullable();
            $table->string('model')->default('gpt-3.5-turbo');
            $table->json('provider_settings')->nullable(); // Added provider-specific settings
            $table->boolean('is_public')->default(false);
            $table->boolean('is_template')->default(false);
            $table->integer('usage_count')->default(0);
            $table->timestamp('last_used_at')->nullable();
            $table->timestamps();
            
            $table->index(['team_id', 'user_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('agent_dynamic_configs');
    }
};

Copy

Apply

database\migrations\2023_10_01_000000_create_agent_dynamic_configs_table.php
7. Update the Filament Resource
Modify the Filament Resource to support model selection with providers:

<?php

namespace App\Filament\Resources;

use App\Filament\Resources\AgentDynamicConfigResource\Pages;
use App\Models\AgentDynamicConfig;
use App\Services\AIModelConfigService;
use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Resources\Table;
use Illuminate\Support\Facades\App;

class AgentDynamicConfigResource extends Resource
{
    protected static ?string $model = AgentDynamicConfig::class;
    protected static ?string $navigationIcon = 'heroicon-o-chip';
    protected static ?string $navigationLabel = 'AI Agents';
    
    public static function form(Form $form): Form
    {
        $modelService = App::make(AIModelConfigService::class);
        $availableModels = $modelService->getAvailableModels();
        
        // Group models by provider
        $modelOptions = [];
        foreach ($availableModels as $modelId => $modelInfo) {
            $category = $modelInfo['category'];
            if (!isset($modelOptions[$category])) {
                $modelOptions[$category] = [];
            }
            $modelOptions[$category][$modelId] = $modelInfo['name'];
        }
        
        return $form
            ->schema([
                Forms\Components\Card::make([
                    Forms\Components\TextInput::make('name')
                        ->label('Agent Name')
                        ->required()
                        ->maxLength(255),
                        
                    Forms\Components\Textarea::make('instruction')
                        ->label('Agent Instructions')
                        ->rows(4)
                        ->required()
                        ->helperText('The system prompt that defines how the agent behaves'),
                        
                    Forms\Components\Select::make('model')
                        ->label('AI Model')
                        ->options($modelOptions)
                        ->required()
                        ->reactive()
                        ->afterStateUpdated(function ($state, callable $set) use ($availableModels) {
                            // Set default provider settings when model changes
                            if (isset($availableModels[$state])) {
                                $provider = $availableModels[$state]['provider'];
                                
                                // Set provider-specific defaults
                                if ($provider === 'anthropic') {
                                    $set('provider_settings.anthropic_version', '2023-06-01');
                                }
                            }
                        }),
                        
                    Forms\Components\Slider::make('temperature')
                        ->default(0.7)
                        ->min(0)
                        ->max(2)
                        ->step(0.1)
                        ->required(),
                        
                    // Dynamic provider settings based on selected model
                    Forms\Components\Group::make()
                        ->schema(function (callable $get) use ($availableModels) {
                            $model = $get('model');
                            $provider = $model && isset($availableModels[$model]) 
                                ? $avail

Copy

Apply

app\Filament\Resources\AgentDynamicConfigResource.php
how to enable theodo-group/llphant for retrieval augmented generation chat using qdrant with a LaraGent agent.. 
larafast1
 




Context
— 15 new items
Based on the question, the user wants to integrate theodo-group/llphant library for Retrieval Augmented Generation (RAG) using Qdrant vector database within a LaraGent agent in LaraFast.

Looking at the available context, I don't see specific details about the existing LaraGent implementation or current RAG capabilities. I'll need to provide a comprehensive solution that:

Installs the required packages
Configures Qdrant connection
Sets up document ingestion/embedding with llphant
Integrates the RAG capabilities with LaraGent agents
Shows how to use it in a workflow or chat
I'll need to build this solution based on general Laravel best practices and what I can infer about the LaraFast architecture from the context provided.

Enabling Retrieval Augmented Generation with llphant and Qdrant in LaraFast
To enable theodo-group/llphant for RAG (Retrieval Augmented Generation) with Qdrant in your LaraGent agents, you'll need to integrate several components. Here's a comprehensive implementation guide:

1. Install Required Packages
First, install the necessary packages:

composer require theodo-group/llphant qdrant/qdrant-php

Copy

Execute

2. Create a Qdrant Service Provider
Create a service provider to register the Qdrant and llphant services:

<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Llphant\Embeddings\OpenAI\OpenAIEmbedding;
use Llphant\VectorStores\Qdrant\QdrantVectorStore;
use Llphant\Retrievers\VectorStoreRetriever;
use Llphant\Chat\ChatPromptTemplate;
use GuzzleHttp\Client;

class LlphantServiceProvider extends ServiceProvider
{
    public function register()
    {
        // Register OpenAI Embeddings
        $this->app->singleton('llphant.embeddings', function ($app) {
            return new OpenAIEmbedding(
                apiKey: config('services.openai.api_key'),
                model: config('services.openai.embedding_model', 'text-embedding-3-small')
            );
        });

        // Register Qdrant Vector Store
        $this->app->singleton('llphant.vectorstore', function ($app) {
            $httpClient = new Client([
                'base_uri' => config('services.qdrant.url', 'http://localhost:6333'),
                'headers' => [
                    'api-key' => config('services.qdrant.api_key', ''),
                ],
            ]);
            
            return new QdrantVectorStore(
                httpClient: $httpClient,
                collectionName: config('services.qdrant.collection', 'larafast_documents'),
                embeddingSize: config('services.qdrant.embedding_size', 1536),
                embedding: $app->make('llphant.embeddings')
            );
        });
        
        // Register Vector Store Retriever
        $this->app->singleton('llphant.retriever', function ($app) {
            return new VectorStoreRetriever(
                vectorStore: $app->make('llphant.vectorstore'),
                k: config('services.qdrant.retrieval_k', 5)
            );
        });
    }

    public function boot()
    {
        //
    }
}

Copy

Apply

app\Providers\LlphantServiceProvider.php
Register this provider in config/app.php:

'providers' => [
    // Other providers...
    App\Providers\LlphantServiceProvider::class,
],

Copy

Apply

3. Update Configuration
Add Qdrant and llphant settings to your services config:

// Existing config...

'qdrant' => [
    'url' => env('QDRANT_URL', 'http://localhost:6333'),
    'api_key' => env('QDRANT_API_KEY', ''),
    'collection' => env('QDRANT_COLLECTION', 'larafast_documents'),
    'embedding_size' => env('QDRANT_EMBEDDING_SIZE', 1536),
    'retrieval_k' => env('QDRANT_RETRIEVAL_K', 5),
],

'openai' => [
    'api_key' => env('OPENAI_API_KEY'),
    'organization' => env('OPENAI_ORGANIZATION'),
    'embedding_model' => env('OPENAI_EMBEDDING_MODEL', 'text-embedding-3-small'),
],

Copy

Apply

config\services.php
4. Create RAG Service
Create a service for document ingestion and retrieval:

<?php

namespace App\Services;

use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Storage;
use Llphant\Documents\Document;
use Llphant\Embeddings\OpenAI\OpenAIEmbedding;
use Llphant\VectorStores\Qdrant\QdrantVectorStore;
use Llphant\Retrievers\VectorStoreRetriever;
use Llphant\Documents\Loaders\TextLoader;
use Llphant\Documents\Loaders\PDFLoader;
use Llphant\Documents\Transformers\CharacterTextSplitter;

class RagService
{
    protected $embedding;
    protected $vectorStore;
    protected $retriever;
    
    public function __construct()
    {
        $this->embedding = App::make('llphant.embeddings');
        $this->vectorStore = App::make('llphant.vectorstore');
        $this->retriever = App::make('llphant.retriever');
    }
    
    /**
     * Ingest a document from a file path
     */
    public function ingestFile(string $filePath, ?string $metadataJson = null): array
    {
        // Determine loader based on file extension
        $extension = pathinfo($filePath, PATHINFO_EXTENSION);
        $loader = match (strtolower($extension)) {
            'pdf' => new PDFLoader($filePath),
            'txt', 'md', 'html', 'htm' => new TextLoader($filePath),
            default => throw new \Exception("Unsupported file type: {$extension}"),
        };
        
        // Load document and split into chunks
        $document = $loader->load()[0];
        
        // Add metadata if provided
        if ($metadataJson) {
            $metadata = json_decode($metadataJson, true);
            if (is_array($metadata)) {
                $document->metadata = array_merge($document->metadata, $metadata);
            }
        }
        
        // Ensure source is tracked
        $document->metadata['source'] = $filePath;
        
        // Split document into smaller chunks
        $splitter = new CharacterTextSplitter(
            chunkSize: 1000,
            chunkOverlap: 200
        );
        
        $splits = $splitter->splitDocuments([$document]);
        
        // Add documents to vector store
        return $this->vectorStore->addDocuments($splits);
    }
    
    /**
     * Ingest text content directly
     */
    public function ingestText(string $content, array $metadata = []): array
    {
        $document = new Document(
            pageContent: $content,
            metadata: $metadata
        );
        
        // Split document into smaller chunks
        $splitter = new CharacterTextSplitter(
            chunkSize: 1000,
            chunkOverlap: 200
        );
        
        $splits = $splitter->splitDocuments([$document]);
        
        // Add documents to vector store
        return $this->vectorStore->addDocuments($splits);
    }
    
    /**
     * Retrieve relevant documents based on a query
     */
    public function retrieveDocuments(string $query, int $limit = null): array
    {
        if ($limit !== null) {
            $this->retriever->k = $limit;
        }
        
        return $this->retriever->getRelevantDocuments($query);
    }
    
    /**
     * Creates a RAG prompt template for use with agents
     */
    public function createRagPromptTemplate(string $agentInstruction): string
    {
        return <<<EOT
{$agentInstruction}

You have access to the following retrieved documents:
{context}

User question: {question}

Please answer the question based on both the context provided and your general knowledge.
When information comes from the retrieved documents, indicate the source.
If the retrieved documents don't contain relevant information, rely on your general knowledge
but be clear about what's your knowledge versus what's in the documents.
EOT;
    }
}

Copy

Apply

app\Services\RagService.php
5. Create an Agent Tool for RAG
Create a tool that LaraGent agents can use for retrieval:

<?php

namespace App\Agents\Tools;

use App\Services\RagService;
use Illuminate\Support\Facades\App;

class RetrievalTool
{
    protected $ragService;
    
    public function __construct(RagService $ragService = null)
    {
        $this->ragService = $ragService ?? App::make(RagService::class);
    }
    
    /**
     * Search for information in the knowledge base
     */
    public function search(string $query, int $limit = 5): array
    {
        $documents = $this->ragService->retrieveDocuments($query, $limit);
        
        $results = [];
        foreach ($documents as $doc) {
            $results[] = [
                'content' => $doc->pageContent,
                'metadata' => $doc->metadata,
                'score' => $doc->metadata['score'] ?? null,
            ];
        }
        
        return [
            'total' => count($results),
            'results' => $results,
        ];
    }
    
    /**
     * Get tool definition for agent configuration
     */
    public static function getToolDefinition(): array
    {
        return [
            'type' => 'function',
            'function' => [
                'name' => 'search_knowledge_base',
                'description' => 'Search for information in the knowledge base to answer user questions',
                'parameters' => [
                    'type' => 'object',
                    'properties' => [
                        'query' => [
                            'type' => 'string',
                            'description' => 'The search query to find relevant information',
                        ],
                        'limit' => [
                            'type' => 'integer',
                            'description' => 'Maximum number of results to return (default: 5)',
                        ],
                    ],
                    'required' => ['query'],
                ],
            ],
        ];
    }
}

Copy

Apply

app\Agents\Tools\RetrievalTool.php
6. Create a Command to Ingest Documents
Create an Artisan command for document ingestion:

<?php

namespace App\Console\Commands;

use App\Services\RagService;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;

class IngestDocument extends Command
{
    protected $signature = 'rag:ingest 
                            {path : Path to file or directory to ingest}
                            {--recursive : Process directories recursively}
                            {--metadata= : JSON string with metadata to attach to documents}';
                            
    protected $description = 'Ingest documents into the vector database for RAG';

    public function handle(RagService $ragService)
    {
        $path = $this->argument('path');
        $recursive = $this->option('recursive');
        $metadata = $this->option('metadata');
        
        if (!file_exists($path)) {
            $this->error("File or directory not found: {$path}");
            return 1;
        }
        
        if (is_dir($path)) {
            $this->processDirectory($path, $ragService, $recursive, $metadata);
        } else {
            $this->processFile($path, $ragService, $metadata);
        }
        
        $this->info('Ingestion completed successfully.');
        return 0;
    }
    
    protected function processDirectory($dirPath, $ragService, $recursive, $metadata)
    {
        $this->info("Processing directory: {$dirPath}");
        
        $files = scandir($dirPath);
        foreach ($files as $file) {
            if ($file === '.' || $file === '..') {
                continue;
            }
            
            $filePath = $dirPath . '/' . $file;
            
            if (is_dir($filePath)) {
                if ($recursive) {
                    $this->processDirectory($filePath, $ragService, $recursive, $metadata);
                }
                continue;
            }
            
            $this->processFile($filePath, $ragService, $metadata);
        }
    }
    
    protected function processFile($filePath, $ragService, $metadata)
    {
        $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
        $supportedExtensions = ['txt', 'pdf', 'md', 'html', 'htm'];
        
        if (!in_array($extension, $supportedExtensions)) {
            $this->warn("Skipping unsupported file: {$filePath}");
            return;
        }
        
        $this->info("Ingesting file: {$filePath}");
        
        try {
            $result = $ragService->ingestFile($filePath, $metadata);
            $this->info("Successfully ingested " . count($result) . " chunks from {$filePath}");
        } catch (\Exception $e) {
            $this->error("Failed to ingest {$filePath}: " . $e->getMessage());
        }
    }
}

Copy

Apply

app\Console\Commands\IngestDocument.php
7. Modify Agent Dynamic Config
Update the AgentDynamicConfig model to integrate with RAG:

<?php

namespace App\Models;

use App\Agents\Tools\RetrievalTool;
use App\Services\RagService;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\App;

class AgentDynamicConfig extends Model
{
    // Existing model code...
    
    /**
     * Check if this agent has retrieval enabled
     */
    public function hasRetrievalEnabled(): bool
    {
        $tools = $this->tools ?? [];
        
        foreach ($tools as $tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Get the prompt with RAG context if needed
     */
    public function getPromptWithRagContext(string $userQuery): string
    {
        if (!$this->hasRetrievalEnabled()) {
            return $this->instruction;
        }
        
        // Get retrieval service
        $ragService = App::make(RagService::class);
        
        // Retrieve relevant documents
        $documents = $ragService->retrieveDocuments($userQuery);
        
        // Format the context from retrieved documents
        $context = "";
        foreach ($documents as $index => $doc) {
            $source = $doc->metadata['source'] ?? "Document " . ($index + 1);
            $context .= "Document from {$source}:\n{$doc->pageContent}\n\n";
        }
        
        // Create a RAG prompt template
        $ragPrompt = $ragService->createRagPromptTemplate($this->instruction);
        
        //

Copy

Apply

app\Models\AgentDynamicConfig.php
continue the above function to complete app\Models\AgentDynamicConfig.php and generate any other required code..




Context
— none fetched
I need to continue implementing the getPromptWithRagContext function in the AgentDynamicConfig model and add any other necessary code for integrating RAG capabilities with LaraGent.

Let me continue with:

Finishing the getPromptWithRagContext function
Adding other necessary methods to handle RAG
Creating a controller for document management
Adding a Filament resource component to manage documents
Adding necessary UI elements
I'll also consider the existing framework patterns seen in the codebase snippets.

Let me continue implementing the getPromptWithRagContext function and provide the other components needed to fully integrate RAG capabilities with LaraGent:

<?php

namespace App\Models;

use App\Agents\Tools\RetrievalTool;
use App\Services\RagService;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\App;

class AgentDynamicConfig extends Model
{
    // Existing model code...
    
    /**
     * Check if this agent has retrieval enabled
     */
    public function hasRetrievalEnabled(): bool
    {
        $tools = $this->tools ?? [];
        
        foreach ($tools as $tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Get the prompt with RAG context if needed
     */
    public function getPromptWithRagContext(string $userQuery): string
    {
        if (!$this->hasRetrievalEnabled()) {
            return $this->instruction;
        }
        
        // Get retrieval service
        $ragService = App::make(RagService::class);
        
        // Retrieve relevant documents
        $documents = $ragService->retrieveDocuments($userQuery);
        
        // Format the context from retrieved documents
        $context = "";
        if (empty($documents)) {
            $context = "No relevant documents found in the knowledge base.";
        } else {
            foreach ($documents as $index => $doc) {
                $source = $doc->metadata['source'] ?? "Document " . ($index + 1);
                $context .= "Document from {$source}:\n{$doc->pageContent}\n\n";
            }
        }
        
        // Create a RAG prompt template
        $ragPrompt = $ragService->createRagPromptTemplate($this->instruction);
        
        // Replace placeholders with actual content
        return str_replace(
            ['{context}', '{question}'],
            [$context, $userQuery],
            $ragPrompt
        );
    }
    
    /**
     * Get the OpenAI compatible tools configuration including retrieval
     */
    public function getToolsConfig(): array
    {
        $toolsConfig = [];
        $tools = $this->tools ?? [];
        
        // Process configured tools
        foreach ($tools as $tool) {
            $type = $tool['type'] ?? '';
            
            if ($type === 'retrieval') {
                // Add the retrieval tool
                $toolsConfig[] = RetrievalTool::getToolDefinition();
            } elseif ($type === 'function') {
                // Add user-defined function tool
                $toolsConfig[] = [
                    'type' => 'function',
                    'function' => [
                        'name' => $tool['name'] ?? 'unnamed_function',
                        'description' => $tool['description'] ?? '',
                        'parameters' => $tool['parameters'] ?? [
                            'type' => 'object',
                            'properties' => [],
                        ],
                    ],
                ];
            }
            // Add other tool types as needed
        }
        
        return $toolsConfig;
    }
    
    /**
     * Execute RAG-enabled chat completion
     */
    public function executeRagCompletion(string $userQuery, array $messages = []): array
    {
        // Get model client (could be OpenAI, Prism, etc.)
        $client = $this->getClient();
        
        // Check if we need to use RAG
        $useRag = $this->hasRetrievalEnabled();
        
        // Prepare messages array
        $chatMessages = $messages;
        
        // Add system message with instruction (possibly RAG-enhanced)
        if ($useRag) {
            $systemContent = $this->getPromptWithRagContext($userQuery);
            
            // Insert system message at beginning
            array_unshift($chatMessages, [
                'role' => 'system',
                'content' => $systemContent
            ]);
        } else {
            // Standard non-RAG system message
            array_unshift($chatMessages, [
                'role' => 'system',
                'content' => $this->instruction
            ]);
        }
        
        // Add user's current query if not already in messages
        if (empty($messages) || end($messages)['role'] !== 'user') {
            $chatMessages[] = [
                'role' => 'user',
                'content' => $userQuery
            ];
        }
        
        // Get tools configuration
        $tools = $this->getToolsConfig();
        
        // Execute chat completion with the prepared context
        return $client->chat->completions->create([
            'model' => $this->model,
            'messages' => $chatMessages,
            'temperature' => $this->temperature,
            'tools' => !empty($tools) ? $tools : null,
            'tool_choice' => !empty($tools) ? 'auto' : null,
        ])->toArray();
    }
}

Copy

Apply

app\Models\AgentDynamicConfig.php
Now, let's create a model for RAG documents:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class KnowledgeDocument extends Model
{
    use HasFactory;

    protected $fillable = [
        'team_id',
        'user_id',
        'title',
        'file_path',
        'file_type',
        'original_filename',
        'size_bytes',
        'metadata',
        'chunks_count',
        'status',
    ];

    protected $casts = [
        'metadata' => 'array',
        'size_bytes' => 'integer',
        'chunks_count' => 'integer',
    ];

    /**
     * Available document statuses
     */
    const STATUS_PENDING = 'pending';
    const STATUS_PROCESSING = 'processing';
    const STATUS_COMPLETED = 'completed';
    const STATUS_FAILED = 'failed';

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function team(): BelongsTo
    {
        return $this->belongsTo(Team::class);
    }
    
    /**
     * Scope query to current team/user's documents
     */
    public function scopeForCurrentTeam($query)
    {
        if (auth()->user()->currentTeam) {
            return $query->where('team_id', auth()->user()->currentTeam->id);
        }
        
        return $query->where('user_id', auth()->id());
    }
}

Copy

Apply

app\Models\KnowledgeDocument.php
Create a migration for the knowledge documents:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('knowledge_documents', function (Blueprint $table) {
            $table->id();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('title');
            $table->string('file_path');
            $table->string('file_type');
            $table->string('original_filename');
            $table->unsignedBigInteger('size_bytes');
            $table->json('metadata')->nullable();
            $table->integer('chunks_count')->default(0);
            $table->string('status')->default('pending');
            $table->text('error_message')->nullable();
            $table->timestamps();
            
            $table->index(['team_id', 'user_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('knowledge_documents');
    }
};

Copy

Apply

database\migrations\2023_10_01_000001_create_knowledge_documents_table.php
Let's create a job to process documents asynchronously:

<?php

namespace App\Jobs;

use App\Models\KnowledgeDocument;
use App\Services\RagService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class ProcessKnowledgeDocument implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $document;

    /**
     * Create a new job instance.
     */
    public function __construct(KnowledgeDocument $document)
    {
        $this->document = $document;
    }

    /**
     * Execute the job.
     */
    public function handle(RagService $ragService): void
    {
        $document = $this->document;
        
        // Update status to processing
        $document->update(['status' => KnowledgeDocument::STATUS_PROCESSING]);
        
        try {
            // Get the full file path
            $filePath = Storage::path($document->file_path);
            
            // Document metadata
            $metadata = [
                'document_id' => $document->id,
                'title' => $document->title,
                'team_id' => $document->team_id,
                'user_id' => $document->user_id,
                'source' => $document->original_filename,
            ];
            
            // Ingest the document
            $chunks = $ragService->ingestFile($filePath, json_encode($metadata));
            
            // Update document with chunks count
            $document->update([
                'chunks_count' => count($chunks),
                'status' => KnowledgeDocument::STATUS_COMPLETED,
            ]);
            
            Log::info("Document {$document->id} processed successfully with " . count($chunks) . " chunks.");
        } catch (\Exception $e) {
            Log::error("Error processing document {$document->id}: " . $e->getMessage());
            
            // Update status to failed
            $document->update([
                'status' => KnowledgeDocument::STATUS_FAILED,
                'error_message' => $e->getMessage(),
            ]);
        }
    }
}

Copy

Apply

app\Jobs\ProcessKnowledgeDocument.php
Now, let's create a Filament resource to manage knowledge documents:

<?php

namespace App\Filament\Resources;

use App\Filament\Resources\KnowledgeDocumentResource\Pages;
use App\Jobs\ProcessKnowledgeDocument;
use App\Models\KnowledgeDocument;
use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Tables\Columns\TextColumn;
use Filament\Tables\Filters\SelectFilter;
use Illuminate\Support\Facades\Storage;

class KnowledgeDocumentResource extends Resource
{
    protected static ?string $model = KnowledgeDocument::class;

    protected static ?string $navigationIcon = 'heroicon-o-document-text';
    protected static ?string $navigationGroup = 'AI & Knowledge';
    protected static ?string $navigationLabel = 'Knowledge Base';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\Card::make()
                    ->schema([
                        Forms\Components\TextInput::make('title')
                            ->required()
                            ->maxLength(255)
                            ->label('Document Title'),
                            
                        Forms\Components\FileUpload::make('file')
                            ->required()
                            ->label('Document File')
                            ->disk('public')
                            ->directory('knowledge-docs')
                            ->acceptedFileTypes([
                                'application/pdf', // PDF
                                'text/plain', // TXT
                                'text/markdown', // MD
                                'text/html', // HTML
                            ])
                            ->helperText('Supported formats: PDF, TXT, MD, HTML'),
                        
                        Forms\Components\KeyValue::make('metadata')
                            ->label('Additional Metadata')
                            ->keyLabel('Property')
                            ->valueLabel('Value')
                            ->helperText('Optional metadata to associate with the document'),
                    ]),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('title')
                    ->searchable()
                    ->sortable(),
                    
                Tables\Columns\TextColumn::make('file_type')
                    ->label('Type')
                    ->badge()
                    ->sortable(),
                    
                Tables\Columns\TextColumn::make('status')
                    ->badge()
                    ->colors([
                        'warning' => KnowledgeDocument::STATUS_PENDING,
                        'primary' => KnowledgeDocument::STATUS_PROCESSING,
                        'success' => KnowledgeDocument::STATUS_COMPLETED,
                        'danger' => KnowledgeDocument::STATUS_FAILED,
                    ])
                    ->sortable(),
                    
                Tables\Columns\TextColumn::make('chunks_count')
                    ->label('Chunks')
                    ->sortable(),
                    
                Tables\Columns\TextColumn::make('user.name')
                    ->label('Uploaded By')
                    ->sortable(),
                    
                Tables\Columns\TextColumn::make('created_at')
                    ->label('Uploaded')
                    ->dateTime()
                    ->sortable(),
            ])
            ->filters([
                SelectFilter::make('status')
                    ->options([
                        KnowledgeDocument::STATUS_PENDING => 'Pending',
                        KnowledgeDocument::STATUS_PROCESSING => 'Processing',
                        KnowledgeDocument::STATUS_COMPLETED => 'Completed',
                        KnowledgeDocument::STATUS_FAILED => 'Failed',
                    ]),
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                Tables\Actions\Action::make('download')
                    ->label('Download')
                    ->icon('heroicon-o-download')
                    ->url(fn (KnowledgeDocument $record) => Storage::url($record->file_path))
                    ->openUrlInNewTab(),
                Tables\Actions\Action::make('reprocess')
                    ->label('Reprocess')
                    ->icon('heroicon-o-refresh')
                    ->action(function (KnowledgeDocument $record) {
                        ProcessKnowledgeDocument::dispatch($record);
                    })
                    ->requiresConfirmation()
                    ->color('warning'),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make

Copy

Apply

app\Filament\Resources\KnowledgeDocumentResource.php
please continue the above function to complete app\Models\AgentDynamicConfig.php




Context
— none fetched
I'm being asked to continue the implementation of the AgentDynamicConfig.php model. Based on the context provided, I need to look at what we've already implemented and what might be missing.

The current state of the AgentDynamicConfig.php I've provided includes:

Basic model attributes and relationships
RAG-specific methods like hasRetrievalEnabled(), getPromptWithRagContext(), getToolsConfig(), and executeRagCompletion()
The implementation seems fairly complete, but I should check if there are any other methods that would be useful for integrating RAG with the agent. I could add:

Method to register retrieval as a tool
Method to test RAG functionality
Method to list all knowledge collections available to the agent
Any helper methods for configuring RAG-specific parameters
Let me continue the implementation to provide a more complete solution.

Let's complete the AgentDynamicConfig.php class by adding more RAG-specific functionality:

<?php

namespace App\Models;

use App\Agents\Tools\RetrievalTool;
use App\Services\RagService;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\App;

class AgentDynamicConfig extends Model
{
    // Existing model code and methods...
    
    /**
     * Get the prompt with RAG context if needed
     */
    public function getPromptWithRagContext(string $userQuery): string
    {
        if (!$this->hasRetrievalEnabled()) {
            return $this->instruction;
        }
        
        // Get retrieval service
        $ragService = App::make(RagService::class);
        
        // Retrieve relevant documents
        $documents = $ragService->retrieveDocuments($userQuery);
        
        // Format the context from retrieved documents
        $context = "";
        if (empty($documents)) {
            $context = "No relevant documents found in the knowledge base.";
        } else {
            foreach ($documents as $index => $doc) {
                $source = $doc->metadata['source'] ?? "Document " . ($index + 1);
                $context .= "Document from {$source}:\n{$doc->pageContent}\n\n";
            }
        }
        
        // Create a RAG prompt template
        $ragPrompt = $ragService->createRagPromptTemplate($this->instruction);
        
        // Replace placeholders with actual content
        return str_replace(
            ['{context}', '{question}'],
            [$context, $userQuery],
            $ragPrompt
        );
    }
    
    /**
     * Add a retrieval tool to this agent's configuration
     * 
     * @param int $k Number of results to retrieve by default
     * @return $this
     */
    public function addRetrievalTool(int $k = 5): self
    {
        $tools = $this->tools ?? [];
        
        // Check if retrieval tool already exists
        foreach ($tools as $tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                return $this; // Tool already exists
            }
        }
        
        // Add the retrieval tool
        $tools[] = [
            'type' => 'retrieval',
            'name' => 'search_knowledge_base',
            'description' => 'Search for information in the knowledge base to answer user questions',
            'parameters' => [
                'k' => $k,
                'filter' => null,
            ]
        ];
        
        $this->tools = $tools;
        return $this;
    }
    
    /**
     * Remove retrieval tool from this agent's configuration
     * 
     * @return $this
     */
    public function removeRetrievalTool(): self
    {
        if (!$this->hasRetrievalEnabled()) {
            return $this;
        }
        
        $tools = $this->tools ?? [];
        $updatedTools = [];
        
        foreach ($tools as $tool) {
            $type = $tool['type'] ?? '';
            $name = $tool['name'] ?? '';
            
            if ($type !== 'retrieval' && $name !== 'search_knowledge_base') {
                $updatedTools[] = $tool;
            }
        }
        
        $this->tools = $updatedTools;
        return $this;
    }
    
    /**
     * Get document filtering criteria for this agent (if specified)
     */
    public function getDocumentFilter(): ?array
    {
        $tools = $this->tools ?? [];
        
        foreach ($tools as $tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                return $tool['parameters']['filter'] ?? null;
            }
        }
        
        return null;
    }
    
    /**
     * Set document filtering criteria for retrieval
     * 
     * @param array|null $filter Filter criteria (e.g. ['team_id' => 5])
     * @return $this
     */
    public function setDocumentFilter(?array $filter): self
    {
        $tools = $this->tools ?? [];
        $updated = false;
        
        foreach ($tools as &$tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                $tool['parameters']['filter'] = $filter;
                $updated = true;
            }
        }
        
        if (!$updated && $filter) {
            // Add the tool if it doesn't exist
            $this->addRetrievalTool();
            return $this->setDocumentFilter($filter);
        }
        
        $this->tools = $tools;
        return $this;
    }
    
    /**
     * Test retrieval with a query and return results
     * 
     * @param string $query Query to test retrieval with
     * @return array Results from retrieval
     */
    public function testRetrieval(string $query): array
    {
        $ragService = App::make(RagService::class);
        $filter = $this->getDocumentFilter();
        
        $documents = $ragService->retrieveDocuments($query, 5, $filter);
        
        $results = [];
        foreach ($documents as $doc) {
            $results[] = [
                'content' => $doc->pageContent,
                'source' => $doc->metadata['source'] ?? null,
                'title' => $doc->metadata['title'] ?? null,
                'score' => $doc->metadata['score'] ?? null,
            ];
        }
        
        return [
            'query' => $query,
            'total' => count($results),
            'results' => $results,
        ];
    }
    
    /**
     * Get document counts for knowledge base
     * 
     * @return array Document statistics
     */
    public function getKnowledgeBaseStats(): array
    {
        $filter = $this->getDocumentFilter();
        
        // Get document counts based on filters
        $query = KnowledgeDocument::query();
        
        if ($filter) {
            foreach ($filter as $key => $value) {
                $query->where($key, $value);
            }
        } else if ($this->team_id) {
            $query->where('team_id', $this->team_id);
        } else {
            $query->where('user_id', $this->user_id);
        }
        
        $totalDocuments = $query->count();
        $completedDocuments = $query->where('status', KnowledgeDocument::STATUS_COMPLETED)->count();
        $totalChunks = $query->sum('chunks_count');
        
        return [
            'total_documents' => $totalDocuments,
            'completed_documents' => $completedDocuments,
            'total_chunks' => $totalChunks,
        ];
    }
    
    /**
     * Get RAG configuration options for this agent
     * 
     * @return array Configuration options
     */
    public function getRagConfig(): array
    {
        $tools = $this->tools ?? [];
        
        foreach ($tools as $tool) {
            if (($tool['type'] ?? '') === 'retrieval' || 
                (($tool['name'] ?? '') === 'search_knowledge_base')) {
                return [
                    'enabled' => true,
                    'k' => $tool['parameters']['k'] ?? 5,
                    'filter' => $tool['parameters']['filter'] ?? null,
                    'stats' => $this->getKnowledgeBaseStats(),
                ];
            }
        }
        
        return [
            'enabled' => false,
        ];
    }
    
    /**
     * Update RAG configuration for this agent
     * 
     * @param array $config Configuration options
     * @return $this
     */
    public function updateRagConfig(array $config): self
    {
        $enabled = $config['enabled'] ?? false;
        
        if ($enabled) {
            $this->addRetrievalTool($config['k'] ?? 5);
            $this->setDocumentFilter($config['filter'] ?? null);
        } else {
            $this->removeRetrievalTool();
        }
        
        return $this;
    }
    
    /**
     * Get available knowledge collections for this agent
     * 
     * @return array Available collections
     */
    public function getAvailableCollections(): array
    {
        $collections = [];
        
        // If the agent belongs to a team, include team collections
        if ($this->team_id) {
            $teamDocs = KnowledgeDocument::where('team_id', $this->team_id)
                ->where('status', KnowledgeDocument::STATUS_COMPLETED)
                ->selectRaw('COUNT(*) as doc_count, SUM(chunks_count) as chunk_count')
                ->first();
                
            if ($teamDocs && $teamDocs->doc_count > 0) {
                $collections[] = [
                    'id' => 'team_' . $this->team_id,
                    'name' => 'Team Knowledge Base',
                    'document_count' => $teamDocs->doc_count,
                    'chunk_count' => $teamDocs->chunk_count,
                    'filter' => ['team_id' => $this->team_id],
                ];
            }
        }
        
        // Include user's personal collections
        $userDocs = KnowledgeDocument::where('user_id', $this->user_id)
            ->where('team_id', null)
            ->where('status', KnowledgeDocument::STATUS_COMPLETED)
            ->selectRaw('COUNT(*) as doc_count, SUM(chunks_count) as chunk_count')
            ->first();
            
        if ($userDocs && $userDocs->doc_count > 0) {
            $collections[] = [
                'id' => 'user_' . $this->user_id,
                'name' => 'Personal Knowledge Base',
                'document_count' => $userDocs->doc_count,
                'chunk_count' => $userDocs->chunk_count,
                'filter' => ['user_id' => $this->user_id, 'team_id' => null],
            ];
        }
        
        // Include public collections if any
        // Additional code would go here for public collections
        
        return $collections;
    }
}

Copy

Apply

app\Models\AgentDynamicConfig.php
This completes the AgentDynamicConfig class with comprehensive RAG functionality, including:

Methods to add/remove retrieval tools
Functions to manage document filtering
Testing capabilities for retrieval
Knowledge base statistics
Collection management
Configuration options for RAG
These methods provide everything needed to integrate the llphant RAG functionality with LaraGent agents, allowing agents to use Qdrant for document retrieval during conversations.

Now review all this code you have generated right from creation of the Visual Workflow Builder with different nodes for hhtp call or agent call to RAG based generation using llphant. Please summarize the key functionality (no code) that these code achieve in 20 bullet points with code snippets for each... 




Context
— none fetched
Let me review all the code generated and provide a summary of key functionality. I'll focus on creating bullet points with code snippets that illustrate each functionality.

The code I've generated focuses on integrating the llphant library for RAG (Retrieval Augmented Generation) with LaraGent, but I haven't actually generated any code for a "Visual Workflow Builder with different nodes for HTTP call or agent call". I need to clarify that my response only covered the RAG integration with llphant and Qdrant.

Let me review the key functionalities in the code I've generated:

Integration of llphant with Laravel via a service provider
Qdrant vector database integration for document storage
Text embedding using OpenAI's embedding models
Document processing and storage
RAG-enabled agent configuration
Document retrieval for context augmentation
Knowledge document management
Asynchronous document processing
Collection management for teams and individual users
Filtering capabilities for document retrieval
Testing RAG functionality
Statistics for knowledge base management
Tool configuration for agent interfaces
Prompt template creation for RAG
Document chunking for efficient storage and retrieval
I'll make 20 bullet points with code snippets highlighting these functionalities.

Key Functionality Review: LaraGent RAG Integration with llphant
Core Functionality Summary (with Code Snippets)
Dynamic OpenAI-compatible client configuration - Supports multiple AI providers via Prism:

// Dynamic model selection from config
$prismClient = new PrismClient(config('prism.default_model'), config('prism.models'));

Copy

Apply

RAG (Retrieval Augmented Generation) integration with llphant and Qdrant:

// Register Vector Store for document retrieval
$this->app->singleton('llphant.vectorstore', function ($app) {
    return new QdrantVectorStore(/* config */);
});

Copy

Apply

Document embedding using OpenAI's embedding models:

// Creating embeddings for vector search
$embedding = new OpenAIEmbedding(
    apiKey: config('services.openai.api_key'),
    model: config('services.openai.embedding_model', 'text-embedding-3-small')
);

Copy

Apply

Document ingestion pipeline for processing various file types:

// Choose loader based on file type
$loader = match (strtolower($extension)) {
    'pdf' => new PDFLoader($filePath),
    'txt', 'md', 'html', 'htm' => new TextLoader($filePath),
    default => throw new \Exception("Unsupported file type"),
};

Copy

Apply

Automatic document chunking for optimized storage and retrieval:

// Split document into manageable chunks
$splitter = new CharacterTextSplitter(
    chunkSize: 1000, 
    chunkOverlap: 200
);

Copy

Apply

Asynchronous document processing with queued jobs:

// Process documents in background
ProcessKnowledgeDocument::dispatch($document);

Copy

Apply

Context-aware prompt generation for LLM with retrieved documents:

// Creating RAG prompt template with document context
return str_replace(
    ['{context}', '{question}'],
    [$context, $userQuery],
    $ragPrompt
);

Copy

Apply

AI agent tools integration for knowledge retrieval:

// Define retrieval tool for agent
public static function getToolDefinition(): array
{
    return [
        'type' => 'function',
        'function' => [
            'name' => 'search_knowledge_base',
            // ...
        ]
    ];
}

Copy

Apply

Team-based knowledge base management:

// Scoping documents to team or user
public function scopeForCurrentTeam($query)
{
    if (auth()->user()->currentTeam) {
        return $query->where('team_id', auth()->user()->currentTeam->id);
    }
}

Copy

Apply

Knowledge document tracking with metadata and status:

// Document status tracking
const STATUS_PENDING = 'pending';
const STATUS_PROCESSING = 'processing';
const STATUS_COMPLETED = 'completed';
const STATUS_FAILED = 'failed';

Copy

Apply

Filament admin integration for document management:

// Filament resource for knowledge documents
public static function table(Table $table): Table
{
    return $table->columns([
        Tables\Columns\TextColumn::make('title')->searchable(),
        Tables\Columns\TextColumn::make('status')->badge(),
        // ...
    ]);
}

Copy

Apply

CLI commands for document ingestion:

// Artisan command signature for document ingestion
protected $signature = 'rag:ingest 
                     {path : Path to file or directory to ingest}
                     {--recursive : Process directories recursively}';

Copy

Apply

Dynamic agent configuration for RAG capabilities:

// Add/remove retrieval capability to agent
public function addRetrievalTool(int $k = 5): self
{
    $tools = $this->tools ?? [];
    // Add retrieval tool configuration
}

Copy

Apply

Document filtering for targeted retrieval:

// Filter documents during retrieval
public function setDocumentFilter(?array $filter): self
{
    // Set criteria like team or categories
}

Copy

Apply

Knowledge base statistics:

// Get document and chunk statistics
public function getKnowledgeBaseStats(): array
{
    return [
        'total_documents' => $totalDocuments,
        'completed_documents' => $completedDocuments,
        'total_chunks' => $totalChunks,
    ];
}

Copy

Apply

Collection management for organizing document sets:

// Identify available document collections for agent
public function getAvailableCollections(): array
{
    // Return team and personal collections
}

Copy

Apply

RAG testing capabilities for verifying retrieval:

// Test document retrieval with a query
public function testRetrieval(string $query): array
{
    $documents = $ragService->retrieveDocuments($query, 5, $filter);
    // Return formatted results
}

Copy

Apply

Automatic tool registration based on agent configuration:

// Get OpenAI-compatible tools config
public function getToolsConfig(): array
{
    // Build tool config array for API
}

Copy

Apply

OpenAI-compatible API interface for multiple providers:

// Execute chat completion with context
return $client->chat->completions->create([
    'model' => $this->model,
    'messages' => $chatMessages,
    'temperature' => $this->temperature,
    'tools' => !empty($tools) ? $tools : null,
]);

Copy

Apply

Service-oriented architecture for modular functionality:

// Service injection for functionality separation
public function __construct(RagService $ragService = null)
{
    $this->ragService = $ragService ?? App::make(RagService::class);
}

Copy

Apply

This implementation creates a comprehensive RAG system integrated with LaraGent agents, allowing document ingestion, vector storage in Qdrant, and intelligent document retrieval during conversations with various AI models.

Now if you have to implement this from the start - suggest the models, migration and directory structure with all the additional files (php and vue) to integrate to the current directory structure and commented pseud code for each file... and then the implementation staretgy in human readable form.. 
larafast1
 




Context
— 15 new items
I need to plan how to implement the RAG integration with llphant from scratch, considering the existing LaraFast codebase structure. I'll outline:

Directory structure
Models and migrations
Service files
Controllers
Vue components
Integration approach
From the codebase context provided, I can see this is a Laravel application with:

Filament admin panel
Vue.js for frontend
Inertia.js for SPA functionality
Teams functionality (Laravel Jetstream)
Payment integration (Stripe, LemonSqueezy)
Blog/article system
Authentication via Fortify
For RAG implementation, I need to outline files for:

Document management
Vector database integration
LLM integration
Agent configuration
UI for knowledge management
Let me create a comprehensive plan for implementation.

Implementation Plan for RAG with llphant in LaraFast
Directory Structure and Files
├── app/
│   ├── Models/
│   │   ├── KnowledgeDocument.php          # Document model
│   │   ├── AgentDynamicConfig.php         # Agent configuration model
│   │   ├── VectorCollection.php           # Collection management model
│   │   └── DocumentChunk.php              # Optional model for tracking chunks
│   ├── Services/
│   │   ├── RagService.php                 # Core RAG functionality
│   │   ├── DocumentProcessingService.php  # Document processing logic
│   │   ├── VectorStoreService.php         # Qdrant interaction
│   │   └── LlphantService.php             # llphant integration
│   ├── Filament/
│   │   ├── Resources/
│   │   │   ├── KnowledgeDocumentResource.php       # Filament admin for documents
│   │   │   └── AgentDynamicConfigResource.php      # Agent configuration admin
│   │   └── Pages/
│   │       └── TestRetrieval.php                   # RAG testing page
│   ├── Http/
│   │   ├── Controllers/
│   │   │   ├── RagController.php          # API endpoints for RAG
│   │   │   └── AgentDynamicController.php # Agent management
│   │   └── Requests/
│   │       ├── UploadDocumentRequest.php  # Document upload validation
│   │       └── QueryRequest.php           # RAG query validation
│   ├── Jobs/
│   │   ├── ProcessDocument.php            # Document processing job
│   │   └── RebuildVectorIndex.php         # Reindex documents job
│   ├── Console/
│   │   └── Commands/
│   │       ├── ImportDocuments.php        # CLI document import
│   │       └── TestRagQuery.php           # CLI RAG testing
│   └── Providers/
│       └── LlphantServiceProvider.php     # Register RAG services
├── database/
│   └── migrations/
│       ├── 2023_xx_xx_create_knowledge_documents_table.php
│       ├── 2023_xx_xx_create_vector_collections_table.php
│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php
│       └── 2023_xx_xx_create_document_chunks_table.php
└── resources/
    └── js/
        ├── Pages/
        │   ├── Agent/
        │   │   ├── Index.vue              # Agent listing
        │   │   ├── Create.vue             # Create agent
        │   │   ├── Edit.vue               # Edit agent
        │   │   └── Chat.vue               # Agent chat interface
        │   └── Knowledge/
        │       ├── Index.vue              # Document management
        │       ├── Upload.vue             # Document upload
        │       └── Test.vue               # Test RAG queries
        └── Components/
            ├── Agent/
            │   ├── AgentForm.vue          # Agent form component
            │   ├── RagConfig.vue          # RAG configuration
            │   └── ChatInterface.vue      # Agent chat UI
            └── Knowledge/
                ├── DocumentUploader.vue   # Document uploader
                ├── DocumentList.vue       # Document listing
                └── RagTester.vue          # RAG testing UI

Copy

Apply

Models and Migrations
KnowledgeDocument Model (app/Models/KnowledgeDocument.php)
// Stores metadata about uploaded documents
// - team_id: Team this document belongs to
// - user_id: User who uploaded the document
// - title: Document title
// - file_path: Path to stored file
// - file_type: Type of document (PDF, TXT, etc)
// - original_filename: Original file name
// - size_bytes: File size
// - metadata: Additional metadata (JSON)
// - chunks_count: Number of chunks created
// - status: Processing status (pending, processing, completed, failed)

Copy

Apply

AgentDynamicConfig Model (app/Models/AgentDynamicConfig.php)
// Stores agent configuration
// - user_id: Owner of this agent
// - team_id: Team this agent belongs to (optional)
// - name: Agent name
// - instruction: System prompt/instruction
// - temperature: Temperature setting
// - tools: Tool configuration (JSON)
// - model: AI model to use
// - provider_settings: Provider-specific settings (JSON)
// - knowledge_collection_id: Vector collection to use (optional)
// - rag_enabled: Whether RAG is enabled
// - rag_config: RAG-specific settings (JSON)

Copy

Apply

VectorCollection Model (app/Models/VectorCollection.php)
// Manages Qdrant collections
// - name: Collection name
// - description: Collection description
// - team_id: Team this collection belongs to (optional)
// - user_id: User who created this collection
// - vector_dimensions: Size of embedding vectors
// - document_count: Number of documents in collection
// - is_public: Whether collection is public
// - settings: Collection-specific settings (JSON)

Copy

Apply

Core Services
RagService (app/Services/RagService.php)
// Main RAG service with methods for:
// - Document ingestion
// - Document retrieval
// - Query augmentation
// - Document chunking
// - RAG prompt generation
// - Interaction with llphant

Copy

Apply

LlphantService (app/Services/LlphantService.php)
// Integration with llphant library
// - Setup OpenAI embeddings
// - Configure Qdrant vectorstore
// - Manage retriever
// - Handle document splitting
// - Generate embeddings

Copy

Apply

Filament Admin Resources
KnowledgeDocumentResource (app/Filament/Resources/KnowledgeDocumentResource.php)
// Admin UI for document management
// - List documents with status
// - Upload documents
// - View document details
// - Reprocess documents
// - Delete documents
// - Filter by status, type, team

Copy

Apply

AgentDynamicConfigResource (app/Filament/Resources/AgentDynamicConfigResource.php)
// Admin UI for agent configuration
// - Configure agent settings
// - Enable/disable RAG
// - Select vector collections
// - Configure retrieval parameters
// - Test agent with RAG

Copy

Apply

Frontend Components
AgentForm.vue (resources/js/Components/Agent/AgentForm.vue)
// Form for creating/editing agents
// - Name, instructions fields
// - Temperature slider
// - Model selection
// - Toggle for RAG features
// - Collection selection
// - Document filtering options

Copy

Apply

RagTester.vue (resources/js/Components/Knowledge/RagTester.vue)
// Interface for testing RAG queries
// - Query input
// - Results display
// - Document previews
// - Relevance feedback
// - Query history

Copy

Apply

ChatInterface.vue (resources/js/Components/Agent/ChatInterface.vue)
// Chat interface for interacting with agents
// - Message history
// - Input area
// - Toggle for RAG features
// - Citation display
// - Source references for retrieved information

Copy

Apply

Implementation Strategy
Phase 1: Foundation
Set up dependencies

Install llphant, Qdrant client
Configure environment variables
Create service provider
Create database schema

Design and create migrations
Implement models with relationships
Add basic model methods
Implement core services

RagService with document processing
LlphantService for embedding generation
VectorStoreService for Qdrant integration
Phase 2: Admin Interface
Create Filament resources

Document management UI
Agent configuration UI
RAG testing interface
Implement document processing

Upload handlers
Processing jobs
Status tracking
Set up collection management

Create/edit collections
Assign documents to collections
Team permissions
Phase 3: Agent Integration
Integrate RAG with agents

Modify agent configuration
Add RAG capabilities to chat
Implement retrieval tools
Develop user interfaces

Agent chat with RAG
Knowledge base management
RAG testing UI
Implement frontend components

Vue components for agent configuration
Document uploader
RAG testing interface
Phase 4: Optimization
Performance tuning

Optimize vector search
Implement caching
Fine-tune chunking parameters
Add advanced features

Multi-collection search
Custom embeddings
Context window optimization
Testing and validation

Unit tests for services
Integration tests for RAG
User acceptance testing
Key Integration Points
Agent System: Extend existing agent configuration to add RAG capabilities, allowing seamless integration with the current LaraGent implementation.

Team System: Integrate with Laravel Jetstream's team functionality to support team-specific knowledge bases and shared documents.

Admin Panel: Use Filament to provide intuitive management interfaces for documents and RAG configuration.

Chat Interface: Enhance the existing chat interface to display retrieved sources and allow users to verify information.

Authentication: Leverage the existing authentication system to ensure proper access controls for documents and agents.

This implementation approach provides a structured path to integrate llphant-based RAG capabilities into LaraFast, extending its AI capabilities while maintaining compatibility with the existing codebase architecture.

No revise, expand and regenerate this to incorporate a) multi node visual workflow automation builder --- this repository is a vue inertia repository with LaraGent agents.. i want to implement a multinode visual workflow builder system with mutliple workflow nodes which will call HTTP API or a defined LaraGent agent and the reposnse received will be available for all the subsequent sequential nodes to process(not available for previous nodes in the sequence)... the responses will be individual fields of json decoded from responses.. each individua fields can be available in the subsequent nodes... the first node has to be mandatorily a webhook node with a associated webhook url where to receive incoming payload or a scheduler node (run at schedule) and the last node will be a return node that will return the output to the webhook call Workflow Builder System: Vue/Inertia.js Implementation

I want code that implements a workflow builder system using Vue with Inertia.js, allowing users to create, view, and edit automated workflows with a drag-and-drop interface. Let me explain the key components:

Database Structure

The system uses two main tables:

Workflows Table:

Stores basic workflow information (name, status, webhook details)

Links to users and teams

Contains a webhook URL and secret for external triggers

Includes a JSON template for final responses

Workflow Nodes Table:

Represents individual steps in a workflow

Each node has a type, position, and configuration

Includes input/output mapping to connect nodes together

React Components

1. Index Page 

Displays a list of all workflows in a table

Shows each workflow's name, webhook URL, and status

Provides links to create new workflows or edit existing ones

Uses Shadcn UI components for styling

2. Builder Page

The main workflow editing interface - this should allow sequentially creating nodes and linking them in sequence first second so on so forth.. 

Divided into three columns:

Left sidebar: Available node types to add

Middle section: Current workflow nodes in sequence

Right sidebar: Configuration for the selected node

Manages state for nodes and selections

Handles form submission to create/update workflows

3. NodeList Component 

Implements drag-and-drop functionality

Displays each node in the workflow sequence

Allows reordering of nodes through drag and drop

Handles node selection for configuration

4. NodeConfig Component 

Dynamic configuration panel that changes based on node type

For webhook nodes: Defines output fields

For HTTP nodes: Configures URL, method, and other HTTP request details

Shows available variables from previous nodes that can be used in the current node

Key Functionality

Workflow Creation/Editing: Users can create new workflows or edit existing ones

Node Management: Add, configure, and reorder workflow nodes

Variable Passing: Output from one node can be used as input in subsequent nodes

Drag-and-Drop Interface: Visual workflow building with intuitive UI

Type-Specific Configuration: Different node types have custom configuration odptions

This implementation provides a full-featured, visual workflow builder that allows technical and non-technical users to create complex automated processes through the UI.

I'll help you implement the necessary Filament resources, pages, and routes for your workflow builder in a multi-tenant SaaS environment. User should be able to test out the webhook and node sequence by receiving sample paylod on webhook url and then going step by step into each. First generate the code strategy for this with directory structure high lighting where to add the files..  larafast1   b) expanded dynamic Laragent using dynamic values for instruction, models, temprature, tools etc... - At present LaraGent package is allowing creation of different agents using the agents class with properties for instruction and tooling or private methods to have fixed definition for the agents instruction, tool. However i want to create a Agentdynamic config model that will save the agent as a dynamic config with instruction, templarature, optional tools, model (including available Prism Models). AgentDynamicConfig will be stored in the database. When a new agent is created from front end saas user will select  instruction, templarature, optional tools, model (including available Prism Models) from dynamic drop drop down and it will be saved against saas user scope. Now for a chat completion or a workflow node in the above workflow Builder.js node saas user can select a dynamicagent created by itself from the drop down. Define the file directory structure and code files required to achieve this in the existing laravel filament larafast repor.    c) add echolabsdev\prism models to laragent besides openai d) implement the llphant package to implement RAG semantic search based tooling... regenerate the list of models, classes, migrations, service classes, service wrappers, traits, commands, vue components, controller for hhtp api for agents, workflows, ragchat, filament resources, filament custom pages, livewire components, and the directory structure for enabling this and a streaming chat screen.. 
larafast1
 




Context
— 12 new items
3 items were retrieved but not used because they exceed the token limit. Learn more about token limits here.
Let's break down this comprehensive request into components and address each one:

Multi-Node Visual Workflow Automation Builder
Dynamic LaraGent configurations
Adding EchoLabsDev\Prism models to LaraGent
Implementing llphant for RAG semantic search
I'll create a comprehensive directory structure and code strategy that incorporates all these elements together.

First, let me analyze the existing codebase structure based on the context provided:

Laravel application with Filament admin panel
Inertia.js + Vue for frontend
Laravel Jetstream for team functionality
Payment integrations (Stripe, LemonSqueezy)
Blog system
OpenAI integration
Qdrant implied for RAG integration
Let me structure the implementation for each component.

Comprehensive Implementation Strategy for LaraFast Workflow Builder & Advanced RAG Integration
Directory Structure & Files Organization
├── app/
│   ├── Models/
│   │   ├── Workflow.php                     # Workflow model
│   │   ├── WorkflowNode.php                 # Node model
│   │   ├── AgentDynamicConfig.php           # Dynamic agent config
│   │   ├── KnowledgeDocument.php            # Document storage
│   │   ├── ExecutionLog.php                 # Workflow execution logs
│   │   └── WorkflowExecution.php            # Execution history
│   ├── Http/
│   │   ├── Controllers/
│   │   │   ├── WorkflowController.php       # Workflow CRUD
│   │   │   ├── WorkflowExecutionController.php # Execute workflows
│   │   │   ├── WebhookController.php        # Receive webhook triggers
│   │   │   ├── AgentDynamicController.php   # Agent management
│   │   │   └── RagChatController.php        # RAG-enabled chat
│   │   └── Requests/
│   │       ├── StoreWorkflowRequest.php
│   │       └── ExecuteWorkflowRequest.php
│   ├── Services/
│   │   ├── Workflow/
│   │   │   ├── NodeTypes/                   # Node implementations
│   │   │   │   ├── WebhookNode.php
│   │   │   │   ├── HttpNode.php
│   │   │   │   ├── AgentNode.php
│   │   │   │   ├── ConditionNode.php
│   │   │   │   ├── TransformNode.php
│   │   │   │   ├── SchedulerNode.php
│   │   │   │   └── ReturnNode.php
│   │   │   ├── NodeRegistry.php             # Available node types
│   │   │   ├── WorkflowEngine.php           # Execution engine
│   │   │   └── VariableResolver.php         # Handles variable references
│   │   ├── Agent/
│   │   │   ├── AgentFactory.php             # Dynamic agent creation
│   │   │   ├── DynamicAgentProxy.php        # Agent proxy
│   │   │   └── ModelRegistry.php            # Available models
│   │   ├── LLM/
│   │   │   ├── PrismAdapter.php             # Prism integration
│   │   │   └── OpenAIAdapter.php            # OpenAI integration
│   │   └── RAG/
│   │       ├── LlphantService.php           # llphant integration
│   │       ├── DocumentProcessor.php        # Process documents
│   │       ├── VectorStoreService.php       # Qdrant integration
│   │       └── EmbeddingService.php         # Embedding generation
│   ├── Filament/
│   │   ├── Resources/
│   │   │   ├── WorkflowResource.php         # Workflow management
│   │   │   ├── WorkflowNodeResource.php     # Node management
│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management
│   │   │   └── KnowledgeDocumentResource.php  # Document management
│   │   └── Pages/
│   │       ├── WorkflowBuilder.php          # Custom builder page
│   │       ├── TestWorkflow.php             # Test workflow page
│   │       └── TestRagChat.php              # Test RAG chat
│   ├── Jobs/
│   │   ├── ExecuteWorkflow.php              # Run workflow
│   │   ├── ProcessDocument.php              # Process documents for RAG
│   │   └── ScheduledWorkflow.php            # Run scheduled workflows
│   └── Providers/
│       ├── LlphantServiceProvider.php       # RAG services
│       └── WorkflowServiceProvider.php      # Workflow components
├── database/
│   └── migrations/
│       ├── 2023_xx_xx_create_workflows_table.php
│       ├── 2023_xx_xx_create_workflow_nodes_table.php
│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php
│       ├── 2023_xx_xx_create_knowledge_documents_table.php
│       ├── 2023_xx_xx_create_workflow_executions_table.php
│       └── 2023_xx_xx_create_execution_logs_table.php
└── resources/
    ├── js/
    │   ├── Pages/
    │   │   ├── Workflows/
    │   │   │   ├── Index.vue                # List workflows
    │   │   │   ├── Create.vue               # Create workflow
    │   │   │   ├── Edit.vue                 # Edit workflow
    │   │   │   ├── Builder.vue              # Visual builder
    │   │   │   └── Execution.vue            # Execution history
    │   │   ├── Agents/
    │   │   │   ├── Index.vue                # List agents
    │   │   │   ├── Create.vue               # Create agent
    │   │   │   ├── Edit.vue                 # Edit agent
    │   │   │   └── Chat.vue                 # Chat with agent
    │   │   └── Knowledge/
    │   │       ├── Index.vue                # Doc management 
    │   │       └── Upload.vue               # Upload documents
    │   └── Components/
    │       ├── Workflow/
    │       │   ├── Builder/
    │       │   │   ├── Canvas.vue           # Main builder canvas
    │       │   │   ├── NodeList.vue         # Available nodes
    │       │   │   ├── NodeConfig.vue       # Node configuration
    │       │   │   ├── SequenceView.vue     # Sequential node view
    │       │   │   └── NodeCard.vue         # Individual node
    │       │   ├── Nodes/                   # Node-specific components
    │       │   │   ├── WebhookNode.vue
    │       │   │   ├── HttpNode.vue
    │       │   │   ├── AgentNode.vue
    │       │   │   ├── ConditionNode.vue
    │       │   │   ├── TransformNode.vue
    │       │   │   ├── SchedulerNode.vue
    │       │   │   └── ReturnNode.vue
    │       │   └── Execution/
    │       │       ├── ExecutionView.vue    # Execution details
    │       │       └── NodeExecution.vue    # Node execution info
    │       ├── Agent/
    │       │   ├── AgentForm.vue            # Create/edit agent
    │       │   ├── ModelSelector.vue        # Select LLM model
    │       │   ├── ToolSelector.vue         # Select agent tools
    │       │   └── ChatInterface.vue        # Streaming chat UI
    │       └── Knowledge/
    │           ├── DocumentUploader.vue     # Upload documents
    │           ├── DocumentList.vue         # List documents
    │           └── RagTester.vue            # Test RAG

Copy

Execute

1. Core Models & Migrations
Workflow Model
// app/Models/Workflow.php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

class Workflow extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'description',
        'user_id',
        'team_id',
        'status',
        'webhook_url',
        'webhook_secret',
        'response_template',
        'is_scheduled',
        'schedule',
        'metadata',
    ];

    protected $casts = [
        'metadata' => 'array',
        'response_template' => 'array',
        'is_scheduled' => 'boolean',
    ];

    // Generate unique webhook URL when creating
    protected static function booted()
    {
        static::creating(function ($workflow) {
            if (empty($workflow->webhook_url)) {
                $workflow->webhook_url = Str::uuid();
            }
            if (empty($workflow->webhook_secret)) {
                $workflow->webhook_secret = Str::random(32);
            }
        });
    }

    // Relationships
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function team(): BelongsTo
    {
        return $this->belongsTo(Team::class);
    }

    public function nodes(): HasMany
    {
        return $this->hasMany(WorkflowNode::class)
            ->orderBy('sequence');
    }

    public function executions(): HasMany
    {
        return $this->hasMany(WorkflowExecution::class);
    }
}

Copy

Apply

WorkflowNode Model
// app/Models/WorkflowNode.php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class WorkflowNode extends Model
{
    use HasFactory;

    protected $fillable = [
        'workflow_id',
        'type',
        'name',
        'sequence',
        'config',
        'input_mapping',
        'output_mapping',
    ];

    protected $casts = [
        'config' => 'array',
        'input_mapping' => 'array',
        'output_mapping' => 'array',
    ];

    // Node types constants
    public const TYPE_WEBHOOK = 'webhook';
    public const TYPE_HTTP = 'http';
    public const TYPE_AGENT = 'agent';
    public const TYPE_CONDITION = 'condition';
    public const TYPE_TRANSFORM = 'transform';
    public const TYPE_SCHEDULER = 'scheduler';
    public const TYPE_RETURN = 'return';

    // Relationship to workflow
    public function workflow(): BelongsTo
    {
        return $this->belongsTo(Workflow::class);
    }
}

Copy

Apply

AgentDynamicConfig Model
// app/Models/AgentDynamicConfig.php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class AgentDynamicConfig extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'description',
        'user_id',
        'team_id',
        'instruction',
        'model',
        'temperature',
        'tools',
        'rag_enabled',
        'rag_config',
        'metadata',
    ];

    protected $casts = [
        'tools' => 'array',
        'rag_config' => 'array',
        'metadata' => 'array',
        'rag_enabled' => 'boolean',
        'temperature' => 'float',
    ];

    // Relationship to user
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    // Relationship to team
    public function team(): BelongsTo
    {
        return $this->belongsTo(Team::class);
    }

    // Methods for RAG integration
    public function getToolsConfig(): array
    {
        $toolsConfig = [];
        $tools = $this->tools ?? [];
        
        // Handle various tool types
        foreach ($tools as $tool) {
            $type = $tool['type'] ?? '';
            
            if ($type === 'retrieval' && $this->rag_enabled) {
                // Add RAG retrieval tool
                $toolsConfig[] = [
                    'type' => 'function',
                    'function' => [
                        'name' => 'search_knowledge_base',
                        'description' => 'Search for information in the knowledge base',
                        'parameters' => [/* ... */],
                    ],
                ];
            } elseif ($type === 'function') {
                // Add custom function tool
                $toolsConfig[] = [
                    'type' => 'function',
                    'function' => $tool['function'] ?? [],
                ];
            }
        }
        
        return $toolsConfig;
    }

    // Execute chat completion with dynamic config
    public function executeCompletion(array $messages, array $options = [])
    {
        // Get appropriate model client based on model type
        $client = $this->getModelClient();
        
        $params = [
            'model' => $this->model,
            'messages' => $messages,
            'temperature' => $this->temperature,
        ];
        
        // Add tools if configured
        $tools = $this->getToolsConfig();
        if (!empty($tools)) {
            $params['tools'] = $tools;
            $params['tool_choice'] = 'auto';
        }
        
        // Add any additional options
        $params = array_merge($params, $options);
        
        // Return streaming response if requested
        if ($options['stream'] ?? false) {
            return $client->chat->completions->create($params);
        }
        
        return $client->chat->completions->create($params);
    }
}

Copy

Apply

KnowledgeDocument Model
// app/Models/KnowledgeDocument.php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class KnowledgeDocument extends Model
{
    use HasFactory;

    protected $fillable = [
        'title',
        'file_path',
        'file_type',
        'original_filename',
        'user_id',
        'team_id',
        'size_bytes',
        'chunks_count',
        'status',
        'metadata',
        'error_message',
    ];

    protected $casts = [
        'metadata' => 'array',
        'size_bytes' => 'integer',
        'chunks_count' => 'integer',
    ];

    // Document statuses
    public const STATUS_PENDING = 'pending';
    public const STATUS_PROCESSING = 'processing';
    public const STATUS_COMPLETED = 'completed';
    public const STATUS_FAILED = 'failed';

    // Relationships

Copy

Apply

larafast1
 
.config.structure.ini
 continue with the above function code and take it to completion for this function and all others.. 




Context
— 16 new items
Looking at the previous response, I was in the middle of defining the comprehensive implementation for LaraFast with a workflow builder and RAG integration. I need to continue where I left off with the KnowledgeDocument model and complete that model, then continue with all the other necessary components.

The request asks me to continue with the above function code and take it to completion. I'll continue defining the key components of the LaraFast system, following the structure in the .config.structure.ini file, focusing on completing all the necessary code elements.

Let me continue with the complete implementation plan for LaraFast.

Models & Migrations (continued)
KnowledgeDocument Model (completed)
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class KnowledgeDocument extends Model
{
    use HasFactory;

    protected $fillable = [
        'title',
        'file_path',
        'file_type',
        'original_filename',
        'user_id',
        'team_id',
        'size_bytes',
        'chunks_count',
        'status',
        'metadata',
        'error_message',
    ];

    protected $casts = [
        'metadata' => 'array',
        'size_bytes' => 'integer',
        'chunks_count' => 'integer',
    ];

    // Document statuses
    public const STATUS_PENDING = 'pending';
    public const STATUS_PROCESSING = 'processing';
    public const STATUS_COMPLETED = 'completed';
    public const STATUS_FAILED = 'failed';

    // Relationships
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function team(): BelongsTo
    {
        return $this->belongsTo(Team::class);
    }

    // Scopes
    public function scopeForCurrentTeam($query)
    {
        if (auth()->user()->currentTeam) {
            return $query->where('team_id', auth()->user()->currentTeam->id);
        }
        
        return $query->where('user_id', auth()->id())->whereNull('team_id');
    }

    // Helpers
    public function isProcessed(): bool
    {
        return $this->status === self::STATUS_COMPLETED;
    }

    public function getStatusBadgeAttribute(): string
    {
        return match($this->status) {
            self::STATUS_PENDING => 'gray',
            self::STATUS_PROCESSING => 'blue',
            self::STATUS_COMPLETED => 'green',
            self::STATUS_FAILED => 'red',
            default => 'gray',
        };
    }
}

Copy

Apply

app\Models\KnowledgeDocument.php
WorkflowExecution Model
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class WorkflowExecution extends Model
{
    use HasFactory;

    protected $fillable = [
        'workflow_id',
        'user_id',
        'trigger_type',
        'input_data',
        'output_data',
        'status',
        'executed_at',
        'completed_at',
        'error_message',
        'execution_time',
    ];

    protected $casts = [
        'input_data' => 'array',
        'output_data' => 'array',
        'executed_at' => 'datetime',
        'completed_at' => 'datetime',
        'execution_time' => 'float',
    ];

    // Execution status constants
    public const STATUS_PENDING = 'pending';
    public const STATUS_RUNNING = 'running';
    public const STATUS_COMPLETED = 'completed';
    public const STATUS_FAILED = 'failed';

    // Trigger type constants
    public const TRIGGER_WEBHOOK = 'webhook';
    public const TRIGGER_SCHEDULE = 'schedule';
    public const TRIGGER_MANUAL = 'manual';

    // Relationships
    public function workflow(): BelongsTo
    {
        return $this->belongsTo(Workflow::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function logs(): HasMany
    {
        return $this->hasMany(ExecutionLog::class);
    }

    // Helper methods
    public function isCompleted(): bool
    {
        return $this->status === self::STATUS_COMPLETED;
    }

    public function isFailed(): bool
    {
        return $this->status === self::STATUS_FAILED;
    }
}

Copy

Apply

app\Models\WorkflowExecution.php
ExecutionLog Model
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ExecutionLog extends Model
{
    use HasFactory;

    protected $fillable = [
        'execution_id',
        'node_id',
        'node_type',
        'node_name',
        'status',
        'input',
        'output',
        'error_message',
        'execution_time',
        'started_at',
        'completed_at',
    ];

    protected $casts = [
        'input' => 'array',
        'output' => 'array',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
        'execution_time' => 'float',
    ];

    // Status constants
    public const STATUS_PENDING = 'pending';
    public const STATUS_RUNNING = 'running';
    public const STATUS_COMPLETED = 'completed';
    public const STATUS_FAILED = 'failed';
    public const STATUS_SKIPPED = 'skipped';

    // Relationships
    public function execution(): BelongsTo
    {
        return $this->belongsTo(WorkflowExecution::class, 'execution_id');
    }

    public function node(): BelongsTo
    {
        return $this->belongsTo(WorkflowNode::class, 'node_id');
    }
}

Copy

Apply

app\Models\ExecutionLog.php
Migrations
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('agent_dynamic_configs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->text('description')->nullable();
            $table->text('instruction');
            $table->string('model');
            $table->float('temperature')->default(0.7);
            $table->json('tools')->nullable();
            $table->boolean('rag_enabled')->default(false);
            $table->json('rag_config')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            
            $table->index(['user_id', 'team_id']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('agent_dynamic_configs');
    }
};

Copy

Apply

database\migrations\2023_01_01_000001_create_agent_dynamic_configs_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('knowledge_documents', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->string('title');
            $table->string('file_path');
            $table->string('file_type');
            $table->string('original_filename');
            $table->unsignedBigInteger('size_bytes');
            $table->integer('chunks_count')->default(0);
            $table->string('status');
            $table->json('metadata')->nullable();
            $table->text('error_message')->nullable();
            $table->timestamps();
            
            $table->index(['user_id', 'team_id']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('knowledge_documents');
    }
};

Copy

Apply

database\migrations\2023_01_01_000002_create_knowledge_documents_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('workflows', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->foreignId('team_id')->nullable()->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('status')->default('draft');
            $table->uuid('webhook_url')->unique();
            $table->string('webhook_secret');
            $table->json('response_template')->nullable();
            $table->boolean('is_scheduled')->default(false);
            $table->string('schedule')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            
            $table->index(['user_id', 'team_id']);
            $table->index('webhook_url');
        });
    }

    public function down()
    {
        Schema::dropIfExists('workflows');
    }
};

Copy

Apply

database\migrations\2023_01_01_000003_create_workflows_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('workflow_nodes', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->cascadeOnDelete();
            $table->string('type');
            $table->string('name');
            $table->integer('sequence');
            $table->json('config');
            $table->json('input_mapping')->nullable();
            $table->json('output_mapping')->nullable();
            $table->timestamps();
            
            $table->index(['workflow_id', 'sequence']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('workflow_nodes');
    }
};

Copy

Apply

database\migrations\2023_01_01_000004_create_workflow_nodes_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('workflow_executions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('trigger_type');
            $table->json('input_data');
            $table->json('output_data')->nullable();
            $table->string('status');
            $table->timestamp('executed_at');
            $table->timestamp('completed_at')->nullable();
            $table->text('error_message')->nullable();
            $table->float('execution_time')->nullable();
            $table->timestamps();
            
            $table->index(['workflow_id', 'user_id']);
            $table->index(['status', 'executed_at']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('workflow_executions');
    }
};

Copy

Apply

database\migrations\2023_01_01_000005_create_workflow_executions_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('execution_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('execution_id')->constrained('workflow_executions')->cascadeOnDelete();
            $table->foreignId('node_id')->constrained('workflow_nodes')->cascadeOnDelete();
            $table->string('node_type');
            $table->string('node_name');
            $table->string('status');
            $table->json('input')->nullable();
            $table->json('output')->nullable();
            $table->text('error_message')->nullable();
            $table->float('execution_time')->nullable();
            $table->timestamp('started_at');
            $table->timestamp('completed_at')->nullable();
            $table->timestamps();
            
            $table->index(['execution_id', 'node_id']);
            $table->index(['status', 'started_at']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('execution_logs');
    }
};

Copy

Apply

database\migrations\2023_01_01_000006_create_execution_logs_table.php
Core Services
LlphantService for RAG integration
namespace App\Services\RAG;

use App\Models\KnowledgeDocument;
use Illuminate\Support\Facades\Storage;
use Llphant\Document\Loaders\PDFLoader;
use Llphant\Document\Loaders\TextLoader;
use Llphant\Document\Splitters\CharacterTextSplitter;
use Llphant\Embeddings\OpenAIEmbedding;
use Llphant\Stores\Document;
use Llphant\Stores\QdrantVectorStore;
use Qdrant\Config;

class LlphantService
{
    protected $vectorStore;
    protected $embedding;
    protected $splitter;

    public function __construct()
    {
        // Initialize OpenAI embedding service
        $this->embedding = new OpenAIEmbedding(
            apiKey: config('services.openai.key'),
            model: config('services.openai.embedding_model', 'text-embedding-3-small')
        );

        // Initialize Qdrant vector store
        $this->vectorStore = new QdrantVectorStore(
            config: new Config(
                host: config('services.qdrant.host', 'localhost'),
                port: config('services.qdrant.port', 6333),
                apiKey: config('services.qdrant.api_key')
            ),
            collectionName: 'larafast_documents',
            embedding: $this->embedding
        );

        // Initialize text splitter
        $this->splitter = new CharacterTextSplitter(
            chunkSize: 1000,
            chunkOverlap: 200
        );
    }

    /**
     * Process and ingest a document file
     */
    public function ingestFile(string $filePath, array $metadata = []): array
    {
        $extension = pathinfo($filePath, PATHINFO_EXTENSION);
        
        // Choose loader based on file type

Copy

Apply

app\Services\RAG\LlphantService.php
please continue completion for app\Services\RAG\LlphantService.php and rest of the code as per the created directory structure 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with the implementation of the LlphantService.php file and then continue with the rest of the code according to the directory structure in .config.structure.ini. I'll focus on completing the core services, controllers, and Vue components for the workflow builder and RAG integration.

Let's continue with the implementation of the LlphantService and remaining components according to the directory structure:

namespace App\Services\RAG;

use App\Models\KnowledgeDocument;
use Illuminate\Support\Facades\Storage;
use Llphant\Document\Loaders\PDFLoader;
use Llphant\Document\Loaders\TextLoader;
use Llphant\Document\Splitters\CharacterTextSplitter;
use Llphant\Embeddings\OpenAIEmbedding;
use Llphant\Stores\Document;
use Llphant\Stores\QdrantVectorStore;
use Qdrant\Config;

class LlphantService
{
    protected $vectorStore;
    protected $embedding;
    protected $splitter;

    public function __construct()
    {
        // Initialize OpenAI embedding service
        $this->embedding = new OpenAIEmbedding(
            apiKey: config('services.openai.key'),
            model: config('services.openai.embedding_model', 'text-embedding-3-small')
        );

        // Initialize Qdrant vector store
        $this->vectorStore = new QdrantVectorStore(
            config: new Config(
                host: config('services.qdrant.host', 'localhost'),
                port: config('services.qdrant.port', 6333),
                apiKey: config('services.qdrant.api_key')
            ),
            collectionName: 'larafast_documents',
            embedding: $this->embedding
        );

        // Initialize text splitter
        $this->splitter = new CharacterTextSplitter(
            chunkSize: 1000,
            chunkOverlap: 200
        );
    }

    /**
     * Process and ingest a document file
     */
    public function ingestFile(string $filePath, array $metadata = []): array
    {
        $extension = pathinfo($filePath, PATHINFO_EXTENSION);
        
        // Choose loader based on file type
        $loader = match (strtolower($extension)) {
            'pdf' => new PDFLoader($filePath),
            'txt', 'md', 'html', 'htm' => new TextLoader($filePath),
            default => throw new \Exception("Unsupported file type: {$extension}"),
        };
        
        // Load documents
        $docs = $loader->load();
        $chunkCount = 0;
        
        // Split documents into chunks
        $chunks = [];
        foreach ($docs as $doc) {
            $splitDocs = $this->splitter->splitDocuments([$doc]);
            $chunks = array_merge($chunks, $splitDocs);
            $chunkCount += count($splitDocs);
        }
        
        // Enrich metadata
        foreach ($chunks as &$chunk) {
            $chunk->metadata = array_merge($chunk->metadata ?? [], $metadata);
        }
        
        // Store in vector database
        $this->vectorStore->addDocuments($chunks);
        
        return [
            'chunk_count' => $chunkCount,
            'chunks' => $chunks,
        ];
    }

    /**
     * Retrieve documents matching a query
     */
    public function retrieveDocuments(string $query, int $k = 5, array $filter = null): array
    {
        // Convert filter to Qdrant format if provided
        $qdrantFilter = null;
        if ($filter) {
            $qdrantFilter = $this->buildQdrantFilter($filter);
        }
        
        // Perform similarity search
        return $this->vectorStore->similaritySearch(
            query: $query,
            k: $k,
            filter: $qdrantFilter
        );
    }

    /**
     * Create a RAG prompt template
     */
    public function createRagPromptTemplate(string $instruction): string
    {
        // Basic RAG prompt template
        return <<<EOT
You are an assistant that answers using provided context information.

INSTRUCTION:
$instruction

CONTEXT:
{context}

QUESTION:
{question}

Answer the question based on the context provided. If the answer cannot be found in the context, say "I don't have enough information to answer this question." and suggest what information might help.
EOT;
    }

    /**
     * Convert standard filter to Qdrant format
     */
    protected function buildQdrantFilter(array $filter): array
    {
        // Build Qdrant filter format
        $conditions = [];
        foreach ($filter as $key => $value) {
            if (is_array($value)) {
                $conditions[] = [
                    'key' => "metadata.{$key}",
                    'match' => [
                        'any' => $value,
                    ],
                ];
            } else {
                $conditions[] = [
                    'key' => "metadata.{$key}",
                    'match' => [
                        'value' => $value,
                    ],
                ];
            }
        }
        
        return ['must' => $conditions];
    }

    /**
     * Delete documents by filter criteria
     */
    public function deleteDocuments(array $filter): bool
    {
        $qdrantFilter = $this->buildQdrantFilter($filter);
        return $this->vectorStore->deleteDocuments($qdrantFilter);
    }

    /**
     * Get embedding for a text
     */
    public function embedText(string $text): array
    {
        return $this->embedding->embedQuery($text);
    }
}

Copy

Apply

app\Services\RAG\LlphantService.php
namespace App\Services\RAG;

use App\Models\KnowledgeDocument;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class DocumentProcessor
{
    protected $llphantService;

    public function __construct(LlphantService $llphantService)
    {
        $this->llphantService = $llphantService;
    }

    /**
     * Process a document for RAG
     */
    public function processDocument(KnowledgeDocument $document): bool
    {
        try {
            // Update status to processing
            $document->update(['status' => KnowledgeDocument::STATUS_PROCESSING]);
            
            // Get file path
            $filePath = Storage::path($document->file_path);
            
            // Set metadata for document
            $metadata = [
                'document_id' => $document->id,
                'title' => $document->title,
                'source' => $document->original_filename,
                'user_id' => $document->user_id,
            ];
            
            if ($document->team_id) {
                $metadata['team_id'] = $document->team_id;
            }
            
            // Process the document
            $result = $this->llphantService->ingestFile($filePath, $metadata);
            
            // Update document with chunk count
            $document->update([
                'status' => KnowledgeDocument::STATUS_COMPLETED,
                'chunks_count' => $result['chunk_count'],
            ]);
            
            return true;
        } catch (\Exception $e) {
            Log::error('Document processing failed', [
                'document_id' => $document->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            // Update document with error
            $document->update([
                'status' => KnowledgeDocument::STATUS_FAILED,
                'error_message' => $e->getMessage(),
            ]);
            
            return false;
        }
    }
}

Copy

Apply

app\Services\RAG\DocumentProcessor.php
namespace App\Services\LLM;

use EchoLabs\Prism\PrismClient;
use Illuminate\Support\Facades\Http;

class PrismAdapter
{
    protected $client;
    protected $config;
    
    public function __construct()
    {
        $this->client = new PrismClient(
            config('prism.default_model'),
            config('prism.models')
        );
    }
    
    /**
     * Get available models
     */
    public function getAvailableModels(): array
    {
        // Return array of model identifiers
        return array_keys(config('prism.models'));
    }
    
    /**
     * Execute chat completion
     */
    public function chatCompletion(array $messages, string $model = null, float $temperature = 0.7, array $tools = [], bool $stream = false)
    {
        $params = [
            'model' => $model ?? config('prism.default_model'),
            'messages' => $messages,
            'temperature' => $temperature,
        ];
        
        if (!empty($tools)) {
            $params['tools'] = $tools;
            $params['tool_choice'] = 'auto';
        }
        
        if ($stream) {
            $params['stream'] = true;
        }
        
        return $this->client->chat->completions->create($params);
    }
}

Copy

Apply

app\Services\LLM\PrismAdapter.php
namespace App\Services\Workflow;

use App\Models\ExecutionLog;
use App\Models\Workflow;
use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use App\Services\Workflow\NodeTypes\NodeTypeInterface;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;

class WorkflowEngine
{
    protected $nodeRegistry;
    protected $variableResolver;

    public function __construct(
        NodeRegistry $nodeRegistry,
        VariableResolver $variableResolver
    ) {
        $this->nodeRegistry = $nodeRegistry;
        $this->variableResolver = $variableResolver;
    }

    /**
     * Execute a workflow with input data
     */
    public function executeWorkflow(Workflow $workflow, array $inputData, string $triggerType): WorkflowExecution
    {
        // Create execution record
        $execution = WorkflowExecution::create([
            'workflow_id' => $workflow->id,
            'user_id' => $workflow->user_id,
            'trigger_type' => $triggerType,
            'input_data' => $inputData,
            'status' => WorkflowExecution::STATUS_RUNNING,
            'executed_at' => now(),
        ]);
        
        // Store variables for nodes
        $variables = ['input' => $inputData];
        $startTime = microtime(true);
        
        try {
            // Load ordered nodes
            $nodes = $workflow->nodes()->orderBy('sequence')->get();
            
            // Execute each node sequentially
            foreach ($nodes as $node) {
                // Create node log
                $nodeLog = ExecutionLog::create([
                    'execution_id' => $execution->id,
                    'node_id' => $node->id,
                    'node_type' => $node->type,
                    'node_name' => $node->name,
                    'status' => ExecutionLog::STATUS_RUNNING,
                    'started_at' => now(),
                ]);
                
                $nodeStartTime = microtime(true);
                
                try {
                    // Resolve input variables for this node
                    $resolvedInput = $this->variableResolver->resolveNodeInput(
                        $node->config,
                        $node->input_mapping,
                        $variables
                    );
                    
                    // Get node handler
                    $nodeHandler = $this->nodeRegistry->getNodeHandler($node->type);
                    
                    // Execute node
                    $nodeOutput = $nodeHandler->execute($node, $resolvedInput, $execution);
                    
                    // Store output in variables
                    $outputKey = 'node_' . $node->id;
                    $variables[$outputKey] = $nodeOutput;
                    
                    // Map output to named variables if specified
                    if (!empty($node->output_mapping)) {
                        foreach ($node->output_mapping as $path => $varName) {
                            $value = $this->variableResolver->getValueByPath($nodeOutput, $path);
                            if ($value !== null) {
                                $variables[$varName] = $value;
                            }
                        }
                    }
                    
                    // Update node log
                    $nodeLog->update([
                        'status' => ExecutionLog::STATUS_COMPLETED,
                        'input' => $resolvedInput,
                        'output' => $nodeOutput,
                        'completed_at' => now(),
                        'execution_time' => microtime(true) - $nodeStartTime,
                    ]);
                    
                    // If this is a return node, set as workflow output
                    if ($node->type === WorkflowNode::TYPE_RETURN) {
                        $execution->output_data = $nodeOutput;
                    }
                } catch (\Exception $e) {
                    Log::error('Node execution failed', [
                        'node_id' => $node->id,
                        'execution_id' => $execution->id,
                        'error' => $e->getMessage(),
                    ]);
                    
                    // Update node log with error
                    $nodeLog->update([
                        'status' => ExecutionLog::STATUS_FAILED,
                        'input' => $resolvedInput ?? null,
                        'error_message' => $e->getMessage(),
                        'completed_at' => now(),
                        'execution_time' => microtime(true) - $nodeStartTime,
                    ]);
                    
                    // Fail the whole execution
                    throw $e;
                }
            }
            
            // Complete execution
            $execution->update([
                'status' => WorkflowExecution::STATUS_COMPLETED,
                'completed_at' => now(),
                'execution_time' => microtime(true) - $startTime,
            ]);
        } catch (\Exception $e) {
            // Mark execution as failed
            $execution->update([
                'status' => WorkflowExecution::STATUS_FAILED,
                'error_message' => $e->getMessage(),
                'completed_at' => now(),
                'execution_time' => microtime(true) - $startTime,
            ]);
        }
        
        return $execution;
    }
}

Copy

Apply

app\Services\Workflow\WorkflowEngine.php
namespace App\Services\Workflow;

class VariableResolver
{
    /**
     * Resolve variables in node input configuration
     */
    public function resolveNodeInput(array $config, ?array $inputMapping, array $variables): array
    {
        $result = $this->resolveVariablesRecursive($config, $variables);
        
        // Apply explicit input mappings if provided
        if ($inputMapping) {
            foreach ($inputMapping as $configPath => $varPath) {
                $value = $this->getValueByPath($variables, $varPath);
                $result = $this->setValueByPath($result, $configPath, $value);
            }
        }
        
        return $result;
    }
    
    /**
     * Recursively resolve variables in a structure
     */
    protected function resolveVariablesRecursive($data, array $variables)
    {
        if (is_string($data)) {
            return $this->replaceVariableReferences($data, $variables);
        }
        
        if (is_array($data)) {
            $result = [];
            foreach ($data as $key => $value) {
                $result[$key]

Copy

Apply

app\Services\Workflow\VariableResolver.php
please continue with code generation for  app\Services\Workflow\VariableResolver.php and rest of the files as per the attached directory structure...




Context
— none fetched
Let me continue with the VariableResolver class and then move on to other files in the directory structure. I'll focus on implementing the remaining core services and components for the workflow builder and RAG integration.

I need to continue with:

Complete the VariableResolver class
Implement node type classes
Add controllers
Create Filament resources
Implement Vue components for the frontend
Let me start with completing the VariableResolver class.

I'll continue with the VariableResolver implementation and then proceed with the rest of the files in the directory structure:

namespace App\Services\Workflow;

class VariableResolver
{
    /**
     * Resolve variables in node input configuration
     */
    public function resolveNodeInput(array $config, ?array $inputMapping, array $variables): array
    {
        $result = $this->resolveVariablesRecursive($config, $variables);
        
        // Apply explicit input mappings if provided
        if ($inputMapping) {
            foreach ($inputMapping as $configPath => $varPath) {
                $value = $this->getValueByPath($variables, $varPath);
                $result = $this->setValueByPath($result, $configPath, $value);
            }
        }
        
        return $result;
    }
    
    /**
     * Recursively resolve variables in a structure
     */
    protected function resolveVariablesRecursive($data, array $variables)
    {
        if (is_string($data)) {
            return $this->replaceVariableReferences($data, $variables);
        }
        
        if (is_array($data)) {
            $result = [];
            foreach ($data as $key => $value) {
                $result[$key] = $this->resolveVariablesRecursive($value, $variables);
            }
            return $result;
        }
        
        return $data;
    }
    
    /**
     * Replace variable references in a string
     */
    protected function replaceVariableReferences(string $text, array $variables): string
    {
        // Pattern for {{variable.path}}
        $pattern = '/\{\{\s*([a-zA-Z0-9_\.]+)\s*\}\}/';
        
        return preg_replace_callback($pattern, function($matches) use ($variables) {
            $path = $matches[1];
            $value = $this->getValueByPath($variables, $path);
            
            if (is_array($value) || is_object($value)) {
                return json_encode($value);
            }
            
            return $value !== null ? (string)$value : $matches[0];
        }, $text);
    }
    
    /**
     * Get a value from an array by dot notation path
     */
    public function getValueByPath(array $array, string $path)
    {
        $segments = explode('.', $path);
        $current = $array;
        
        foreach ($segments as $segment) {
            if (!is_array($current) || !array_key_exists($segment, $current)) {
                return null;
            }
            $current = $current[$segment];
        }
        
        return $current;
    }
    
    /**
     * Set a value in an array using dot notation path
     */
    public function setValueByPath(array $array, string $path, $value): array
    {
        $segments = explode('.', $path);
        $current = &$array;
        
        foreach ($segments as $segment) {
            if (!isset($current[$segment])) {
                $current[$segment] = [];
            }
            $current = &$current[$segment];
        }
        
        $current = $value;
        
        return $array;
    }
}

Copy

Apply

app\Services\Workflow\VariableResolver.php
namespace App\Services\Workflow;

use App\Models\WorkflowNode;
use App\Services\Workflow\NodeTypes\AgentNode;
use App\Services\Workflow\NodeTypes\ConditionNode;
use App\Services\Workflow\NodeTypes\HttpNode;
use App\Services\Workflow\NodeTypes\NodeTypeInterface;
use App\Services\Workflow\NodeTypes\ReturnNode;
use App\Services\Workflow\NodeTypes\SchedulerNode;
use App\Services\Workflow\NodeTypes\TransformNode;
use App\Services\Workflow\NodeTypes\WebhookNode;
use Illuminate\Support\Facades\App;

class NodeRegistry
{
    /**
     * Get all available node types with metadata
     */
    public function getNodeTypes(): array
    {
        return [
            WorkflowNode::TYPE_WEBHOOK => [
                'name' => 'Webhook',
                'description' => 'Receive data from external webhook',
                'icon' => 'webhook',
                'category' => 'Trigger',
                'isTrigger' => true,
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_WEBHOOK)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_SCHEDULER => [
                'name' => 'Scheduler',
                'description' => 'Run workflow on a schedule',
                'icon' => 'clock',
                'category' => 'Trigger',
                'isTrigger' => true,
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_SCHEDULER)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_HTTP => [
                'name' => 'HTTP Request',
                'description' => 'Make HTTP requests to external APIs',
                'icon' => 'globe',
                'category' => 'Integration',
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_HTTP)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_AGENT => [
                'name' => 'AI Agent',
                'description' => 'Process data with a LaraGent agent',
                'icon' => 'robot',
                'category' => 'AI',
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_AGENT)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_CONDITION => [
                'name' => 'Condition',
                'description' => 'Branch execution based on conditions',
                'icon' => 'branch',
                'category' => 'Logic',
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_CONDITION)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_TRANSFORM => [
                'name' => 'Transform',
                'description' => 'Transform data with JavaScript',
                'icon' => 'transform',
                'category' => 'Logic',
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_TRANSFORM)->getConfigSchema(),
            ],
            WorkflowNode::TYPE_RETURN => [
                'name' => 'Return',
                'description' => 'Return response to caller',
                'icon' => 'reply',
                'category' => 'Output',
                'isOutput' => true,
                'schema' => $this->getNodeHandler(WorkflowNode::TYPE_RETURN)->getConfigSchema(),
            ],
        ];
    }
    
    /**
     * Get node handler for a specific node type
     */
    public function getNodeHandler(string $type): NodeTypeInterface
    {
        $handler = match ($type) {
            WorkflowNode::TYPE_WEBHOOK => App::make(WebhookNode::class),
            WorkflowNode::TYPE_HTTP => App::make(HttpNode::class),
            WorkflowNode::TYPE_AGENT => App::make(AgentNode::class),
            WorkflowNode::TYPE_CONDITION => App::make(ConditionNode::class),
            WorkflowNode::TYPE_TRANSFORM => App::make(TransformNode::class),
            WorkflowNode::TYPE_SCHEDULER => App::make(SchedulerNode::class),
            WorkflowNode::TYPE_RETURN => App::make(ReturnNode::class),
            default => throw new \Exception("Unknown node type: {$type}"),
        };
        
        return $handler;
    }
}

Copy

Apply

app\Services\Workflow\NodeRegistry.php
Now, let's implement one of the node types as an example:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;

interface NodeTypeInterface
{
    /**
     * Execute the node with given input data
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array;
    
    /**
     * Get JSON Schema for node configuration
     */
    public function getConfigSchema(): array;
    
    /**
     * Validate node configuration
     */
    public function validateConfig(array $config): bool;
}

Copy

Apply

app\Services\Workflow\NodeTypes\NodeTypeInterface.php
namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;

class WebhookNode implements NodeTypeInterface
{
    /**
     * Execute the webhook node
     * For webhook, execution is just passing through the received data
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        // Webhook nodes just pass through their input
        return $input;
    }
    
    /**
     * Get JSON Schema for webhook configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'properties' => [
                'description' => [
                    'type' => 'string',
                    'title' => 'Description',
                    'description' => 'Description of the expected webhook payload',
                ],
                'expectedFields' => [
                    'type' => 'array',
                    'title' => 'Expected Fields',
                    'description' => 'Fields expected in the webhook payload',
                    'items' => [
                        'type' => 'object',
                        'properties' => [
                            'name' => [
                                'type' => 'string',
                                'title' => 'Field Name',
                            ],
                            'type' => [
                                'type' => 'string',
                                'title' => 'Field Type',
                                'enum' => ['string', 'number', 'boolean', 'object', 'array'],
                            ],
                            'description' => [
                                'type' => 'string',
                                'title' => 'Description',
                            ],
                            'required' => [
                                'type' => 'boolean',
                                'title' => 'Required',
                                'default' => false,
                            ],
                        ],
                        'required' => ['name', 'type'],
                    ],
                ],
            ],
        ];
    }
    
    /**
     * Validate webhook configuration
     */
    public function validateConfig(array $config): bool
    {
        // Webhook config is always valid
        return true;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\WebhookNode.php
namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use Illuminate\Support\Facades\Http;

class HttpNode implements NodeTypeInterface
{
    /**
     * Execute the HTTP node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // Create request
        $request = Http::withHeaders($config['headers'] ?? []);
        
        // Add basic auth if configured
        if (!empty($config['auth']) && $config['auth']['type'] === 'basic') {
            $request = $request->withBasicAuth(
                $config['auth']['username'] ?? '',
                $config['auth']['password'] ?? ''
            );
        }
        
        // Add bearer token if configured
        if (!empty($config['auth']) && $config['auth']['type'] === 'bearer') {
            $request = $request->withToken($config['auth']['token'] ?? '');
        }
        
        // Prepare body
        $body = $config['body'] ?? null;
        
        // Make request based on method
        $method = strtoupper($config['method'] ?? 'GET');
        $url = $config['url'] ?? '';
        
        $response = match ($method) {
            'GET' => $request->get($url),
            'POST' => $request->post($url, $body),
            'PUT' => $request->put($url, $body),
            'PATCH' => $request->patch($url, $body),
            'DELETE' => $request->delete($url, $body),
            default => throw new \Exception("Unsupported HTTP method: {$method}"),
        };
        
        // Check for error
        if ($response->failed()) {
            throw new \Exception("HTTP request failed: " . $response->status() . " " . $response->body());
        }
        
        // Return response data
        return [
            'status' => $response->status(),
            'headers' => $response->headers(),
            'body' => $response->json() ?? $response->body(),
        ];
    }
    
    /**
     * Get JSON Schema for HTTP configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['url', 'method'],
            'properties' => [
                'url' => [
                    'type' => 'string',
                    'title' => 'URL',
                    'description' => 'URL to send the request to',
                ],
                'method' => [
                    'type' => 'string',
                    'title' => 'Method',
                    'enum' => ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
                    'default' => 'GET',
                ],
                'headers' => [
                    'type' => 'object',
                    'title' => 'Headers',
                    'description' => 'HTTP headers',
                    'additionalProperties' => true,
                ],
                'body' => [
                    'type' => ['object', 'string', 'null'],
                    'title' => 'Request Body',
                    'description' => 'Request body (for POST, PUT, PATCH)',
                ],
                'auth' => [
                    'type' => 'object',
                    'title' => 'Authentication',
                    'properties' => [
                        'type' => [
                            'type' => 'string',
                            'title' => 'Auth Type',
                            'enum' => ['none', 'basic', 'bearer'],
                            'default' => 'none',
                        ],
                        'username' => [
                            'type' => 'string',
                            'title' => 'Username',
                            'description' => 'Basic auth username',
                        ],
                        'password' => [
                            'type' => 'string',
                            'title' => 'Password',
                            'description' => 'Basic auth password',
                        ],
                        'token' => [
                            'type' => 'string',
                            'title' => 'Token',
                            'description' => 'Bearer token',
                        ],
                    ],
                },
            ],
        ];
    }
    
    /**
     * Validate HTTP configuration
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['url'])) {
            return false;
        }
        
        if (empty($config['method']) || !in_array($config['method'], ['GET', 'POST',

Copy

Apply

app\Services\Workflow\NodeTypes\HttpNode.php
please continue with code generation for  app\Services\Workflow\NodeTypes\HttpNode.php and rest of the files as per the attached directory structure...




Context
— none fetched
Let me continue with the HttpNode implementation and then proceed with the other files in the directory structure. I need to complete:

The rest of the HttpNode class
Other NodeTypes (AgentNode, ConditionNode, etc.)
Controllers for the workflow system
Vue components for the workflow builder UI
I'll continue from where I left off with the HttpNode validate method.

I'll continue with the HttpNode implementation and then proceed with the other files in the directory structure:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use Illuminate\Support\Facades\Http;

class HttpNode implements NodeTypeInterface
{
    /**
     * Execute the HTTP node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // Create request
        $request = Http::withHeaders($config['headers'] ?? []);
        
        // Add basic auth if configured
        if (!empty($config['auth']) && $config['auth']['type'] === 'basic') {
            $request = $request->withBasicAuth(
                $config['auth']['username'] ?? '',
                $config['auth']['password'] ?? ''
            );
        }
        
        // Add bearer token if configured
        if (!empty($config['auth']) && $config['auth']['type'] === 'bearer') {
            $request = $request->withToken($config['auth']['token'] ?? '');
        }
        
        // Prepare body
        $body = $config['body'] ?? null;
        
        // Make request based on method
        $method = strtoupper($config['method'] ?? 'GET');
        $url = $config['url'] ?? '';
        
        $response = match ($method) {
            'GET' => $request->get($url),
            'POST' => $request->post($url, $body),
            'PUT' => $request->put($url, $body),
            'PATCH' => $request->patch($url, $body),
            'DELETE' => $request->delete($url, $body),
            default => throw new \Exception("Unsupported HTTP method: {$method}"),
        };
        
        // Check for error
        if ($response->failed()) {
            throw new \Exception("HTTP request failed: " . $response->status() . " " . $response->body());
        }
        
        // Return response data
        return [
            'status' => $response->status(),
            'headers' => $response->headers(),
            'body' => $response->json() ?? $response->body(),
        ];
    }
    
    /**
     * Get JSON Schema for HTTP configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['url', 'method'],
            'properties' => [
                'url' => [
                    'type' => 'string',
                    'title' => 'URL',
                    'description' => 'URL to send the request to',
                ],
                'method' => [
                    'type' => 'string',
                    'title' => 'Method',
                    'enum' => ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
                    'default' => 'GET',
                ],
                'headers' => [
                    'type' => 'object',
                    'title' => 'Headers',
                    'description' => 'HTTP headers',
                    'additionalProperties' => true,
                ],
                'body' => [
                    'type' => ['object', 'string', 'null'],
                    'title' => 'Request Body',
                    'description' => 'Request body (for POST, PUT, PATCH)',
                ],
                'auth' => [
                    'type' => 'object',
                    'title' => 'Authentication',
                    'properties' => [
                        'type' => [
                            'type' => 'string',
                            'title' => 'Auth Type',
                            'enum' => ['none', 'basic', 'bearer'],
                            'default' => 'none',
                        ],
                        'username' => [
                            'type' => 'string',
                            'title' => 'Username',
                            'description' => 'Basic auth username',
                        ],
                        'password' => [
                            'type' => 'string',
                            'title' => 'Password',
                            'description' => 'Basic auth password',
                        ],
                        'token' => [
                            'type' => 'string',
                            'title' => 'Token',
                            'description' => 'Bearer token',
                        ],
                    ],
                },
            ],
        ];
    }
    
    /**
     * Validate HTTP configuration
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['url'])) {
            return false;
        }
        
        if (empty($config['method']) || !in_array($config['method'], ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])) {
            return false;
        }
        
        return true;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\HttpNode.php
Now let's implement the AgentNode for LaraGent integration:

namespace App\Services\Workflow\NodeTypes;

use App\Models\AgentDynamicConfig;
use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use App\Services\Agent\DynamicAgentProxy;
use Illuminate\Support\Facades\Log;

class AgentNode implements NodeTypeInterface
{
    protected $agentProxy;
    
    public function __construct(DynamicAgentProxy $agentProxy)
    {
        $this->agentProxy = $agentProxy;
    }
    
    /**
     * Execute the Agent node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // Get agent configuration
        $agentId = $config['agent_id'] ?? null;
        if (!$agentId) {
            throw new \Exception("Agent ID is not configured");
        }
        
        $agent = AgentDynamicConfig::findOrFail($agentId);
        
        // Prepare messages
        $messages = [];
        
        // Add system message with instructions
        $messages[] = [
            'role' => 'system',
            'content' => $agent->instruction,
        ];
        
        // Add user message
        $messages[] = [
            'role' => 'user',
            'content' => $this->formatUserMessage($config, $input),
        ];
        
        // Execute agent
        $result = $this->agentProxy->executeAgent($agent, $messages);
        
        // Return formatted response
        return [
            'content' => $result['content'] ?? null,
            'tool_calls' => $result['tool_calls'] ?? null,
            'response' => $result,
        ];
    }
    
    /**
     * Format the user message with input data
     */
    protected function formatUserMessage(array $config, array $input): string
    {
        $template = $config['message_template'] ?? "Process the following input:\n\n{{input}}";
        
        // Replace input placeholders with actual values
        return str_replace('{{input}}', json_encode($input, JSON_PRETTY_PRINT), $template);
    }
    
    /**
     * Get JSON Schema for agent configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['agent_id'],
            'properties' => [
                'agent_id' => [
                    'type' => 'integer',
                    'title' => 'Agent',
                    'description' => 'Select the agent to use',
                    'x-control' => 'agent-select',
                ],
                'message_template' => [
                    'type' => 'string',
                    'title' => 'Message Template',
                    'description' => 'Template for the message to send to the agent. Use {{input}} to refer to the input data.',
                    'default' => "Process the following input:\n\n{{input}}",
                    'x-control' => 'textarea',
                ],
            ],
        ];
    }
    
    /**
     * Validate agent configuration
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['agent_id'])) {
            return false;
        }
        
        return true;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\AgentNode.php
Let's implement the ReturnNode:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;

class ReturnNode implements NodeTypeInterface
{
    /**
     * Execute the Return node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // If simple passthrough, just return the input
        if ($config['mode'] === 'passthrough') {
            return $input;
        }
        
        // If template, use the template structure
        if ($config['mode'] === 'template') {
            // Template is already resolved with variables at this point
            return $config['template'] ?? [];
        }
        
        // Default passthrough
        return $input;
    }
    
    /**
     * Get JSON Schema for return node configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'properties' => [
                'mode' => [
                    'type' => 'string',
                    'title' => 'Return Mode',
                    'enum' => ['passthrough', 'template'],
                    'default' => 'passthrough',
                    'description' => 'How to format the return value',
                ],
                'template' => [
                    'type' => 'object',
                    'title' => 'Response Template',
                    'description' => 'Template for the response structure. Use {{variable}} syntax to insert values.',
                    'additionalProperties' => true,
                ],
            ],
        ];
    }
    
    /**
     * Validate return node configuration
     */
    public function validateConfig(array $config): bool
    {
        if (isset($config['mode']) && !in_array($config['mode'], ['passthrough', 'template'])) {
            return false;
        }
        
        if ($config['mode'] === 'template' && !isset($config['template'])) {
            return false;
        }
        
        return true;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\ReturnNode.php
Let's implement the Agent Factory service:

namespace App\Services\Agent;

use App\Models\AgentDynamicConfig;
use App\Services\LLM\PrismAdapter;
use App\Services\RAG\LlphantService;
use Illuminate\Support\Facades\App;
use OpenAI\Client;

class DynamicAgentProxy
{
    protected $openai;
    protected $prism;
    protected $llphantService;
    protected $modelRegistry;
    
    public function __construct(
        Client $openai,
        PrismAdapter $prism,
        LlphantService $llphantService,
        ModelRegistry $modelRegistry
    ) {
        $this->openai = $openai;
        $this->prism = $prism;
        $this->llphantService = $llphantService;
        $this->modelRegistry = $modelRegistry;
    }
    
    /**
     * Execute an agent with the provided messages
     */
    public function executeAgent(AgentDynamicConfig $agent, array $messages, bool $stream = false): array
    {
        // Get the model provider
        $provider = $this->modelRegistry->getProviderForModel($agent->model);
        
        // Prepare request parameters
        $params = [
            'model' => $agent->model,
            'messages' => $messages,
            'temperature' => $agent->temperature,
        ];
        
        // Add tools configuration if present
        $tools = $agent->getToolsConfig();
        if (!empty($tools)) {
            $params['tools'] = $tools;
            $params['tool_choice'] = 'auto';
        }
        
        // Execute based on provider
        if ($provider === 'openai') {
            return $this->executeWithOpenAI($params, $stream);
        } elseif ($provider === 'prism') {
            return $this->executeWithPrism($params, $stream);
        } else {
            throw new \Exception("Unsupported model provider: {$provider}");
        }
    }
    
    /**
     * Execute with OpenAI
     */
    protected function executeWithOpenAI(array $params, bool $stream): array
    {
        if ($stream) {
            return $this->handleStream(
                $this->openai->chat->completions->create($params + ['stream' => true])
            );
        }
        
        $response = $this->openai->chat->completions->create($params);
        return $this->formatResponse($response);
    }
    
    /**
     * Execute with Prism
     */
    protected function executeWithPrism(array $params, bool $stream): array
    {
        if ($stream) {
            return $this->handleStream(
                $this->prism->chatCompletion($params['messages'], $params['model'], $params['temperature'], $params['tools'] ?? [], true)
            );
        }
        
        $response = $this->prism->chatCompletion(
            $params['messages'],
            $params['model'],
            $params['temperature'],
            $params['tools'] ?? []
        );
        
        return $this->formatResponse($response);
    }
    
    /**
     * Format the API response to a standard format
     */
    protected function formatResponse($response): array
    {
        // Get the message from the response
        $message = $response->choices[0]->message;
        
        $result = [
            'content' => $message->content,
            'role' => $message->role,
            'model' => $response->model,
        ];
        
        // Add tool calls if present
        if (isset($message->tool_calls) && !empty($message->tool_calls)) {
            $result['tool_calls'] = $message->tool_calls;
        }
        
        return $result;
    }
    
    /**
     * Handle streaming response
     */
    protected function handleStream($stream): array
    {
        // Placeholder for working with streams in workflow context
        // In a real implementation, this would buffer the stream and return
        // the complete response after the stream ends
        throw new \Exception("Streaming is not supported in workflow nodes");
    }
    
    /**
     * Execute RAG retrieval for an agent
     */
    public function executeRetrieval(string $query, AgentDynamicConfig $agent): array
    {
        // Only proceed if RAG is enabled
        if (!$agent->rag_enabled) {
            return [];
        }
        
        // Create filter for this agent's team/user
        $filter = ['user_id' => $agent->user_id];
        if ($agent->team_id) {
            $filter['team_id'] = $agent->team_id;
        }
        
        // Get document limit from config or use default
        $

Copy

Apply

app\Services\Agent\DynamicAgentProxy.php
please continue with code generation for  app\Services\Agent\DynamicAgentProxy.php and rest of the files as per the attached directory structure...




Context
— none fetched
Let me continue with the DynamicAgentProxy implementation and then move on to completing the remaining files in the structure. I'll need to finish the retrieval method and continue with the other core components.

I need to complete:

Finish DynamicAgentProxy
ModelRegistry implementation
Controller implementations
Filament resources
Vue components
Let me start with completing the DynamicAgentProxy class.

Let me continue with the DynamicAgentProxy implementation and the rest of the files:

namespace App\Services\Agent;

use App\Models\AgentDynamicConfig;
use App\Services\LLM\PrismAdapter;
use App\Services\RAG\LlphantService;
use Illuminate\Support\Facades\App;
use OpenAI\Client;

class DynamicAgentProxy
{
    protected $openai;
    protected $prism;
    protected $llphantService;
    protected $modelRegistry;
    
    public function __construct(
        Client $openai,
        PrismAdapter $prism,
        LlphantService $llphantService,
        ModelRegistry $modelRegistry
    ) {
        $this->openai = $openai;
        $this->prism = $prism;
        $this->llphantService = $llphantService;
        $this->modelRegistry = $modelRegistry;
    }
    
    /**
     * Execute an agent with the provided messages
     */
    public function executeAgent(AgentDynamicConfig $agent, array $messages, bool $stream = false): array
    {
        // Get the model provider
        $provider = $this->modelRegistry->getProviderForModel($agent->model);
        
        // Prepare request parameters
        $params = [
            'model' => $agent->model,
            'messages' => $messages,
            'temperature' => $agent->temperature,
        ];
        
        // Add tools configuration if present
        $tools = $agent->getToolsConfig();
        if (!empty($tools)) {
            $params['tools'] = $tools;
            $params['tool_choice'] = 'auto';
        }
        
        // Execute based on provider
        if ($provider === 'openai') {
            return $this->executeWithOpenAI($params, $stream);
        } elseif ($provider === 'prism') {
            return $this->executeWithPrism($params, $stream);
        } else {
            throw new \Exception("Unsupported model provider: {$provider}");
        }
    }
    
    /**
     * Execute with OpenAI
     */
    protected function executeWithOpenAI(array $params, bool $stream): array
    {
        if ($stream) {
            return $this->handleStream(
                $this->openai->chat->completions->create($params + ['stream' => true])
            );
        }
        
        $response = $this->openai->chat->completions->create($params);
        return $this->formatResponse($response);
    }
    
    /**
     * Execute with Prism
     */
    protected function executeWithPrism(array $params, bool $stream): array
    {
        if ($stream) {
            return $this->handleStream(
                $this->prism->chatCompletion($params['messages'], $params['model'], $params['temperature'], $params['tools'] ?? [], true)
            );
        }
        
        $response = $this->prism->chatCompletion(
            $params['messages'],
            $params['model'],
            $params['temperature'],
            $params['tools'] ?? []
        );
        
        return $this->formatResponse($response);
    }
    
    /**
     * Format the API response to a standard format
     */
    protected function formatResponse($response): array
    {
        // Get the message from the response
        $message = $response->choices[0]->message;
        
        $result = [
            'content' => $message->content,
            'role' => $message->role,
            'model' => $response->model,
        ];
        
        // Add tool calls if present
        if (isset($message->tool_calls) && !empty($message->tool_calls)) {
            $result['tool_calls'] = $message->tool_calls;
        }
        
        return $result;
    }
    
    /**
     * Handle streaming response
     */
    protected function handleStream($stream): array
    {
        // Placeholder for working with streams in workflow context
        // In a real implementation, this would buffer the stream and return
        // the complete response after the stream ends
        throw new \Exception("Streaming is not supported in workflow nodes");
    }
    
    /**
     * Execute RAG retrieval for an agent
     */
    public function executeRetrieval(string $query, AgentDynamicConfig $agent): array
    {
        // Only proceed if RAG is enabled
        if (!$agent->rag_enabled) {
            return [];
        }
        
        // Create filter for this agent's team/user
        $filter = ['user_id' => $agent->user_id];
        if ($agent->team_id) {
            $filter['team_id'] = $agent->team_id;
        }
        
        // Get document limit from config or use default
        $limit = $agent->rag_config['max_documents'] ?? 5;
        
        // Retrieve relevant documents
        $documents = $this->llphantService->retrieveDocuments($query, $limit, $filter);
        
        // Format for context insertion
        $formattedContext = [];
        foreach ($documents as $doc) {
            $formattedContext[] = [
                'content' => $doc->pageContent,
                'source' => $doc->metadata['source'] ?? 'Unknown',
                'title' => $doc->metadata['title'] ?? 'Untitled',
            ];
        }
        
        return $formattedContext;
    }
    
    /**
     * Create a RAG-enhanced message from user query
     */
    public function createRagEnhancedMessage(string $query, array $retrievedDocs): string
    {
        // Create a context string from documents
        $contextText = '';
        foreach ($retrievedDocs as $index => $doc) {
            $contextText .= "DOCUMENT " . ($index + 1) . ":\n";
            $contextText .= "Title: " . $doc['title'] . "\n";
            $contextText .= "Source: " . $doc['source'] . "\n";
            $contextText .= "Content: " . $doc['content'] . "\n\n";
        }
        
        // Return formatted query with context
        if (empty($contextText)) {
            return $query;
        }
        
        return "I need information about the following: $query\n\n" .
               "Here is some context that might be helpful:\n\n" .
               $contextText .
               "Based on the above context, please answer: $query";
    }
}

Copy

Apply

app\Services\Agent\DynamicAgentProxy.php
Now let's implement the ModelRegistry for managing different LLM models:

namespace App\Services\Agent;

class ModelRegistry
{
    /**
     * Get all available models
     */
    public function getAvailableModels(): array
    {
        return array_merge(
            $this->getOpenAIModels(),
            $this->getPrismModels()
        );
    }
    
    /**
     * Get OpenAI models
     */
    public function getOpenAIModels(): array
    {
        return [
            'gpt-4o' => [
                'name' => 'GPT-4o',
                'provider' => 'openai',
                'description' => 'Most capable multimodal model for text and vision tasks',
                'context_window' => 128000,
                'supports_tools' => true,
                'supports_vision' => true,
            ],
            'gpt-4-turbo' => [
                'name' => 'GPT-4 Turbo',
                'provider' => 'openai',
                'description' => 'GPT-4 Turbo with improved capabilities',
                'context_window' => 128000,
                'supports_tools' => true,
                'supports_vision' => false,
            ],
            'gpt-3.5-turbo' => [
                'name' => 'GPT-3.5 Turbo',
                'provider' => 'openai',
                'description' => 'Fast and cost-effective model for most tasks',
                'context_window' => 16385,
                'supports_tools' => true,
                'supports_vision' => false,
            ],
        ];
    }
    
    /**
     * Get Prism models (self-hosted)
     */
    public function getPrismModels(): array
    {
        $models = [];
        
        // Get models from config
        $configuredModels = config('prism.models', []);
        
        foreach ($configuredModels as $modelId => $config) {
            $models[$modelId] = [
                'name' => $config['name'] ?? $modelId,
                'provider' => 'prism',
                'description' => $config['description'] ?? 'Self-hosted model via Prism',
                'context_window' => $config['context_window'] ?? 8192,
                'supports_tools' => $config['supports_tools'] ?? false,
                'supports_vision' => $config['supports_vision'] ?? false,
            ];
        }
        
        return $models;
    }
    
    /**
     * Get the provider for a specific model
     */
    public function getProviderForModel(string $modelId): string
    {
        $allModels = $this->getAvailableModels();
        
        if (isset($allModels[$modelId])) {
            return $allModels[$modelId]['provider'];
        }
        
        // Default to OpenAI if model not found
        return 'openai';
    }
    
    /**
     * Get model details by ID
     */
    public function getModelById(string $modelId): ?array
    {
        $allModels = $this->getAvailableModels();
        
        return $allModels[$modelId] ?? null;
    }
}

Copy

Apply

app\Services\Agent\ModelRegistry.php
Let's implement the ConditionNode for workflow branching:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

class ConditionNode implements NodeTypeInterface
{
    protected $expressionLanguage;
    
    public function __construct()
    {
        $this->expressionLanguage = new ExpressionLanguage();
    }
    
    /**
     * Execute the Condition node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        $conditions = $config['conditions'] ?? [];
        
        // Evaluate each condition
        foreach ($conditions as $condition) {
            if ($this->evaluateCondition($condition['expression'], $input)) {
                // Return with condition result
                return [
                    'result' => true,
                    'path' => $condition['name'],
                    'input' => $input
                ];
            }
        }
        
        // If no conditions match, use default path
        return [
            'result' => false,
            'path' => 'default',
            'input' => $input
        ];
    }
    
    /**
     * Evaluate a condition expression
     */
    protected function evaluateCondition(string $expression, array $input): bool
    {
        try {
            // Convert dot notation to nested access
            $expressionWithVars = preg_replace_callback(
                '/input\.([a-zA-Z0-9_.]+)/',
                function ($matches) {
                    return '$input["' . str_replace('.', '"]["', $matches[1]) . '"]';
                },
                $expression
            );
            
            // Evaluate the expression
            return (bool) $this->expressionLanguage->evaluate($expressionWithVars, ['input' => $input]);
        } catch (\Exception $e) {
            // Log error and return false on failure
            \Log::error('Condition evaluation failed', [
                'expression' => $expression,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * Get JSON Schema for condition configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['conditions'],
            'properties' => [
                'conditions' => [
                    'type' => 'array',
                    'title' => 'Conditions',
                    'description' => 'List of conditions to evaluate',
                    'items' => [
                        'type' => 'object',
                        'required' => ['name', 'expression'],
                        'properties' => [
                            'name' => [
                                'type' => 'string',
                                'title' => 'Path Name',
                                'description' => 'Name for this condition path',
                            ],
                            'expression' => [
                                'type' => 'string',
                                'title' => 'Condition Expression',
                                'description' => 'Expression to evaluate. Use input.field to access input values.',
                                'examples' => ['input.status == "success"', 'input.count > 10'],
                            ],
                        ],
                    ],
                ],
                'default_path' => [
                    'type' => 'string',
                    'title' => 'Default Path',
                    'description' => 'Path to follow if no conditions match',
                    'default' => 'default',
                ],
            ],
        ];
    }
    
    /**
     * Validate condition configuration
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['conditions']) || !is_array($config['conditions'])) {
            return false;
        }
        
        foreach ($config['conditions'] as $condition) {
            if (empty($condition['name']) || empty($condition['expression'])) {
                return false;
            }
        }
        
        return true;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\ConditionNode.php
Now let's implement the TransformNode for data transformation:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use V8Js;

class TransformNode implements NodeTypeInterface
{
    /**
     * Execute the Transform node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        $script = $config['script'] ?? '';
        
        if (empty($script)) {
            return $input;
        }
        
        // Execute JavaScript transformation
        try {
            // Prepare input data as JSON
            $inputJson = json_encode($input);
            
            // Build full script with input data
            $fullScript = "const input = {$inputJson};\n" .
                          "let output = input;\n" .
                          "{$script}\n" .
                          "JSON.stringify(output);";
            
            // Execute with V8Js
            $v8 = new V8Js();
            $result = $v8->executeString($fullScript);
            
            // Parse result
            return json_decode($result, true) ?? $input;
        } catch (\Exception $e) {
            throw new \Exception("Transform script execution

Copy

Apply

app\Services\Workflow\NodeTypes\TransformNode.php
app\Services\Workflow\NodeTypes\TransformNode.php please continue with code generation for  this and rest of the files as per the attached directory structure...




Context
— none fetched
Let me continue with the TransformNode class implementation and then proceed with the rest of the files according to the provided directory structure. I need to complete:

Finish the TransformNode class
Implement other node types (SchedulerNode)
Implement workflow controllers
Model classes
Vue components for the workflow builder
I'll focus on completing each file in turn.

Let me continue with the TransformNode implementation and then proceed with the remaining files:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use V8Js;

class TransformNode implements NodeTypeInterface
{
    /**
     * Execute the Transform node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        $script = $config['script'] ?? '';
        
        if (empty($script)) {
            return $input;
        }
        
        // Execute JavaScript transformation
        try {
            // Prepare input data as JSON
            $inputJson = json_encode($input);
            
            // Build full script with input data
            $fullScript = "const input = {$inputJson};\n" .
                          "let output = input;\n" .
                          "{$script}\n" .
                          "JSON.stringify(output);";
            
            // Execute with V8Js
            $v8 = new V8Js();
            $result = $v8->executeString($fullScript);
            
            // Parse result
            return json_decode($result, true) ?? $input;
        } catch (\Exception $e) {
            throw new \Exception("Transform script execution failed: " . $e->getMessage());
        }
    }
    
    /**
     * Get JSON Schema for transform configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['script'],
            'properties' => [
                'script' => [
                    'type' => 'string',
                    'title' => 'Transform Script',
                    'description' => 'JavaScript code to transform the input. The input is available as "input" variable, and the result should be assigned to "output".',
                    'x-control' => 'code-editor',
                    'x-language' => 'javascript',
                ],
            ],
        ];
    }
    
    /**
     * Validate transform configuration
     */
    public function validateConfig(array $config): bool
    {
        return isset($config['script']) && is_string($config['script']);
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\TransformNode.php
Let's implement the SchedulerNode for scheduled workflows:

namespace App\Services\Workflow\NodeTypes;

use App\Jobs\ScheduledWorkflow;
use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use Carbon\Carbon;

class SchedulerNode implements NodeTypeInterface
{
    /**
     * Execute the Scheduler node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // Check if this is a scheduled execution or just configuration
        $scheduledRun = $input['_scheduled'] ?? false;
        
        if ($scheduledRun) {
            // If this is a scheduled run, just pass through input
            return $input;
        } else {
            // This is just configuring the schedule, return schedule info
            $schedule = $this->getScheduleInfo($config);
            
            // Schedule the job based on the configuration
            $this->scheduleWorkflow($node, $config);
            
            return [
                'scheduled' => true,
                'schedule_type' => $config['schedule_type'],
                'next_run' => $schedule['next_run'],
                'description' => $schedule['description'],
            ];
        }
    }
    
    /**
     * Schedule the workflow to run
     */
    protected function scheduleWorkflow(WorkflowNode $node, array $config): void
    {
        $workflow = $node->workflow;
        
        // Only schedule if the workflow is active
        if (!$workflow->is_active) {
            return;
        }
        
        $schedule = $this->getScheduleInfo($config);
        
        // Dispatch the job with appropriate delay
        ScheduledWorkflow::dispatch($workflow, $node->id)
            ->delay($schedule['next_run']);
    }
    
    /**
     * Get schedule information based on configuration
     */
    protected function getScheduleInfo(array $config): array
    {
        $now = Carbon::now();
        $scheduleType = $config['schedule_type'] ?? 'none';
        
        switch ($scheduleType) {
            case 'interval':
                $interval = $config['interval'] ?? 60;
                $unit = $config['interval_unit'] ?? 'minutes';
                $nextRun = $now->copy()->add($interval, $unit);
                return [
                    'next_run' => $nextRun,
                    'description' => "Every {$interval} {$unit}",
                ];
                
            case 'daily':
                $time = $config['time'] ?? '00:00';
                list($hour, $minute) = explode(':', $time);
                $nextRun = $now->copy()->startOfDay()->addHours($hour)->addMinutes($minute);
                if ($nextRun->isPast()) {
                    $nextRun->addDay();
                }
                return [
                    'next_run' => $nextRun,
                    'description' => "Daily at {$time}",
                ];
                
            case 'weekly':
                $day = $config['day'] ?? 1; // Monday = 1, Sunday = 7
                $time = $config['time'] ?? '00:00';
                list($hour, $minute) = explode(':', $time);
                $nextRun = $now->copy()->startOfWeek()->addDays($day - 1)->addHours($hour)->addMinutes($minute);
                if ($nextRun->isPast()) {
                    $nextRun->addWeek();
                }
                $dayName = $nextRun->format('l');
                return [
                    'next_run' => $nextRun,
                    'description' => "Weekly on {$dayName} at {$time}",
                ];
                
            case 'monthly':
                $day = $config['day'] ?? 1;
                $time = $config['time'] ?? '00:00';
                list($hour, $minute) = explode(':', $time);
                $nextRun = $now->copy()->startOfMonth()->addDays($day - 1)->addHours($hour)->addMinutes($minute);
                if ($nextRun->isPast()) {
                    $nextRun->addMonth();
                }
                return [
                    'next_run' => $nextRun,
                    'description' => "Monthly on day {$day} at {$time}",
                ];
                
            case 'cron':
                $expression = $config['cron_expression'] ?? '* * * * *';
                $nextRun = Carbon::instance(\Cron\CronExpression::factory($expression)->getNextRunDate());
                return [
                    'next_run' => $nextRun,
                    'description' => "Cron: {$expression}",
                ];
                
            default:
                return [
                    'next_run' => null,
                    'description' => 'Not scheduled',
                ];
        }
    }
    
    /**
     * Get JSON Schema for scheduler configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'required' => ['schedule_type'],
            'properties' => [
                'schedule_type' => [
                    'type' => 'string',
                    'title' => 'Schedule Type',
                    'enum' => ['none', 'interval', 'daily', 'weekly', 'monthly', 'cron'],
                    'default' => 'none',
                ],
                'interval' => [
                    'type' => 'integer',
                    'title' => 'Interval',
                    'minimum' => 1,
                    'default' => 60,
                ],
                'interval_unit' => [
                    'type' => 'string',
                    'title' => 'Interval Unit',
                    'enum' => ['minutes', 'hours', 'days'],
                    'default' => 'minutes',
                ],
                'time' => [
                    'type' => 'string',
                    'title' => 'Time',
                    'format' => 'time',
                    'default' => '00:00',
                ],
                'day' => [
                    'type' => 'integer',
                    'title' => 'Day',
                    'minimum' => 1,
                    'maximum' => 31,
                    'default' => 1,
                ],
                'cron_expression' => [
                    'type' => 'string',
                    'title' => 'Cron Expression',
                    'pattern': '^(\\*|\\d+)(\\s+(\\*|\\d+)){4}$',
                    'default' => '* * * * *',
                ],
                'input_data' => [
                    'type' => 'object',
                    'title' => 'Input Data',
                    'description' => 'Data to pass to the workflow when triggered',
                    'additionalProperties' => true,
                ],
            ],
        ];
    }
    
    /**
     * Validate scheduler configuration
     */
    public function validateConfig(array $config): bool
    {
        if (empty($config['schedule_type']) || !in_array($config['schedule_type'], ['none', 'interval', 'daily', 'weekly', 'monthly', 'cron'])) {
            return false;
        }
        
        // Validate based on schedule type
        switch ($config['schedule_type']) {
            case 'interval':
                return isset($config['interval']) && is_numeric($config['interval']) && $config['interval'] > 0;
                
            case 'cron':
                return isset($config['cron_expression']) && $this->isValidCronExpression($config['cron_expression']);
                
            default:
                return true;
        }
    }
    
    /**
     * Validate a cron expression
     */
    protected function isValidCronExpression(string $expression): bool
    {
        try {
            \Cron\CronExpression::factory($expression);
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\SchedulerNode.php
Now let's implement the WorkflowController for managing workflows:

namespace App\Http\Controllers;

use App\Http\Requests\StoreWorkflowRequest;
use App\Models\Workflow;
use App\Models\WorkflowNode;
use App\Services\Workflow\NodeRegistry;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;

class WorkflowController extends Controller
{
    protected $nodeRegistry;
    
    public function __construct(NodeRegistry $nodeRegistry)
    {
        $this->nodeRegistry = $nodeRegistry;
    }
    
    /**
     * Display a listing of workflows
     */
    public function index()
    {
        $workflows = Workflow::where('user_id', Auth::id())
            ->withCount('nodes')
            ->withCount('executions')
            ->orderBy('updated_at', 'desc')
            ->paginate(10);
        
        return Inertia::render('Workflows/Index', [
            'workflows' => $workflows,
        ]);
    }
    
    /**
     * Show the form for creating a new workflow
     */
    public function create()
    {
        return Inertia::render('Workflows/Create');
    }
    
    /**
     * Store a newly created workflow
     */
    public function store(StoreWorkflowRequest $request)
    {
        $workflow = Workflow::create([
            'name' => $request->name,
            'description' => $request->description,
            'is_active' => $request->is_active ?? false,
            'user_id' => Auth::id(),
        ]);
        
        return redirect()->route('workflows.edit', $workflow)
            ->with('success', 'Workflow created successfully');
    }
    
    /**
     * Show the workflow builder view
     */
    public function edit(Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        // Load workflow with nodes
        $workflow->load('nodes');
        
        // Get all available node types
        $nodeTypes = $this->nodeRegistry->getNodeTypes();
        
        return Inertia::render('Workflows/Builder', [
            'workflow' => $workflow,
            'nodeTypes' => $nodeTypes,
        ]);
    }
    
    /**
     * Update the workflow
     */
    public function update(StoreWorkflowRequest $request, Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        $workflow->update([
            'name' => $request->name,
            'description' => $request->description,
            'is_active' => $request->is_active ?? false,
        ]);
        
        return redirect()->route('workflows.index')
            ->with('success', 'Workflow updated successfully');
    }
    
    /**
     * Save workflow nodes
     */
    public function saveNodes(Request $request, Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        // Validate request
        $request->validate([
            'nodes' => 'required|array',
            'nodes.*.id' => 'nullable|integer',
            'nodes.*.type' => 'required|string',
            'nodes.*.name' => 'required|string',
            'nodes.*.config' => 'required|array',
            'nodes.*.position' => 'required|array',
            'nodes.*.sequence' => 'required|integer',
        ]);
        
        // Begin transaction
        DB::beginTransaction();
        
        try {
            // Get existing node IDs
            $existingNodeIds = $workflow->nodes()->pluck('id')->toArray();
            $updatedNodeIds = [];
            
            // Update or create nodes
            foreach ($request->nodes as $nodeData) {
                $nodeId = $nodeData['id'] ?? null;
                
                $node = $nodeId 
                    ? $workflow->nodes()->findOrFail($nodeId)
                    : new WorkflowNode();
                
                $node->fill([
                    'workflow_id' => $workflow->id,
                    'type' => $nodeData['type'],
                    'name' => $nodeData['name'],
                    'config' => $nodeData['config'],
                    'position' => $nodeData['position'],
                    'sequence' => $nodeData['sequence'],
                    'input_mapping' => $nodeData['input_mapping'] ?? null,
                    'output_mapping' => $nodeData['output_mapping'] ?? null,
                ]);
                
                $node->save();
                $updatedNodeIds[] = $node->id;
            }
            
            // Delete removed nodes
            $nodesToDelete = array_diff($exist

Copy

Apply

app\Http\Controllers\WorkflowController.php
│   │   │   │   └── ReturnNode.php

│   │   │   ├── NodeRegistry.php             # Available node types

│   │   │   ├── WorkflowEngine.php           # Execution engine

│   │   │   └── VariableResolver.php         # Handles variable references

│   │   ├── Agent/

│   │   │   ├── AgentFactory.php             # Dynamic agent creation

│   │   │   ├── DynamicAgentProxy.php        # Agent proxy

│   │   │   └── ModelRegistry.php            # Available models

│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration please continue with code generation for ReturnNode.php and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
You're asking me to continue with code generation for WorkflowController and other files in the directory structure. Let me continue with WorkflowController and then implement the remaining key files:

Complete WorkflowController
Implement WorkflowEngine
Implement LLM adapters (PrismAdapter and OpenAIAdapter)
Implement AgentFactory
Implement RAG-related services
I'll continue from where I left off with the WorkflowController and then proceed with other files.

Let me continue with the WorkflowController and implement the remaining files according to the directory structure:

namespace App\Http\Controllers;

use App\Http\Requests\StoreWorkflowRequest;
use App\Models\Workflow;
use App\Models\WorkflowNode;
use App\Services\Workflow\NodeRegistry;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;

class WorkflowController extends Controller
{
    protected $nodeRegistry;
    
    public function __construct(NodeRegistry $nodeRegistry)
    {
        $this->nodeRegistry = $nodeRegistry;
    }
    
    /**
     * Display a listing of workflows
     */
    public function index()
    {
        $workflows = Workflow::where('user_id', Auth::id())
            ->withCount('nodes')
            ->withCount('executions')
            ->orderBy('updated_at', 'desc')
            ->paginate(10);
        
        return Inertia::render('Workflows/Index', [
            'workflows' => $workflows,
        ]);
    }
    
    /**
     * Show the form for creating a new workflow
     */
    public function create()
    {
        return Inertia::render('Workflows/Create');
    }
    
    /**
     * Store a newly created workflow
     */
    public function store(StoreWorkflowRequest $request)
    {
        $workflow = Workflow::create([
            'name' => $request->name,
            'description' => $request->description,
            'is_active' => $request->is_active ?? false,
            'user_id' => Auth::id(),
        ]);
        
        return redirect()->route('workflows.edit', $workflow)
            ->with('success', 'Workflow created successfully');
    }
    
    /**
     * Show the workflow builder view
     */
    public function edit(Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        // Load workflow with nodes
        $workflow->load('nodes');
        
        // Get all available node types
        $nodeTypes = $this->nodeRegistry->getNodeTypes();
        
        return Inertia::render('Workflows/Builder', [
            'workflow' => $workflow,
            'nodeTypes' => $nodeTypes,
        ]);
    }
    
    /**
     * Update the workflow
     */
    public function update(StoreWorkflowRequest $request, Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        $workflow->update([
            'name' => $request->name,
            'description' => $request->description,
            'is_active' => $request->is_active ?? false,
        ]);
        
        return redirect()->route('workflows.index')
            ->with('success', 'Workflow updated successfully');
    }
    
    /**
     * Save workflow nodes
     */
    public function saveNodes(Request $request, Workflow $workflow)
    {
        // Authorization check
        $this->authorize('update', $workflow);
        
        // Validate request
        $request->validate([
            'nodes' => 'required|array',
            'nodes.*.id' => 'nullable|integer',
            'nodes.*.type' => 'required|string',
            'nodes.*.name' => 'required|string',
            'nodes.*.config' => 'required|array',
            'nodes.*.position' => 'required|array',
            'nodes.*.sequence' => 'required|integer',
        ]);
        
        // Begin transaction
        DB::beginTransaction();
        
        try {
            // Get existing node IDs
            $existingNodeIds = $workflow->nodes()->pluck('id')->toArray();
            $updatedNodeIds = [];
            
            // Update or create nodes
            foreach ($request->nodes as $nodeData) {
                $nodeId = $nodeData['id'] ?? null;
                
                $node = $nodeId 
                    ? $workflow->nodes()->findOrFail($nodeId)
                    : new WorkflowNode();
                
                $node->fill([
                    'workflow_id' => $workflow->id,
                    'type' => $nodeData['type'],
                    'name' => $nodeData['name'],
                    'config' => $nodeData['config'],
                    'position' => $nodeData['position'],
                    'sequence' => $nodeData['sequence'],
                    'input_mapping' => $nodeData['input_mapping'] ?? null,
                    'output_mapping' => $nodeData['output_mapping'] ?? null,
                ]);
                
                $node->save();
                $updatedNodeIds[] = $node->id;
            }
            
            // Delete removed nodes
            $nodesToDelete = array_diff($existingNodeIds, $updatedNodeIds);
            
            if (!empty($nodesToDelete)) {
                $workflow->nodes()->whereIn('id', $nodesToDelete)->delete();
            }
            
            // Save connections
            if ($request->has('connections')) {
                // Clear existing connections
                foreach ($workflow->nodes as $node) {
                    $node->next_node_id = null;
                    $node->save();
                }
                
                // Create new connections
                foreach ($request->connections as $connection) {
                    $sourceNode = $workflow->nodes()->where('id', $connection['source'])->first();
                    
                    if ($sourceNode) {
                        $sourceNode->next_node_id = $connection['target'];
                        $sourceNode->save();
                    }
                }
            }
            
            DB::commit();
            
            return response()->json(['success' => true]);
        } catch (\Exception $e) {
            DB::rollBack();
            
            return response()->json([
                'success' => false,
                'message' => 'Failed to save workflow: ' . $e->getMessage(),
            ], 500);
        }
    }
    
    /**
     * Delete the workflow
     */
    public function destroy(Workflow $workflow)
    {
        // Authorization check
        $this->authorize('delete', $workflow);
        
        // Delete the workflow (cascades to nodes and executions)
        $workflow->delete();
        
        return redirect()->route('workflows.index')
            ->with('success', 'Workflow deleted successfully');
    }
    
    /**
     * Show workflow execution history
     */
    public function executions(Workflow $workflow)
    {
        // Authorization check
        $this->authorize('view', $workflow);
        
        // Load recent executions
        $executions = $workflow->executions()
            ->orderBy('created_at', 'desc')
            ->paginate(10);
        
        return Inertia::render('Workflows/Execution', [
            'workflow' => $workflow,
            'executions' => $executions,
        ]);
    }
}

Copy

Apply

app\Http\Controllers\WorkflowController.php
Now let's implement the WorkflowEngine class:

namespace App\Services\Workflow;

use App\Models\ExecutionLog;
use App\Models\Workflow;
use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;
use Illuminate\Support\Facades\Log;

class WorkflowEngine
{
    protected $nodeRegistry;
    protected $variableResolver;
    
    public function __construct(
        NodeRegistry $nodeRegistry,
        VariableResolver $variableResolver
    ) {
        $this->nodeRegistry = $nodeRegistry;
        $this->variableResolver = $variableResolver;
    }
    
    /**
     * Execute a workflow with the given input
     */
    public function executeWorkflow(Workflow $workflow, array $input = [], ?int $startNodeId = null): WorkflowExecution
    {
        // Create workflow execution record
        $execution = WorkflowExecution::create([
            'workflow_id' => $workflow->id,
            'status' => WorkflowExecution::STATUS_RUNNING,
            'input' => $input,
            'output' => null,
        ]);
        
        try {
            // Find start node
            $startNode = $startNodeId 
                ? $workflow->nodes()->findOrFail($startNodeId)
                : $workflow->nodes()->orderBy('sequence')->first();
            
            if (!$startNode) {
                throw new \Exception("No nodes found in this workflow");
            }
            
            // Execute from start node
            $result = $this->executeNode($startNode, $input, $execution);
            
            // Mark execution as completed
            $execution->update([
                'status' => WorkflowExecution::STATUS_COMPLETED,
                'output' => $result,
                'completed_at' => now(),
            ]);
            
            return $execution;
        } catch (\Exception $e) {
            // Log error
            Log::error('Workflow execution failed', [
                'workflow_id' => $workflow->id,
                'execution_id' => $execution->id,
                'error' => $e->getMessage(),
            ]);
            
            // Update execution status
            $execution->update([
                'status' => WorkflowExecution::STATUS_FAILED,
                'error' => $e->getMessage(),
                'completed_at' => now(),
            ]);
            
            // Re-throw or return execution
            return $execution;
        }
    }
    
    /**
     * Execute a single node and follow through the workflow
     */
    protected function executeNode(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        // Log node execution start
        $this->logExecution($execution, $node, 'started', [
            'input' => $input,
        ]);
        
        try {
            // Get node handler
            $handler = $this->nodeRegistry->getNodeHandler($node->type);
            
            // Resolve variables in configuration
            $resolvedConfig = $this->variableResolver->resolveNodeInput(
                $node->config, 
                $node->input_mapping, 
                $input
            );
            
            // Update node config with resolved values
            $node->config = $resolvedConfig;
            
            // Execute node
            $result = $handler->execute($node, $input, $execution);
            
            // Log node execution success
            $this->logExecution($execution, $node, 'completed', [
                'output' => $result,
            ]);
            
            // Handle condition node branches
            if ($node->type === WorkflowNode::TYPE_CONDITION) {
                $path = $result['path'] ?? 'default';
                
                // Find the next node by path
                $nextNode = $this->findNextNodeByPath($node, $path);
                
                if ($nextNode) {
                    // Pass through the original input with condition results
                    return $this->executeNode($nextNode, $result['input'], $execution);
                }
                
                // If no next node, return the result
                return $result;
            }
            
            // Check if there's a next node
            if ($node->next_node_id) {
                $nextNode = WorkflowNode::find($node->next_node_id);
                
                if ($nextNode) {
                    // Apply output mapping if defined
                    if ($node->output_mapping) {
                        $mappedResult = [];
                        
                        foreach ($node->output_mapping as $source => $target) {
                            $value = $this->variableResolver->getValueByPath($result, $source);
                            $mappedResult = $this->variableResolver->setValueByPath($mappedResult, $target, $value);
                        }
                        
                        // Merge with input for context preservation
                        $nextInput = array_merge($input, $mappedResult);
                    } else {
                        // Default behavior: merge node result with input
                        $nextInput = array_merge($input, ['previous' => $result]);
                    }
                    
                    // Execute next node
                    return $this->executeNode($nextNode, $nextInput, $execution);
                }
            }
            
            // Return final result if no next node
            return $result;
        } catch (\Exception $e) {
            // Log node execution error
            $this->logExecution($execution, $node, 'failed', [
                'error' => $e->getMessage(),
            ]);
            
            // Re-throw the exception
            throw $e;
        }
    }
    
    /**
     * Find the next node based on a condition path
     */
    protected function findNextNodeByPath(WorkflowNode $conditionNode, string $path): ?WorkflowNode
    {
        // Get all nodes in the workflow
        $nodes = $conditionNode->workflow->nodes;
        
        // Find connections with path information
        foreach ($nodes as $node) {
            if ($node->previous_node_id === $conditionNode->id && isset($node->metadata['path']) && $node->metadata['path'] === $path) {
                return $node;
            }
        }
        
        // If no specific path node found, use the standard next_node_id
        if ($conditionNode->next_node_id) {
            return WorkflowNode::find($conditionNode->next_node_id);
        }
        
        return null;
    }
    
    /**
     * Log node execution
     */
    protected function logExecution(WorkflowExecution $execution, WorkflowNode $node, string $status, array $data = []): void
    {
        ExecutionLog::create([
            'execution_id' => $execution->id,
            'node_id' => $node->id,
            'node_type' => $node->type,
            'node_name' => $node->name,
            'status' => $status,
            'data' => $data,
        ]);
    }
}

Copy

Apply

app\Services\Workflow\WorkflowEngine.php
Now let's implement the PrismAdapter for LLM integration:

namespace App\Services\LLM;

use EchoLabs\Prism\Facades\PrismServer;
use Illuminate\Support\Facades\Log;

class PrismAdapter
{
    /**
     * Send a chat completion request to Prism
     */
    public function chatCompletion(array $messages, string $model, float $temperature = 0.7, array $tools = [], bool $stream = false)
    {
        try {
            $params = [
                'model' => $model,
                'messages' => $messages,
                'temperature' => $temperature,
            ];
            
            // Add tools if provided
            if (!empty($tools)) {
                $params['tools'] = $tools;
                $params['tool_choice'] = 'auto';
            }
            
            // Handle streaming
            if ($stream) {
                return PrismServer::chatCompletions()->create($params + ['stream' => true]);
            }
            
            // Regular request
            return PrismServer::chatCompletions()->create($params);
        } catch (\Exception $e) {
            Log::error('Prism API error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     *

Copy

Apply

app\Services\LLM\PrismAdapter.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  PrismAdapter.php and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 15 new items
1 item were retrieved but not used because they exceed the token limit. Learn more about token limits here.
Let me continue with the PrismAdapter and OpenAIAdapter implementations, then move on to the RAG-related services and other components in the directory structure. I'll focus on:

Complete PrismAdapter.php (which was cut off)
Implement OpenAIAdapter.php
Implement RAG services (LlphantService.php, DocumentProcessor.php, etc.)
Implement key Filament resources
Implement Jobs classes
I'll structure these implementations to be cohesive with the parts I've already provided.

Let me continue completing the remaining files according to the directory structure:

namespace App\Services\LLM;

use EchoLabs\Prism\Facades\PrismServer;
use Illuminate\Support\Facades\Log;

class PrismAdapter
{
    /**
     * Send a chat completion request to Prism
     */
    public function chatCompletion(array $messages, string $model, float $temperature = 0.7, array $tools = [], bool $stream = false)
    {
        try {
            $params = [
                'model' => $model,
                'messages' => $messages,
                'temperature' => $temperature,
            ];
            
            // Add tools if provided
            if (!empty($tools)) {
                $params['tools'] = $tools;
                $params['tool_choice'] = 'auto';
            }
            
            // Handle streaming
            if ($stream) {
                return PrismServer::chatCompletions()->create($params + ['stream' => true]);
            }
            
            // Regular request
            return PrismServer::chatCompletions()->create($params);
        } catch (\Exception $e) {
            Log::error('Prism API error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Generate embeddings via Prism
     */
    public function generateEmbeddings(string $text, string $model = 'text-embedding-ada-002'): array
    {
        try {
            $response = PrismServer::embeddings()->create([
                'model' => $model,
                'input' => $text,
            ]);
            
            return $response->data[0]->embedding;
        } catch (\Exception $e) {
            Log::error('Prism embeddings error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Check if a model is available in Prism
     */
    public function isModelAvailable(string $model): bool
    {
        try {
            $models = PrismServer::models()->list();
            
            foreach ($models->data as $availableModel) {
                if ($availableModel->id === $model) {
                    return true;
                }
            }
            
            return false;
        } catch (\Exception $e) {
            Log::warning('Failed to check model availability in Prism', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            return false;
        }
    }
}

Copy

Apply

app\Services\LLM\PrismAdapter.php
Now let's implement the OpenAIAdapter:

namespace App\Services\LLM;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use OpenAI\Client;

class OpenAIAdapter
{
    protected $client;
    
    public function __construct(Client $client)
    {
        $this->client = $client;
    }
    
    /**
     * Send a chat completion request to OpenAI
     */
    public function chatCompletion(array $messages, string $model = 'gpt-4o', float $temperature = 0.7, array $tools = [], bool $stream = false)
    {
        try {
            $params = [
                'model' => $model,
                'messages' => $messages,
                'temperature' => $temperature,
            ];
            
            // Add tools if provided
            if (!empty($tools)) {
                $params['tools'] = $tools;
                $params['tool_choice'] = 'auto';
            }
            
            // Handle streaming
            if ($stream) {
                return $this->client->chat->completions->create($params + ['stream' => true]);
            }
            
            // Regular request
            return $this->client->chat->completions->create($params);
        } catch (\Exception $e) {
            Log::error('OpenAI API error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Generate embeddings via OpenAI
     */
    public function generateEmbeddings(string $text, string $model = 'text-embedding-3-small'): array
    {
        try {
            $response = $this->client->embeddings->create([
                'model' => $model,
                'input' => $text,
            ]);
            
            return $response->data[0]->embedding;
        } catch (\Exception $e) {
            Log::error('OpenAI embeddings error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Call vision model for image analysis
     */
    public function analyzeImage(string $imageUrl, string $prompt, string $model = 'gpt-4o'): string
    {
        try {
            $response = $this->client->chat->completions->create([
                'model' => $model,
                'messages' => [
                    [
                        'role' => 'user',
                        'content' => [
                            [
                                'type' => 'text',
                                'text' => $prompt,
                            ],
                            [
                                'type' => 'image_url',
                                'image_url' => [
                                    'url' => $imageUrl,
                                ],
                            ],
                        ],
                    ],
                ],
                'temperature' => 0.7,
            ]);
            
            return $response->choices[0]->message->content;
        } catch (\Exception $e) {
            Log::error('OpenAI vision API error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Execute tool calls via function calling
     */
    public function executeToolCalls(array $tools, array $toolResults, array $messages, string $model = 'gpt-4o'): array
    {
        try {
            // Prepare tool calls with results
            $toolCallMessages = [];
            
            foreach ($toolResults as $toolId => $result) {
                $toolCallMessages[] = [
                    'role' => 'tool',
                    'tool_call_id' => $toolId,
                    'content' => is_string($result) ? $result : json_encode($result),
                ];
            }
            
            // Add tool messages to conversation
            $allMessages = array_merge($messages, $toolCallMessages);
            
            // Get final response
            $response = $this->client->chat->completions->create([
                'model' => $model,
                'messages' => $allMessages,
                'tools' => $tools,
                'temperature' => 0.7,
            ]);
            
            return [
                'content' => $response->choices[0]->message->content,
                'role' => $response->choices[0]->message->role,
                'model' => $response->model,
                'tool_calls' => $response->choices[0]->message->tool_calls ?? null,
            ];
        } catch (\Exception $e) {
            Log::error('OpenAI tool calls error', [
                'error' => $e->getMessage(),
                'model' => $model,
            ]);
            
            throw $e;
        }
    }
}

Copy

Apply

app\Services\LLM\OpenAIAdapter.php
Now let's implement the NodeRegistry for managing workflow node types:

namespace App\Services\Workflow;

use App\Models\WorkflowNode;
use App\Services\Workflow\NodeTypes\AgentNode;
use App\Services\Workflow\NodeTypes\ConditionNode;
use App\Services\Workflow\NodeTypes\HttpNode;
use App\Services\Workflow\NodeTypes\NodeTypeInterface;
use App\Services\Workflow\NodeTypes\ReturnNode;
use App\Services\Workflow\NodeTypes\SchedulerNode;
use App\Services\Workflow\NodeTypes\TransformNode;
use App\Services\Workflow\NodeTypes\WebhookNode;
use Illuminate\Support\Facades\App;

class NodeRegistry
{
    protected array $nodeTypes = [];
    
    /**
     * Register the default node types
     */
    public function __construct()
    {
        $this->registerCoreNodeTypes();
    }
    
    /**
     * Register the core node types
     */
    protected function registerCoreNodeTypes(): void
    {
        $this->registerNodeType(WorkflowNode::TYPE_WEBHOOK, WebhookNode::class, [
            'name' => 'Webhook',
            'description' => 'Receive data from external systems',
            'category' => 'Trigger',
            'icon' => 'globe',
            'color' => 'blue',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_HTTP, HttpNode::class, [
            'name' => 'HTTP Request',
            'description' => 'Make HTTP requests to external APIs',
            'category' => 'Integration',
            'icon' => 'arrow-up-right',
            'color' => 'green',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_AGENT, AgentNode::class, [
            'name' => 'AI Agent',
            'description' => 'Process inputs using AI agents',
            'category' => 'AI',
            'icon' => 'robot',
            'color' => 'purple',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_CONDITION, ConditionNode::class, [
            'name' => 'Condition',
            'description' => 'Branch workflow based on conditions',
            'category' => 'Logic',
            'icon' => 'git-branch',
            'color' => 'orange',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_TRANSFORM, TransformNode::class, [
            'name' => 'Transform',
            'description' => 'Transform data with JavaScript',
            'category' => 'Processing',
            'icon' => 'code',
            'color' => 'indigo',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_SCHEDULER, SchedulerNode::class, [
            'name' => 'Scheduler',
            'description' => 'Schedule workflows to run periodically',
            'category' => 'Trigger',
            'icon' => 'calendar',
            'color' => 'yellow',
        ]);
        
        $this->registerNodeType(WorkflowNode::TYPE_RETURN, ReturnNode::class, [
            'name' => 'Return',
            'description' => 'Return data from the workflow',
            'category' => 'Logic',
            'icon' => 'reply',
            'color' => 'gray',
        ]);
    }
    
    /**
     * Register a node type
     */
    public function registerNodeType(string $type, string $handlerClass, array $metadata = []): void
    {
        $this->nodeTypes[$type] = [
            'type' => $type,
            'handler' => $handlerClass,
            'metadata' => $metadata,
        ];
    }
    
    /**
     * Get all registered node types
     */
    public function getNodeTypes(): array
    {
        $result = [];
        
        foreach ($this->nodeTypes as $type => $info) {
            $handler = App::make($info['handler']);
            
            $result[$type] = array_merge($info['metadata'], [
                'type' => $type,
                'config_schema' => $handler->getConfigSchema(),
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get a node handler instance
     */
    public function getNodeHandler(string $type): NodeTypeInterface
    {
        if (!isset($this->nodeTypes[$type])) {
            throw new \InvalidArgumentException("Unknown node type: {$type}");
        }
        
        return App::make($this->nodeTypes[$type]['handler']);
    }
    
    /**
     * Check if a node type exists
     */
    public function hasNodeType(string $type): bool
    {
        return isset($this->nodeTypes[$type]);
    }
    
    /**
     * Get metadata for a node type
     */
    public function getNodeTypeMetadata(string $type): array
    {
        if (!isset($this->nodeTypes[$type])) {
            throw new \InvalidArgumentException("Unknown node type: {$type}");
        }
        
        return $this->nodeTypes[$type]['metadata'];
    }
}

Copy

Apply

app\Services\Workflow\NodeRegistry.php
Let's implement the VariableResolver for handling variable references in workflows:

namespace App\Services\Workflow;

class VariableResolver
{
    /**
     * Resolve variables in node configuration
     */
    public function resolveNodeInput(array $config, ?array $inputMapping, array $input): array
    {
        // If input mapping is defined, map input values
        if ($inputMapping) {
            $mappedInput = [];
            
            foreach ($inputMapping as $source => $target) {
                $value = $this->getValueByPath($input, $source);
                $mappedInput = $this->setValueByPath($mappedInput, $target, $value);
            }
            
            // Use mapped input for variable resolution
            $resolvedConfig = $this->resolveVariables($config, $mappedInput);
        } else {
            // Use original input for variable resolution
            $resolvedConfig = $this->resolveVariables($config, $input);
        }
        
        return $resolvedConfig;
    }
    
    /**
     * Resolve variables in an array recursively
     */
    public function resolveVariables(array $data, array $variables): array
    {
        $result = [];
        
        foreach ($data as $key => $value) {
            if (is_array($value)) {
                $result[$key] = $this->resolveVariables($value, $variables);
            } elseif (is_string($value)) {
                $result[$key] = $this->resolveVariablesInString($value, $variables);
            } else {
                $result[$key] = $value;
            }
        }
        
        return $result;
    }
    
    /**
     * Resolve variables in a string
     */
    protected function resolveVariablesInString(string $str, array $variables): string
    {
        // Replace {{variable}} pattern
        return preg_replace_callback('/\{\{([^}]+)\}\}/', function ($matches) use ($variables) {
            $path = trim($matches[1]);
            $value = $this->getValueByPath($variables, $path);
            
            // Convert arrays and objects to JSON
            if (is_array($value) || is_object($value)) {

Copy

Apply

app\Services\Workflow\VariableResolver.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  app\Services\Workflow\VariableResolver.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with the VariableResolver implementation and the remaining files according to the directory structure. I need to:

Complete the VariableResolver class (it was cut off)
Implement ReturnNode.php
Implement RAG services (LlphantService, DocumentProcessor, etc.)
Implement Filament resources
Implement Jobs
I'll focus on these key components according to the structure.

Let me continue implementing VariableResolver.php and the rest of the files according to the directory structure:

namespace App\Services\Workflow;

class VariableResolver
{
    /**
     * Resolve variables in node configuration
     */
    public function resolveNodeInput(array $config, ?array $inputMapping, array $input): array
    {
        // If input mapping is defined, map input values
        if ($inputMapping) {
            $mappedInput = [];
            
            foreach ($inputMapping as $source => $target) {
                $value = $this->getValueByPath($input, $source);
                $mappedInput = $this->setValueByPath($mappedInput, $target, $value);
            }
            
            // Use mapped input for variable resolution
            $resolvedConfig = $this->resolveVariables($config, $mappedInput);
        } else {
            // Use original input for variable resolution
            $resolvedConfig = $this->resolveVariables($config, $input);
        }
        
        return $resolvedConfig;
    }
    
    /**
     * Resolve variables in an array recursively
     */
    public function resolveVariables(array $data, array $variables): array
    {
        $result = [];
        
        foreach ($data as $key => $value) {
            if (is_array($value)) {
                $result[$key] = $this->resolveVariables($value, $variables);
            } elseif (is_string($value)) {
                $result[$key] = $this->resolveVariablesInString($value, $variables);
            } else {
                $result[$key] = $value;
            }
        }
        
        return $result;
    }
    
    /**
     * Resolve variables in a string
     */
    protected function resolveVariablesInString(string $str, array $variables): string
    {
        // Replace {{variable}} pattern
        return preg_replace_callback('/\{\{([^}]+)\}\}/', function ($matches) use ($variables) {
            $path = trim($matches[1]);
            $value = $this->getValueByPath($variables, $path);
            
            // Convert arrays and objects to JSON
            if (is_array($value) || is_object($value)) {
                return json_encode($value);
            }
            
            // Return string value or empty string for null
            return is_null($value) ? '' : (string) $value;
        }, $str);
    }
    
    /**
     * Get value from nested array by dot notation path
     */
    public function getValueByPath(array $data, string $path)
    {
        // Handle empty path
        if (empty($path)) {
            return null;
        }
        
        // Split path into segments
        $segments = explode('.', $path);
        $current = $data;
        
        // Navigate through path segments
        foreach ($segments as $segment) {
            if (is_array($current) && array_key_exists($segment, $current)) {
                $current = $current[$segment];
            } elseif (is_object($current) && property_exists($current, $segment)) {
                $current = $current->{$segment};
            } else {
                return null; // Path segment not found
            }
        }
        
        return $current;
    }
    
    /**
     * Set value in nested array by dot notation path
     */
    public function setValueByPath(array $data, string $path, $value): array
    {
        // Handle empty path
        if (empty($path)) {
            return $data;
        }
        
        // Split path into segments
        $segments = explode('.', $path);
        $current = &$data;
        
        // Navigate through path segments and create if not exists
        foreach ($segments as $i => $segment) {
            // If this is the last segment, set the value
            if ($i === count($segments) - 1) {
                $current[$segment] = $value;
            } else {
                // Create the path if it doesn't exist
                if (!isset($current[$segment]) || !is_array($current[$segment])) {
                    $current[$segment] = [];
                }
                
                // Move reference to next level
                $current = &$current[$segment];
            }
        }
        
        return $data;
    }
}

Copy

Apply

app\Services\Workflow\VariableResolver.php
Now let's implement the ReturnNode:

namespace App\Services\Workflow\NodeTypes;

use App\Models\WorkflowExecution;
use App\Models\WorkflowNode;

class ReturnNode implements NodeTypeInterface
{
    /**
     * Execute the Return node
     */
    public function execute(WorkflowNode $node, array $input, WorkflowExecution $execution): array
    {
        $config = $node->config;
        
        // By default, return all input data
        if (empty($config['return_type']) || $config['return_type'] === 'all') {
            return $input;
        }
        
        // Return specific variables
        if ($config['return_type'] === 'specific' && !empty($config['variables'])) {
            $result = [];
            
            foreach ($config['variables'] as $variable) {
                $key = $variable['key'] ?? null;
                $path = $variable['path'] ?? null;
                
                if ($key && $path) {
                    // Extract the value from input using the specified path
                    $value = $this->getValueByPath($input, $path);
                    $result[$key] = $value;
                }
            }
            
            return $result;
        }
        
        // Return static value
        if ($config['return_type'] === 'static' && isset($config['static_value'])) {
            return [
                'result' => $config['static_value']
            ];
        }
        
        // Return custom value (JSON)
        if ($config['return_type'] === 'custom' && !empty($config['custom_json'])) {
            try {
                $customValue = json_decode($config['custom_json'], true);
                
                if (json_last_error() === JSON_ERROR_NONE) {
                    return $customValue;
                }
            } catch (\Exception $e) {
                // If JSON parsing fails, return as string
                return [
                    'result' => $config['custom_json']
                ];
            }
        }
        
        // Default fallback: return all input
        return $input;
    }
    
    /**
     * Get JSON Schema for return configuration
     */
    public function getConfigSchema(): array
    {
        return [
            'type' => 'object',
            'properties' => [
                'return_type' => [
                    'type' => 'string',
                    'title' => 'Return Type',
                    'enum' => ['all', 'specific', 'static', 'custom'],
                    'default' => 'all',
                ],
                'variables' => [
                    'type' => 'array',
                    'title' => 'Variables to Return',
                    'items' => [
                        'type' => 'object',
                        'properties' => [
                            'key' => [
                                'type' => 'string',
                                'title' => 'Output Key',
                            ],
                            'path' => [
                                'type' => 'string',
                                'title' => 'Input Path',
                            ],
                        ],
                    ],
                ],
                'static_value' => [
                    'type' => 'string',
                    'title' => 'Static Value',
                ],
                'custom_json' => [
                    'type' => 'string',
                    'title' => 'Custom JSON',
                    'x-control' => 'code-editor',
                    'x-language' => 'json',
                ],
            ],
        ];
    }
    
    /**
     * Validate return configuration
     */
    public function validateConfig(array $config): bool
    {
        // All configurations are valid for return node
        return true;
    }
    
    /**
     * Get value from nested array by dot notation path
     */
    private function getValueByPath(array $data, string $path)
    {
        // Handle empty path
        if (empty($path)) {
            return null;
        }
        
        // Split path into segments
        $segments = explode('.', $path);
        $current = $data;
        
        // Navigate through path segments
        foreach ($segments as $segment) {
            if (is_array($current) && array_key_exists($segment, $current)) {
                $current = $current[$segment];
            } elseif (is_object($current) && property_exists($current, $segment)) {
                $current = $current->{$segment};
            } else {
                return null; // Path segment not found
            }
        }
        
        return $current;
    }
}

Copy

Apply

app\Services\Workflow\NodeTypes\ReturnNode.php
Let's implement the RAG services starting with LlphantService:

namespace App\Services\RAG;

use Illuminate\Support\Facades\Log;
use Llphant\Contracts\ChatModelInterface;
use Llphant\Contracts\VectorStoreInterface;
use Llphant\Formatting\ChatMessage;
use Llphant\Llphant;
use Llphant\Retrievers\VectorStoreRetriever;

class LlphantService
{
    protected $llphant;
    protected $vectorStore;
    protected $model;
    
    public function __construct(
        Llphant $llphant,
        VectorStoreInterface $vectorStore,
        ChatModelInterface $model
    ) {
        $this->llphant = $llphant;
        $this->vectorStore = $vectorStore;
        $this->model = $model;
    }
    
    /**
     * Generate a RAG-enhanced response to a user query
     */
    public function generateResponse(string $query, array $systemInstructions = [], int $maxResults = 5, float $threshold = 0.7): string
    {
        try {
            // Set up vector store retriever
            $retriever = new VectorStoreRetriever(
                $this->vectorStore,
                maxResults: $maxResults,
                threshold: $threshold
            );
            
            // Retrieve relevant documents
            $relevantDocs = $retriever->retrieve($query);
            
            // Create context from documents
            $context = '';
            
            foreach ($relevantDocs as $doc) {
                $context .= "Document: {$doc->metadata['title'] ?? 'Untitled'}\n";
                $context .= "Content: {$doc->content}\n\n";
            }
            
            // Build system message with context
            $systemContent = "You are a helpful assistant with access to the following documents:\n\n";
            $systemContent .= $context;
            $systemContent .= "\nUse this information to answer the user's questions. If the answer cannot be found in the provided documents, say so clearly.";
            
            // Add custom instructions if provided
            if (!empty($systemInstructions)) {
                $systemContent .= "\n\nAdditional instructions:\n";
                $systemContent .= implode("\n", $systemInstructions);
            }
            
            // Create chat messages
            $messages = [
                new ChatMessage(role: 'system', content: $systemContent),
                new ChatMessage(role: 'user', content: $query),
            ];
            
            // Generate response
            $response = $this->model->generate($messages);
            
            // Return content
            return $response->content;
        } catch (\Exception $e) {
            Log::error('RAG query failed', [
                'query' => $query,
                'error' => $e->getMessage(),
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Generate a streaming RAG-enhanced response to a user query
     */
    public function generateStreamingResponse(string $query, array $systemInstructions = [], int $maxResults = 5, float $threshold = 0.7)
    {
        try {
            // Set up vector store retriever
            $retriever = new VectorStoreRetriever(
                $this->vectorStore,
                maxResults: $maxResults,
                threshold: $threshold
            );
            
            // Retrieve relevant documents
            $relevantDocs = $retriever->retrieve($query);
            
            // Create context from documents
            $context = '';
            
            foreach ($relevantDocs as $doc) {
                $context .= "Document: {$doc->metadata['title'] ?? 'Untitled'}\n";
                $context .= "Content: {$doc->content}\n\n";
            }
            
            // Build system message with context
            $systemContent = "You are a helpful assistant with access to the following documents:\n\n";
            $systemContent .= $context;
            $systemContent .= "\nUse this information to answer the user's questions. If the answer cannot be found in the provided documents, say so clearly.";
            
            // Add custom instructions if provided
            if (!empty($systemInstructions)) {
                $systemContent .= "\n\nAdditional instructions:\n";
                $systemContent .= implode("\n", $systemInstructions);
            }
            
            // Create chat messages
            $messages = [
                new ChatMessage(role: 'system', content: $systemContent),
                new ChatMessage(role: 'user', content: $query),
            ];
            
            // Generate streaming response
            return $this->model->generateStream($messages);
        } catch (\Exception $e) {
            Log::error('RAG streaming query failed', [
                'query' => $query,
                'error' => $e->getMessage(),
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Get information about the sources used for the response
     */
    public function getSourcesForQuery(string $query, int $maxResults = 5, float $threshold = 0.7): array
    {
        // Set up vector store retriever
        $retriever = new VectorStoreRetriever(
            $this->vectorStore,
            maxResults: $maxResults,
            threshold: $threshold
        );
        
        // Retrieve relevant documents
        $relevantDocs = $retriever->retrieve($query);
        
        // Format source information
        $sources = [];
        
        foreach ($relevantDocs as $doc) {
            $sources[] = [
                'title' => $doc->metadata['title'] ?? 'Untitled',
                'file_name' => $doc->metadata['file_name'] ?? null,
                'document_id' => $doc->metadata['document_id'] ?? null,
                'similarity' => $doc->metadata['similarity'] ?? null,
                'created_at' => $doc->metadata['created_at'] ?? null,
            ];
        }
        
        return $sources;
    }
}

Copy

Apply

app\Services\RAG\LlphantService.php
Now let's implement the DocumentProcessor:

namespace App\Services\RAG;

use App\Models\KnowledgeDocument;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Smalot\PdfParser\Parser as PdfParser;

class DocumentProcessor
{
    protected $emb

Copy

Apply

app\Services\RAG\DocumentProcessor.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  DocumnetProcessor.php and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with the code generation for DocumentProcessor.php and other key files. I'll focus on these remaining important components:

Complete DocumentProcessor.php (which was cut off)
Implement EmbeddingService.php
Implement VectorStoreService.php (Qdrant integration)
Implement WorkflowResource.php for Filament
Implement the key Jobs (like ExecuteWorkflow)
Implement a database migration file
Let me continue with DocumentProcessor.php first, which will handle document processing for RAG.

Let me continue implementing the DocumentProcessor and other remaining files according to the directory structure:

namespace App\Services\RAG;

use App\Models\KnowledgeDocument;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Smalot\PdfParser\Parser as PdfParser;

class DocumentProcessor
{
    protected $embeddingService;
    protected $vectorStoreService;
    protected $chunkSize;
    protected $chunkOverlap;
    
    public function __construct(
        EmbeddingService $embeddingService,
        VectorStoreService $vectorStoreService,
        int $chunkSize = 1000,
        int $chunkOverlap = 200
    ) {
        $this->embeddingService = $embeddingService;
        $this->vectorStoreService = $vectorStoreService;
        $this->chunkSize = $chunkSize;
        $this->chunkOverlap = $chunkOverlap;
    }
    
    /**
     * Process a document for RAG
     */
    public function processDocument(KnowledgeDocument $document): bool
    {
        try {
            // Extract text from document
            $text = $this->extractTextFromDocument($document);
            
            if (empty($text)) {
                throw new \Exception("Failed to extract text from document");
            }
            
            // Update document with extracted text
            $document->content = $text;
            $document->save();
            
            // Chunk text
            $chunks = $this->chunkText($text);
            
            // Generate embeddings and store in vector DB
            foreach ($chunks as $index => $chunk) {
                // Generate embedding
                $embedding = $this->embeddingService->generateEmbedding($chunk);
                
                // Store in vector database
                $this->vectorStoreService->storeEmbedding(
                    $chunk,
                    $embedding,
                    [
                        'document_id' => $document->id,
                        'title' => $document->title,
                        'file_name' => $document->file_name,
                        'chunk_index' => $index,
                        'created_at' => $document->created_at->toIso8601String(),
                    ]
                );
            }
            
            // Mark document as processed
            $document->update([
                'is_processed' => true,
                'chunks_count' => count($chunks),
                'processed_at' => now(),
            ]);
            
            return true;
        } catch (\Exception $e) {
            // Update document status with error
            $document->update([
                'is_processed' => false,
                'processing_error' => $e->getMessage(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Extract text from document based on file type
     */
    protected function extractTextFromDocument(KnowledgeDocument $document): string
    {
        // Get file path
        $filePath = Storage::disk('documents')->path($document->file_path);
        
        // Get file extension
        $extension = strtolower(pathinfo($document->file_name, PATHINFO_EXTENSION));
        
        // Process based on file type
        switch ($extension) {
            case 'pdf':
                return $this->extractTextFromPdf($filePath);
            case 'txt':
                return file_get_contents($filePath);
            case 'docx':
                return $this->extractTextFromDocx($filePath);
            case 'md':
            case 'markdown':
                return file_get_contents($filePath);
            case 'html':
            case 'htm':
                return $this->extractTextFromHtml($filePath);
            default:
                throw new \Exception("Unsupported file type: {$extension}");
        }
    }
    
    /**
     * Extract text from PDF using PDF Parser
     */
    protected function extractTextFromPdf(string $filePath): string
    {
        $parser = new PdfParser();
        $pdf = $parser->parseFile($filePath);
        
        return $pdf->getText();
    }
    
    /**
     * Extract text from DOCX using PhpWord
     */
    protected function extractTextFromDocx(string $filePath): string
    {
        $phpWord = \PhpOffice\PhpWord\IOFactory::load($filePath);
        $text = '';
        
        foreach ($phpWord->getSections() as $section) {
            foreach ($section->getElements() as $element) {
                if (method_exists($element, 'getText')) {
                    $text .= $element->getText() . "\n";
                } else if (method_exists($element, 'getElements')) {
                    foreach ($element->getElements() as $childElement) {
                        if (method_exists($childElement, 'getText')) {
                            $text .= $childElement->getText() . "\n";
                        }
                    }
                }
            }
        }
        
        return $text;
    }
    
    /**
     * Extract text from HTML
     */
    protected function extractTextFromHtml(string $filePath): string
    {
        $html = file_get_contents($filePath);
        
        // Remove scripts, styles, and HTML tags
        $html = preg_replace('/<script\b[^>]*>(.*?)<\/script>/is', '', $html);
        $html = preg_replace('/<style\b[^>]*>(.*?)<\/style>/is', '', $html);
        $text = strip_tags($html);
        
        // Convert HTML entities
        $text = html_entity_decode($text);
        
        // Normalize whitespace
        $text = preg_replace('/\s+/', ' ', $text);
        
        return trim($text);
    }
    
    /**
     * Chunk text into smaller pieces for embedding
     */
    protected function chunkText(string $text): array
    {
        // Split by paragraphs first
        $paragraphs = preg_split('/\n\s*\n/', $text);
        $chunks = [];
        $currentChunk = '';
        
        foreach ($paragraphs as $paragraph) {
            $paragraph = trim($paragraph);
            
            if (empty($paragraph)) {
                continue;
            }
            
            // If adding this paragraph exceeds chunk size, save current chunk and start new one
            if (strlen($currentChunk) + strlen($paragraph) > $this->chunkSize) {
                // If current chunk is not empty, save it
                if (!empty($currentChunk)) {
                    $chunks[] = trim($currentChunk);
                }
                
                // Start a new chunk with the current paragraph
                $currentChunk = $paragraph;
            } else {
                // Add paragraph to current chunk
                $currentChunk .= "\n" . $paragraph;
            }
        }
        
        // Add the last chunk if not empty
        if (!empty($currentChunk)) {
            $chunks[] = trim($currentChunk);
        }
        
        // Ensure chunks have some overlap for context
        if (count($chunks) > 1 && $this->chunkOverlap > 0) {
            $overlappedChunks = [];
            
            for ($i = 0; $i < count($chunks); $i++) {
                if ($i > 0) {
                    // Get the end of the previous chunk for overlap
                    $previousWords = explode(' ', $chunks[$i-1]);
                    $overlapWords = array_slice($previousWords, -$this->chunkOverlap / 10);
                    $overlapText = implode(' ', $overlapWords);
                    
                    // Add overlap to the beginning of the current chunk
                    $overlappedChunks[] = $overlapText . "\n" . $chunks[$i];
                } else {
                    $overlappedChunks[] = $chunks[$i];
                }
            }
            
            $chunks = $overlappedChunks;
        }
        
        return $chunks;
    }
}

Copy

Apply

app\Services\RAG\DocumentProcessor.php
Now let's implement the EmbeddingService:

namespace App\Services\RAG;

use App\Services\LLM\OpenAIAdapter;
use App\Services\LLM\PrismAdapter;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class EmbeddingService
{
    protected $openAIAdapter;
    protected $prismAdapter;
    protected $embeddingModel;
    protected $useCache;
    protected $provider;
    
    public function __construct(
        OpenAIAdapter $openAIAdapter,
        PrismAdapter $prismAdapter,
        string $provider = 'openai',
        string $embeddingModel = 'text-embedding-3-small',
        bool $useCache = true
    ) {
        $this->openAIAdapter = $openAIAdapter;
        $this->prismAdapter = $prismAdapter;
        $this->provider = $provider;
        $this->embeddingModel = $embeddingModel;
        $this->useCache = $useCache;
    }
    
    /**
     * Generate embedding for text
     */
    public function generateEmbedding(string $text): array
    {
        // Check cache if enabled
        if ($this->useCache) {
            $cacheKey = 'embedding_' . md5($text);
            
            if (Cache::has($cacheKey)) {
                return Cache::get($cacheKey);
            }
        }
        
        try {
            // Use the appropriate adapter based on configuration
            if ($this->provider === 'prism') {
                $embedding = $this->prismAdapter->generateEmbeddings($text, $this->embeddingModel);
            } else {
                $embedding = $this->openAIAdapter->generateEmbeddings($text, $this->embeddingModel);
            }
            
            // Cache the result if caching is enabled
            if ($this->useCache) {
                Cache::put($cacheKey, $embedding, now()->addDays(7));
            }
            
            return $embedding;
        } catch (\Exception $e) {
            Log::error('Failed to generate embedding', [
                'error' => $e->getMessage(),
                'provider' => $this->provider,
                'model' => $this->embeddingModel,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Generate embeddings for multiple texts in batch
     */
    public function generateEmbeddingsBatch(array $texts): array
    {
        $embeddings = [];
        
        foreach ($texts as $text) {
            $embeddings[] = $this->generateEmbedding($text);
        }
        
        return $embeddings;
    }
    
    /**
     * Set the embedding model to use
     */
    public function setEmbeddingModel(string $model): self
    {
        $this->embeddingModel = $model;
        
        return $this;
    }
    
    /**
     * Set the provider to use (openai or prism)
     */
    public function setProvider(string $provider): self
    {
        $this->provider = $provider;
        
        return $this;
    }
}

Copy

Apply

app\Services\RAG\EmbeddingService.php
Now let's implement the VectorStoreService for Qdrant integration:

namespace App\Services\RAG;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class VectorStoreService
{
    protected $qdrantUrl;
    protected $collectionName;
    protected $apiKey;
    protected $vectorSize;
    
    public function __construct(
        string $qdrantUrl = null,
        string $collectionName = 'documents',
        string $apiKey = null,
        int $vectorSize = 1536
    ) {
        $this->qdrantUrl = $qdrantUrl ?? config('services.qdrant.url', 'http://localhost:6333');
        $this->collectionName = $collectionName;
        $this->apiKey = $apiKey ?? config('services.qdrant.api_key');
        $this->vectorSize = $vectorSize;
    }
    
    /**
     * Initialize the collection if it doesn't exist
     */
    public function initializeCollection(): bool
    {
        try {
            // Check if collection already exists
            $response = $this->sendRequest('GET', "/collections/{$this->collectionName}");
            
            if ($response->successful()) {
                return true; // Collection already exists
            }
            
            // Create collection
            $createResponse = $this->sendRequest('PUT', "/collections/{$this->collectionName}", [
                'vectors' => [
                    'size' => $this->vectorSize,
                    'distance' => 'Cosine',
                ],
                'optimizers_config' => [
                    'default_segment_number' => 2,
                ],
                'replication_factor' => 1,
            ]);
            
            if (!$createResponse->successful()) {
                throw new \Exception("Failed to create collection: " . $createResponse->body());
            }
            
            // Create payload index for document_id to enable filtering
            $indexResponse = $this->sendRequest('PUT', "/collections/{$this->collectionName}/index", [
                'field_name' => 'document_id',
                'field_schema' => 'keyword',
            ]);
            
            return $indexResponse->successful();
        } catch (\Exception $e) {
            Log::error('Failed to initialize Qdrant collection', [
                'error' => $e->getMessage(),
                'collection' => $this->collectionName,
            ]);
            
            return false;
        }
    }
    
    /**
     * Store an embedding in the vector database
     */
    public function storeEmbedding(string $text, array $embedding, array $metadata = []): string
    {
        // Generate a unique ID for this vector
        $pointId = (string) Str::uuid();
        
        try {
            // Ensure collection exists
            $this->initializeCollection();
            
            // Store point in Qdrant
            $response = $this->sendRequest('PUT', "/collections/{$this->collectionName}/points", [
                'points' => [
                    [
                        'id' => $pointId,
                        'vector' => $embedding,
                        'payload' => array_merge([
                            'text' => $text,
                            'point_id' => $pointId,
                        ], $metadata),
                    ],
                ],
            ]);
            
            if (!$response->successful()) {
                throw new \Exception("Failed to store point: " . $response->body());
            }
            
            return $pointId;
        } catch (\Exception $e) {
            Log::error('Failed to store embedding in Qdrant', [
                'error' => $e->getMessage(),
                'collection' => $this->collectionName,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Search for similar vectors
     */
    public function search(array

Copy

Apply

app\Services\RAG\VectorStoreService.php
│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  VectorStoreService.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with the VectorStoreService.php implementation (which was cut off) and then implement other key files from the directory structure:

Complete the VectorStoreService.php
Implement Filament resources like WorkflowResource.php
Implement the Jobs classes like ExecuteWorkflow.php
Implement a sample migration file
I'll focus on these core components to create a comprehensive solution according to the structure.

Let me continue implementing the VectorStoreService.php and other key files from the directory structure:

namespace App\Services\RAG;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class VectorStoreService
{
    protected $qdrantUrl;
    protected $collectionName;
    protected $apiKey;
    protected $vectorSize;
    
    public function __construct(
        string $qdrantUrl = null,
        string $collectionName = 'documents',
        string $apiKey = null,
        int $vectorSize = 1536
    ) {
        $this->qdrantUrl = $qdrantUrl ?? config('services.qdrant.url', 'http://localhost:6333');
        $this->collectionName = $collectionName;
        $this->apiKey = $apiKey ?? config('services.qdrant.api_key');
        $this->vectorSize = $vectorSize;
    }
    
    /**
     * Initialize the collection if it doesn't exist
     */
    public function initializeCollection(): bool
    {
        try {
            // Check if collection already exists
            $response = $this->sendRequest('GET', "/collections/{$this->collectionName}");
            
            if ($response->successful()) {
                return true; // Collection already exists
            }
            
            // Create collection
            $createResponse = $this->sendRequest('PUT', "/collections/{$this->collectionName}", [
                'vectors' => [
                    'size' => $this->vectorSize,
                    'distance' => 'Cosine',
                ],
                'optimizers_config' => [
                    'default_segment_number' => 2,
                ],
                'replication_factor' => 1,
            ]);
            
            if (!$createResponse->successful()) {
                throw new \Exception("Failed to create collection: " . $createResponse->body());
            }
            
            // Create payload index for document_id to enable filtering
            $indexResponse = $this->sendRequest('PUT', "/collections/{$this->collectionName}/index", [
                'field_name' => 'document_id',
                'field_schema' => 'keyword',
            ]);
            
            return $indexResponse->successful();
        } catch (\Exception $e) {
            Log::error('Failed to initialize Qdrant collection', [
                'error' => $e->getMessage(),
                'collection' => $this->collectionName,
            ]);
            
            return false;
        }
    }
    
    /**
     * Store an embedding in the vector database
     */
    public function storeEmbedding(string $text, array $embedding, array $metadata = []): string
    {
        // Generate a unique ID for this vector
        $pointId = (string) Str::uuid();
        
        try {
            // Ensure collection exists
            $this->initializeCollection();
            
            // Store point in Qdrant
            $response = $this->sendRequest('PUT', "/collections/{$this->collectionName}/points", [
                'points' => [
                    [
                        'id' => $pointId,
                        'vector' => $embedding,
                        'payload' => array_merge([
                            'text' => $text,
                            'point_id' => $pointId,
                        ], $metadata),
                    ],
                ],
            ]);
            
            if (!$response->successful()) {
                throw new \Exception("Failed to store point: " . $response->body());
            }
            
            return $pointId;
        } catch (\Exception $e) {
            Log::error('Failed to store embedding in Qdrant', [
                'error' => $e->getMessage(),
                'collection' => $this->collectionName,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Search for similar vectors
     */
    public function search(array $embedding, int $limit = 5, float $threshold = 0.7, array $filter = []): array
    {
        try {
            $payload = [
                'vector' => $embedding,
                'limit' => $limit,
                'with_payload' => true,
                'score_threshold' => $threshold,
            ];
            
            // Add filter if provided
            if (!empty($filter)) {
                $payload['filter'] = $filter;
            }
            
            $response = $this->sendRequest('POST', "/collections/{$this->collectionName}/points/search", $payload);
            
            if (!$response->successful()) {
                throw new \Exception("Failed to search: " . $response->body());
            }
            
            $results = $response->json()['result'] ?? [];
            
            // Format results
            $formattedResults = [];
            foreach ($results as $result) {
                $formattedResults[] = [
                    'id' => $result['id'],
                    'score' => $result['score'],
                    'text' => $result['payload']['text'] ?? '',
                    'metadata' => array_diff_key($result['payload'], ['text' => true]),
                ];
            }
            
            return $formattedResults;
        } catch (\Exception $e) {
            Log::error('Failed to search in Qdrant', [
                'error' => $e->getMessage(),
                'collection' => $this->collectionName,
            ]);
            
            throw $e;
        }
    }
    
    /**
     * Delete embeddings for a document
     */
    public function deleteEmbeddingsForDocument(string $documentId): bool
    {
        try {
            $response = $this->sendRequest('POST', "/collections/{$this->collectionName}/points/delete", [
                'filter' => [
                    'must' => [
                        [
                            'key' => 'document_id',
                            'match' => [
                                'value' => $documentId,
                            ],
                        ],
                    ],
                ],
            ]);
            
            return $response->successful();
        } catch (\Exception $e) {
            Log::error('Failed to delete embeddings for document', [
                'error' => $e->getMessage(),
                'document_id' => $documentId,
                'collection' => $this->collectionName,
            ]);
            
            return false;
        }
    }
    
    /**
     * Helper method to send requests to Qdrant API
     */
    protected function sendRequest(string $method, string $endpoint, array $data = [])
    {
        $url = rtrim($this->qdrantUrl, '/') . $endpoint;
        $headers = ['Content-Type' => 'application/json'];
        
        // Add API key if provided
        if ($this->apiKey) {
            $headers['Api-Key'] = $this->apiKey;
        }
        
        return Http::withHeaders($headers)->$method($url, $data);
    }
}

Copy

Apply

app\Services\RAG\VectorStoreService.php
Now let's implement a Filament resource for managing workflows:

namespace App\Filament\Resources;

use App\Filament\Resources\WorkflowResource\Pages;
use App\Models\Workflow;
use Filament\Forms;
use Filament\Forms\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Tables\Table;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletingScope;

class WorkflowResource extends Resource
{
    protected static ?string $model = Workflow::class;
    protected static ?string $navigationIcon = 'heroicon-o-arrows-right-left';
    protected static ?string $navigationGroup = 'Automation';
    protected static ?int $navigationSort = 1;

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\Card::make()
                    ->schema([
                        Forms\Components\TextInput::make('name')
                            ->required()
                            ->maxLength(255),
                        Forms\Components\Textarea::make('description')
                            ->rows(3)
                            ->maxLength(1000),
                        Forms\Components\Toggle::make('is_active')
                            ->label('Active')
                            ->default(true),
                        Forms\Components\Select::make('trigger_type')
                            ->label('Trigger Type')
                            ->options([
                                'webhook' => 'Webhook',
                                'scheduled' => 'Scheduled',
                                'manual' => 'Manual',
                                'event' => 'Event',
                            ])
                            ->required(),
                        Forms\Components\Select::make('schedule_frequency')
                            ->label('Schedule Frequency')
                            ->options([
                                'minutely' => 'Every Minute',
                                'hourly' => 'Hourly',
                                'daily' => 'Daily',
                                'weekly' => 'Weekly',
                                'monthly' => 'Monthly',
                                'custom' => 'Custom',
                            ])
                            ->visible(fn (callable $get) => $get('trigger_type') === 'scheduled'),
                        Forms\Components\TextInput::make('cron_expression')
                            ->label('Cron Expression')
                            ->placeholder('e.g. * * * * *')
                            ->helperText('Leave empty to use selected frequency')
                            ->visible(fn (callable $get) => $get('trigger_type') === 'scheduled'),
                        Forms\Components\KeyValue::make('trigger_config')
                            ->label('Trigger Configuration')
                            ->keyLabel('Parameter')
                            ->valueLabel('Value')
                            ->addable()
                            ->deletable(),
                    ]),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('name')
                    ->searchable(),
                Tables\Columns\TextColumn::make('description')
                    ->limit(50)
                    ->searchable(),
                Tables\Columns\BadgeColumn::make('trigger_type')
                    ->colors([
                        'primary' => 'webhook',
                        'success' => 'scheduled',
                        'warning' => 'manual',
                        'danger' => 'event',
                    ]),
                Tables\Columns\IconColumn::make('is_active')
                    ->boolean(),
                Tables\Columns\TextColumn::make('created_at')
                    ->dateTime()
                    ->sortable(),
                Tables\Columns\TextColumn::make('updated_at')
                    ->dateTime()
                    ->sortable()
                    ->toggleable(isToggledHiddenByDefault: true),
            ])
            ->filters([
                Tables\Filters\SelectFilter::make('trigger_type')
                    ->options([
                        'webhook' => 'Webhook',
                        'scheduled' => 'Scheduled',
                        'manual' => 'Manual',
                        'event' => 'Event',
                    ]),
                Tables\Filters\TernaryFilter::make('is_active')
                    ->label('Active'),
            ])
            ->actions([
                Tables\Actions\ActionGroup::make([
                    Tables\Actions\EditAction::make(),
                    Tables\Actions\Action::make('build')
                        ->label('Open Builder')
                        ->color('primary')
                        ->icon('heroicon-o-adjustments-horizontal')
                        ->url(fn (Workflow $record) => route('filament.admin.resources.workflows.builder', $record)),
                    Tables\Actions\Action::make('run')
                        ->label('Execute')
                        ->color('success')
                        ->icon('heroicon-o-play')
                        ->action(fn (Workflow $record) => $record->execute()),
                    Tables\Actions\Action::make('duplicate')
                        ->label('Duplicate')
                        ->color('warning')
                        ->icon('heroicon-o-document-duplicate')
                        ->action(fn (Workflow $record) => $record->duplicate()),
                    Tables\Actions\DeleteAction::make(),
                ]),
            ])
            ->bulkActions([
                Tables\Actions\BulkActionGroup::make([
                    Tables\Actions\DeleteBulkAction::make(),
                    Tables\Actions\BulkAction::make('activate')
                        ->label('Activate')
                        ->color('success')
                        ->icon('heroicon-o-check')
                        ->action(fn (Builder $query) => $query->update(['is_active' => true])),
                    Tables\Actions\BulkAction::make('deactivate')
                        ->label('Deactivate')
                        ->color('danger')
                        ->icon('heroicon-o-x-mark')
                        ->action(fn (Builder $query) => $query->update(['is_active' => false])),
                ]),
            ]);
    }
    
    public static function getRelations(): array
    {
        return [
            //
        ];
    }
    
    public static function getPages(): array
    {
        return [
            'index' => Pages\ListWorkflows::route('/'),
            'create' => Pages\CreateWorkflow::route('/create'),
            'edit' => Pages\EditWorkflow::route('/{record}/edit'),
            'builder' => Pages\WorkflowBuilder::route('/{record}/builder'),
        ];
    }    
}

Copy

Apply

app\Filament\Resources\WorkflowResource.php
Let's implement the ExecuteWorkflow job:

namespace App\Jobs;

use App\Models\Workflow;
use App\Models\WorkflowExecution;
use App\Services\Workflow\WorkflowEngine;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ExecuteWorkflow implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $workflow;
    protected $input;
    protected $executionId;
    protected $userId;

    /**
     * Create a new job instance.
     */
    public function __construct(Workflow $workflow, array $input = [], ?int $executionId = null, ?int $userId = null)
    {
        $this->workflow = $workflow;
        $this->input = $input;
        $this->executionId = $executionId;
        $this->userId = $userId;
    }

    /**
     * Execute the job.
     */
    public function handle(WorkflowEngine $engine): void
    {
        try {
            // Create an execution record if not provided
            if (!$this->executionId) {
                $execution = WorkflowExecution::create([
                    'workflow_id' => $this->workflow->id,
                    'status' => WorkflowExecution::STATUS_RUNNING,
                    'input' => $this->input,
                    'user_id' => $this->userId,
                    'started_at' => now(),
                ]);
                
                $this->executionId = $execution->id;
            } else {

Copy

Apply

app\Jobs\ExecuteWorkflow.php
│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  ExecuteWorkflow.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 13 new items
Let me continue implementing the ExecuteWorkflow.php job which was cut off and create implementations for the other key files in the directory structure:

Complete ExecuteWorkflow.php
Implement ProcessDocument.php job
Implement ScheduledWorkflow.php job
Implement LlphantServiceProvider.php
Implement a sample migration file for the workflows table
I'll focus on completing these core backend components which are essential for the system to work.

Let me continue implementing the ExecuteWorkflow.php job and other key files from the structure:

namespace App\Jobs;

use App\Models\Workflow;
use App\Models\WorkflowExecution;
use App\Services\Workflow\WorkflowEngine;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ExecuteWorkflow implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $workflow;
    protected $input;
    protected $executionId;
    protected $userId;

    /**
     * Create a new job instance.
     */
    public function __construct(Workflow $workflow, array $input = [], ?int $executionId = null, ?int $userId = null)
    {
        $this->workflow = $workflow;
        $this->input = $input;
        $this->executionId = $executionId;
        $this->userId = $userId;
    }

    /**
     * Execute the job.
     */
    public function handle(WorkflowEngine $engine): void
    {
        try {
            // Create an execution record if not provided
            if (!$this->executionId) {
                $execution = WorkflowExecution::create([
                    'workflow_id' => $this->workflow->id,
                    'status' => WorkflowExecution::STATUS_RUNNING,
                    'input' => $this->input,
                    'user_id' => $this->userId,
                    'started_at' => now(),
                ]);
                
                $this->executionId = $execution->id;
            } else {
                $execution = WorkflowExecution::findOrFail($this->executionId);
                
                // Update execution status to running
                $execution->update([
                    'status' => WorkflowExecution::STATUS_RUNNING,
                    'started_at' => now(),
                ]);
            }
            
            // Execute the workflow
            $result = $engine->executeWorkflow($this->workflow, $this->input, $execution);
            
            // Update execution status to completed
            $execution->update([
                'status' => WorkflowExecution::STATUS_COMPLETED,
                'output' => $result,
                'completed_at' => now(),
            ]);
            
            Log::info('Workflow executed successfully', [
                'workflow_id' => $this->workflow->id,
                'execution_id' => $execution->id,
            ]);
        } catch (\Exception $e) {
            Log::error('Workflow execution failed', [
                'workflow_id' => $this->workflow->id,
                'execution_id' => $this->executionId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            // Update execution status to failed
            if (isset($execution)) {
                $execution->update([
                    'status' => WorkflowExecution::STATUS_FAILED,
                    'error' => $e->getMessage(),
                    'completed_at' => now(),
                ]);
            }
            
            // Re-throw the exception for queue to handle
            throw $e;
        }
    }
}

Copy

Apply

app\Jobs\ExecuteWorkflow.php
Now let's implement the ProcessDocument job:

namespace App\Jobs;

use App\Models\KnowledgeDocument;
use App\Services\RAG\DocumentProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ProcessDocument implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $document;
    protected $reprocess;

    /**
     * Create a new job instance.
     */
    public function __construct(KnowledgeDocument $document, bool $reprocess = false)
    {
        $this->document = $document;
        $this->reprocess = $reprocess;
    }

    /**
     * Execute the job.
     */
    public function handle(DocumentProcessor $documentProcessor): void
    {
        try {
            // If the document is already processed and we're not reprocessing, skip
            if ($this->document->is_processed && !$this->reprocess) {
                Log::info('Document already processed, skipping', [
                    'document_id' => $this->document->id,
                ]);
                return;
            }

            // Update document status to processing
            $this->document->update([
                'is_processed' => false,
                'processing_status' => 'processing',
                'processing_started_at' => now(),
            ]);

            // Process the document
            $result = $documentProcessor->processDocument($this->document);

            if ($result) {
                // Update document status to processed
                $this->document->update([
                    'is_processed' => true,
                    'processing_status' => 'completed',
                    'processing_completed_at' => now(),
                    'processing_error' => null,
                ]);

                Log::info('Document processed successfully', [
                    'document_id' => $this->document->id,
                ]);
            } else {
                // Processing failed somehow
                $this->document->update([
                    'is_processed' => false,
                    'processing_status' => 'failed',
                    'processing_completed_at' => now(),
                    'processing_error' => 'Document processing failed',
                ]);

                Log::error('Document processing failed', [
                    'document_id' => $this->document->id,
                ]);
            }
        } catch (\Exception $e) {
            Log::error('Document processing exception', [
                'document_id' => $this->document->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            // Update document status to failed
            $this->document->update([
                'is_processed' => false,
                'processing_status' => 'failed',
                'processing_completed_at' => now(),
                'processing_error' => $e->getMessage(),
            ]);

            // Re-throw the exception for queue to handle
            throw $e;
        }
    }
}

Copy

Apply

app\Jobs\ProcessDocument.php
Now let's implement the ScheduledWorkflow job:

namespace App\Jobs;

use App\Models\Workflow;
use Carbon\Carbon;
use Cron\CronExpression;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ScheduledWorkflow implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        Log::info('Running scheduled workflow check');

        // Get all active scheduled workflows
        $workflows = Workflow::where('is_active', true)
            ->where('trigger_type', 'scheduled')
            ->get();

        foreach ($workflows as $workflow) {
            try {
                // Check if the workflow is due to run based on cron expression
                if ($this->shouldRunWorkflow($workflow)) {
                    Log::info('Scheduling workflow execution', [
                        'workflow_id' => $workflow->id,
                        'name' => $workflow->name,
                    ]);

                    // Dispatch the workflow execution job
                    ExecuteWorkflow::dispatch($workflow, [
                        'scheduled' => true,
                        'scheduled_at' => now()->toIso8601String(),
                    ]);

                    // Update the last scheduled run time
                    $workflow->update([
                        'last_scheduled_run' => now(),
                    ]);
                }
            } catch (\Exception $e) {
                Log::error('Error scheduling workflow', [
                    'workflow_id' => $workflow->id,
                    'error' => $e->getMessage(),
                ]);
            }
        }
    }

    /**
     * Determine if a workflow should run based on its schedule
     */
    protected function shouldRunWorkflow(Workflow $workflow): bool
    {
        // Get the cron expression
        $cronExpression = $this->getCronExpression($workflow);
        
        if (empty($cronExpression)) {
            return false;
        }

        // Parse the cron expression
        $cron = new CronExpression($cronExpression);
        
        // Get the last run time, or use creation time if never run
        $lastRun = $workflow->last_scheduled_run ?? $workflow->created_at;
        
        // Check if it's due to run
        $nextRunDate = Carbon::instance($cron->getNextRunDate($lastRun));
        $now = Carbon::now();
        
        return $nextRunDate->lte($now);
    }

    /**
     * Get the cron expression for a workflow
     */
    protected function getCronExpression(Workflow $workflow): ?string
    {
        // If cron expression is directly specified, use it
        if (!empty($workflow->cron_expression)) {
            return $workflow->cron_expression;
        }

        // Otherwise, convert the frequency to a cron expression
        switch ($workflow->schedule_frequency) {
            case 'minutely':
                return '* * * * *';
            case 'hourly':
                return '0 * * * *';
            case 'daily':
                return '0 0 * * *';
            case 'weekly':
                return '0 0 * * 0';
            case 'monthly':
                return '0 0 1 * *';
            default:
                return null;
        }
    }
}

Copy

Apply

app\Jobs\ScheduledWorkflow.php
Now let's implement the LlphantServiceProvider:

namespace App\Providers;

use App\Services\LLM\OpenAIAdapter;
use App\Services\LLM\PrismAdapter;
use App\Services\RAG\DocumentProcessor;
use App\Services\RAG\EmbeddingService;
use App\Services\RAG\LlphantService;
use App\Services\RAG\VectorStoreService;
use Illuminate\Support\ServiceProvider;
use Llphant\Contracts\ChatModelInterface;
use Llphant\Contracts\VectorStoreInterface;
use Llphant\Llphant;
use Llphant\Models\OpenAIChatModel;
use Llphant\VectorStores\QdrantVectorStore;

class LlphantServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        // Register OpenAI Chat Model
        $this->app->bind(ChatModelInterface::class, function ($app) {
            $model = config('services.openai.chat_model', 'gpt-4o');
            $apiKey = config('services.openai.api_key');
            
            return new OpenAIChatModel($apiKey, $model);
        });

        // Register Qdrant Vector Store
        $this->app->bind(VectorStoreInterface::class, function ($app) {
            $url = config('services.qdrant.url', 'http://localhost:6333');
            $collection = config('services.qdrant.collection', 'documents');
            
            return new QdrantVectorStore($url, $collection);
        });

        // Register Llphant
        $this->app->singleton(Llphant::class, function ($app) {
            return new Llphant(
                $app->make(ChatModelInterface::class)
            );
        });

        // Register RAG Services
        $this->app->singleton(EmbeddingService::class, function ($app) {
            return new EmbeddingService(
                $app->make(OpenAIAdapter::class),
                $app->make(PrismAdapter::class),
                config('services.embeddings.provider', 'openai'),
                config('services.embeddings.model', 'text-embedding-3-small')
            );
        });

        $this->app->singleton(VectorStoreService::class, function ($app) {
            return new VectorStoreService(
                config('services.qdrant.url'),
                config('services.qdrant.collection'),
                config('services.qdrant.api_key')
            );
        });

        $this->app->singleton(LlphantService::class, function ($app) {
            return new LlphantService(
                $app->make(Llphant::class),
                $app->make(VectorStoreInterface::class),
                $app->make(ChatModelInterface::class)
            );
        });

        $this->app->singleton(DocumentProcessor::class, function ($app) {
            return new DocumentProcessor(
                $app->make(EmbeddingService::class),
                $app->make(VectorStoreService::class),
                config('services.rag.chunk_size', 1000),
                config('services.rag.chunk_overlap', 200)
            );
        });
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        // 
    }
}

Copy

Apply

app\Providers\LlphantServiceProvider.php
Let's create a sample migration file:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workflows', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->string('trigger_type')->default('manual');
            $table->string('schedule_frequency')->nullable();
            $table->string('cron_expression')->nullable();
            $table->json('trigger_config')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamp('last_scheduled_run')->nullable();
            $table->foreignId('created_by')->nullable()->constrained('users')->onDelete('set null');
            $table->timestamps();
        });

        Schema::create('workflow_nodes', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->onDelete('cascade');
            $table->string('name');
            $table->string('node_type');
            $table->json('config')->nullable();
            $table->json('position')->nullable();
            $table->string('next_node_id')->nullable();
            $

Copy

Apply

database\migrations\2023_10_01_000001_create_workflows_table.php
│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  migration workflow_table.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 13 new items
I need to continue with the remaining files, focusing on completing the database migration for workflow tables and implementing some of the core Vue components mentioned in the structure.

I'll continue with:

Completing the migration file for workflows that was cut off
Creating the other migration files mentioned in the structure
Implementing WorkflowServiceProvider.php
Creating a Vue component for the workflow builder/canvas
I'll start with completing the migrations.

Let me continue implementing the migrations and other key files from the structure:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workflows', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->string('trigger_type')->default('manual');
            $table->string('schedule_frequency')->nullable();
            $table->string('cron_expression')->nullable();
            $table->json('trigger_config')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamp('last_scheduled_run')->nullable();
            $table->foreignId('created_by')->nullable()->constrained('users')->onDelete('set null');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('workflows');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_workflows_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workflow_nodes', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->onDelete('cascade');
            $table->string('name');
            $table->string('node_type');
            $table->json('config')->nullable();
            $table->json('position')->nullable();
            $table->string('node_id')->unique(); // Unique identifier for frontend
            $table->json('connections')->nullable(); // Store connections to other nodes
            $table->integer('order')->default(0); // For sequential execution
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('workflow_nodes');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_workflow_nodes_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('agent_dynamic_configs', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('model')->default('gpt-4o'); // LLM model to use
            $table->text('system_prompt')->nullable(); // System prompt for the agent
            $table->json('tools')->nullable(); // Available tools
            $table->json('memory_config')->nullable(); // Memory configuration
            $table->json('rag_config')->nullable(); // RAG configuration
            $table->boolean('is_active')->default(true);
            $table->json('metadata')->nullable();
            $table->foreignId('created_by')->nullable()->constrained('users')->onDelete('set null');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('agent_dynamic_configs');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_agent_dynamic_configs_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('knowledge_documents', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->string('file_name');
            $table->string('file_path');
            $table->string('mime_type');
            $table->integer('file_size');
            $table->text('content')->nullable();
            $table->boolean('is_processed')->default(false);
            $table->string('processing_status')->default('pending');
            $table->text('processing_error')->nullable();
            $table->integer('chunks_count')->nullable();
            $table->timestamp('processed_at')->nullable();
            $table->timestamp('processing_started_at')->nullable();
            $table->timestamp('processing_completed_at')->nullable();
            $table->foreignId('created_by')->nullable()->constrained('users')->onDelete('set null');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('knowledge_documents');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_knowledge_documents_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workflow_executions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_id')->constrained()->onDelete('cascade');
            $table->string('status')->default('pending');
            $table->json('input')->nullable();
            $table->json('output')->nullable();
            $table->text('error')->nullable();
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->float('execution_time')->nullable(); // in seconds
            $table->foreignId('user_id')->nullable()->constrained('users')->onDelete('set null');
            $table->string('trigger_source')->nullable(); // webhook, scheduled, manual, etc.
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('workflow_executions');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_workflow_executions_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('execution_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workflow_execution_id')->constrained()->onDelete('cascade');
            $table->foreignId('workflow_node_id')->nullable()->constrained()->onDelete('cascade');
            $table->string('status');
            $table->json('input')->nullable();
            $table->json('output')->nullable();
            $table->text('error')->nullable();
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->float('execution_time')->nullable(); // in seconds
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('execution_logs');
    }
};

Copy

Apply

database\migrations\2023_xx_xx_create_execution_logs_table.php
Now let's implement the WorkflowServiceProvider:

<?php

namespace App\Providers;

use App\Services\Workflow\NodeRegistry;
use App\Services\Workflow\NodeTypes\AgentNode;
use App\Services\Workflow\NodeTypes\ConditionNode;
use App\Services\Workflow\NodeTypes\HttpNode;
use App\Services\Workflow\NodeTypes\ReturnNode;
use App\Services\Workflow\NodeTypes\SchedulerNode;
use App\Services\Workflow\NodeTypes\TransformNode;
use App\Services\Workflow\NodeTypes\WebhookNode;
use App\Services\Workflow\VariableResolver;
use App\Services\Workflow\WorkflowEngine;
use Illuminate\Support\ServiceProvider;

class WorkflowServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        // Register workflow components
        $this->app->singleton(NodeRegistry::class, function ($app) {
            $registry = new NodeRegistry();
            
            // Register core node types
            $registry->registerNodeType('webhook', WebhookNode::class);
            $registry->registerNodeType('http', HttpNode::class);
            $registry->registerNodeType('agent', AgentNode::class);
            $registry->registerNodeType('condition', ConditionNode::class);
            $registry->registerNodeType('transform', TransformNode::class);
            $registry->registerNodeType('scheduler', SchedulerNode::class);
            $registry->registerNodeType('return', ReturnNode::class);
            
            return $registry;
        });
        
        $this->app->singleton(VariableResolver::class, function ($app) {
            return new VariableResolver();
        });
        
        $this->app->singleton(WorkflowEngine::class, function ($app) {
            return new WorkflowEngine(
                $app->make(NodeRegistry::class),
                $app->make(VariableResolver::class)
            );
        });
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        //
    }
}

Copy

Apply

app\Providers\WorkflowServiceProvider.php
Now let's create the Visual Workflow Builder Vue component:

<template>
  <div class="workflow-builder-canvas">
    <div class="workflow-actions bg-gray-100 p-4 border-b">
      <div class="flex justify-between items-center">
        <div>
          <h2 class="text-xl font-bold">{{ workflow.name }}</h2>
          <p class="text-sm text-gray-600">{{ workflow.description }}</p>
        </div>
        <div class="flex space-x-2">
          <button @click="saveWorkflow" 
            class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">
            <span v-if="saving">Saving...</span>
            <span v-else>Save</span>
          </button>
          <button @click="testWorkflow" 
            class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
            Test Workflow
          </button>
        </div>
      </div>
    </div>
    
    <div class="flex h-[calc(100vh-10rem)]">
      <NodeList @add-node="addNode" class="w-64 bg-gray-50 border-r p-4 overflow-y-auto" />
      
      <div ref="canvasContainer" class="flex-1 overflow-hidden relative">
        <div class="workflow-canvas h-full w-full overflow-auto"
             @dragover.prevent 
             @drop="onDropNode">
          <svg ref="connectionsSvg" class="connections-layer absolute top-0 left-0 pointer-events-none">
            <!-- Connections will be rendered here -->
          </svg>
          
          <div v-for="node in nodes" :key="node.id" 
               class="absolute transition-all duration-100"
               :style="{ 
                 top: `${node.position.y}px`, 
                 left: `${node.position.x}px` 
               }"
               @mousedown="startDragNode($event, node)">
            <NodeCard 
              :node="node" 
              :selected="selectedNode && selectedNode.id === node.id"
              @select="selectNode"
              @connect="startConnection"
              @disconnect="removeConnection" />
          </div>
        </div>
      </div>
      
      <NodeConfig 
        v-if="selectedNode" 
        :node="selectedNode" 
        @update="updateNodeConfig"
        @close="deselectNode"
        class="w-96 bg-gray-50 border-l p-4 overflow-y-auto" />
    </div>
    
    <div class="workflow-status bg-gray-100 p-4 border-t">
      <div v-if="lastSaved" class="text-sm text-gray-600">
        Last saved: {{ new Date(lastSaved).toLocaleString() }}
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onBeforeUnmount, nextTick } from 'vue';
import { useToast } from '@/Composables/useToast';
import NodeList from './NodeList.vue';
import NodeCard from './NodeCard.vue';
import NodeConfig from './NodeConfig.vue';

export default {
  components: {
    NodeList,
    NodeCard,
    NodeConfig
  },
  
  props: {
    workflow: {
      type: Object,
      required: true
    }
  },
  
  setup(props) {
    const { showToast } = useToast();
    const canvasContainer = ref(null);
    const connectionsSvg = ref(null);
    const nodes = ref([]);
    const connections = ref([]);
    const selectedNode = ref(null);
    const currentConnection = ref(null);
    const isDragging = ref(false);
    const draggedNode = ref(null);
    const dragStartPos = ref({ x: 0, y: 0 });
    const dragNodeOffset = ref({ x: 0, y: 0 });
    const saving = ref(false);
    const lastSaved = ref(null);
    
    // Load workflow data
    onMounted(async () => {
      try {
        const response = await axios.get(`/api/workflows/${props.workflow.id}/nodes`);
        nodes.value = response.data.nodes.map(node => ({
          ...node,
          position: node.position || { x: 100, y: 100 }
        }));
        connections.value = response.data.connections || [];
        nextTick(() => {
          drawConnections();
        });
      } catch (error) {
        console.error('Error loading workflow:', error);
        showToast('Error loading workflow nodes', 'error');
      }
    });
    
    // Set up event listeners for canvas dragging
    onMounted(() => {
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      
      // Set SVG dimensions
      updateSvgSize();
      window.addEventListener('resize', updateSvgSize);
    });
    
    onBeforeUnmount(() => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
      window.removeEventListener('resize', updateSvgSize);
    });
    
    // Methods

Copy

Apply

resources\js\Components\Workflow\Builder\Canvas.vue
    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for the last file and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 15 new items
I'll continue implementing the remaining Vue components from the structure, focusing on the NodeList component which is a key part of the workflow builder interface, and also a few node-specific components. Let me focus on:

NodeList.vue - shows available nodes that can be dragged onto the canvas
NodeConfig.vue - for configuring a selected node
A sample node component (AgentNode.vue) - specific implementation for the Agent node
ChatInterface.vue - UI for the streaming chat interface
These components will showcase various aspects of the system's functionality.

Let me continue implementing the remaining Vue components from the structure:

<template>
  <div class="node-list">
    <h3 class="font-semibold text-lg mb-4">Available Nodes</h3>
    
    <div class="mb-4">
      <input
        type="text"
        placeholder="Search nodes..."
        v-model="searchQuery"
        class="w-full px-3 py-2 border rounded-md text-sm"
      />
    </div>
    
    <div class="categories space-y-4">
      <div v-for="(category, index) in categories" :key="index" class="category">
        <h4 
          @click="toggleCategory(category.name)"
          class="font-medium text-sm uppercase tracking-wider mb-2 cursor-pointer flex items-center"
        >
          <svg 
            :class="{'transform rotate-90': expandedCategories[category.name]}"
            class="w-4 h-4 mr-1 transition-transform" 
            fill="none" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
          >
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
          {{ category.name }}
        </h4>
        
        <div 
          v-if="expandedCategories[category.name]"
          class="grid gap-2 transition-all duration-300"
        >
          <div 
            v-for="node in filteredNodes.filter(n => n.category === category.name)" 
            :key="node.type"
            draggable="true"
            @dragstart="onDragStart($event, node)"
            class="node-item bg-white p-3 rounded border shadow-sm cursor-move hover:shadow-md transition-shadow"
          >
            <div class="flex items-center">
              <div 
                class="node-icon w-8 h-8 rounded-md flex items-center justify-center mr-3"
                :style="{ backgroundColor: node.color + '20', color: node.color }"
              >
                <i :class="node.icon"></i>
              </div>
              <div>
                <div class="font-medium text-sm">{{ node.label }}</div>
                <div class="text-xs text-gray-500">{{ node.description }}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="mt-6 pt-4 border-t">
      <a href="#" class="text-blue-600 text-sm hover:text-blue-800" @click.prevent="showDocs">
        View Documentation
      </a>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted } from 'vue';

export default {
  emits: ['add-node'],
  
  setup(_, { emit }) {
    const searchQuery = ref('');
    const expandedCategories = ref({});
    
    // Node definitions
    const nodes = ref([
      // Trigger nodes
      {
        type: 'webhook',
        label: 'Webhook',
        description: 'Trigger workflow via HTTP webhook',
        category: 'Triggers',
        color: '#4f46e5',
        icon: 'fas fa-bolt',
        defaultConfig: {
          path: '',
          method: 'POST',
          requireAuth: true
        }
      },
      {
        type: 'scheduler',
        label: 'Scheduler',
        description: 'Schedule workflow execution',
        category: 'Triggers',
        color: '#4f46e5',
        icon: 'fas fa-clock',
        defaultConfig: {
          frequency: 'daily',
          time: '00:00',
          cronExpression: ''
        }
      },
      
      // Action nodes
      {
        type: 'http',
        label: 'HTTP Request',
        description: 'Make HTTP requests to external APIs',
        category: 'Actions',
        color: '#06b6d4',
        icon: 'fas fa-globe',
        defaultConfig: {
          url: '',
          method: 'GET',
          headers: {},
          body: '',
          timeout: 30
        }
      },
      {
        type: 'agent',
        label: 'AI Agent',
        description: 'Use AI agent to process data',
        category: 'Actions',
        color: '#06b6d4',
        icon: 'fas fa-robot',
        defaultConfig: {
          agentId: null,
          input: '',
          systemPrompt: '',
          temperature: 0.7
        }
      },
      {
        type: 'transform',
        label: 'Transform',
        description: 'Transform data using JavaScript',
        category: 'Actions',
        color: '#06b6d4',
        icon: 'fas fa-code',
        defaultConfig: {
          code: 'function transform(data) {\n  // Transform data here\n  return data;\n}'
        }
      },
      
      // Flow control
      {
        type: 'condition',
        label: 'Condition',
        description: 'Branch workflow based on conditions',
        category: 'Flow',
        color: '#f97316',
        icon: 'fas fa-code-branch',
        defaultConfig: {
          conditions: [
            { expression: '', result: null }
          ],
          defaultResult: null
        }
      },
      {
        type: 'return',
        label: 'Return',
        description: 'End workflow and return data',
        category: 'Flow',
        color: '#f97316',
        icon: 'fas fa-flag-checkered',
        defaultConfig: {
          data: ''
        }
      }
    ]);
    
    // Define categories
    const categories = ref([
      { name: 'Triggers', order: 1 },
      { name: 'Actions', order: 2 },
      { name: 'Flow', order: 3 }
    ]);
    
    // Automatically expand all categories by default
    onMounted(() => {
      categories.value.forEach(category => {
        expandedCategories.value[category.name] = true;
      });
    });
    
    // Filter nodes based on search query
    const filteredNodes = computed(() => {
      if (!searchQuery.value) return nodes.value;
      
      const query = searchQuery.value.toLowerCase();
      return nodes.value.filter(node => 
        node.label.toLowerCase().includes(query) || 
        node.description.toLowerCase().includes(query)
      );
    });
    
    // Toggle category expansion
    const toggleCategory = (categoryName) => {
      expandedCategories.value[categoryName] = !expandedCategories.value[categoryName];
    };
    
    // Handle drag start
    const onDragStart = (event, node) => {
      // Set drag data
      event.dataTransfer.setData('application/json', JSON.stringify({
        type: node.type,
        label: node.label,
        color: node.color,
        config: node.defaultConfig
      }));
      
      // Set drag effect
      event.dataTransfer.effectAllowed = 'copy';
    };
    
    // Show documentation
    const showDocs = () => {
      window.open('/docs/workflow-nodes', '_blank');
    };
    
    return {
      searchQuery,
      nodes,
      categories,
      expandedCategories,
      filteredNodes,
      toggleCategory,
      onDragStart,
      showDocs
    };
  }
};
</script>

Copy

Apply

resources\js\Components\Workflow\Builder\NodeList.vue
Now let's implement the NodeConfig component:

<template>
  <div class="node-config p-4">
    <div class="flex justify-between items-center mb-4">
      <h3 class="font-semibold text-lg">Configure Node</h3>
      <button @click="$emit('close')" class="text-gray-500 hover:text-gray-700">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
    
    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1">Node Name</label>
      <input 
        type="text" 
        v-model="form.name" 
        class="w-full px-3 py-2 border rounded-md"
        @change="updateNode"
      />
    </div>
    
    <!-- Specific node configuration based on type -->
    <component 
      :is="nodeConfigComponent" 
      v-if="nodeConfigComponent"
      :node="node"
      :config="form.config"
      @update="updateNodeConfig"
    />
    
    <div class="mt-6 pt-4 border-t">
      <button 
        @click="deleteNode" 
        class="px-3 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition"
      >
        Delete Node
      </button>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted, watch } from 'vue';
import { useToast } from '@/Composables/useToast';

// Import node-specific config components
import WebhookNodeConfig from '../Nodes/WebhookNode.vue';
import HttpNodeConfig from '../Nodes/HttpNode.vue';
import AgentNodeConfig from '../Nodes/AgentNode.vue';
import ConditionNodeConfig from '../Nodes/ConditionNode.vue';
import TransformNodeConfig from '../Nodes/TransformNode.vue';
import SchedulerNodeConfig from '../Nodes/SchedulerNode.vue';
import ReturnNodeConfig from '../Nodes/ReturnNode.vue';

export default {
  components: {
    WebhookNodeConfig,
    HttpNodeConfig,
    AgentNodeConfig,
    ConditionNodeConfig,
    TransformNodeConfig,
    SchedulerNodeConfig,
    ReturnNodeConfig
  },
  
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  
  emits: ['update', 'close'],
  
  setup(props, { emit }) {
    const { showToast } = useToast();
    
    // Create a local copy of the node data for editing
    const form = ref({
      name: props.node.name,
      config: { ...props.node.config }
    });
    
    // Map node types to their configuration components
    const nodeConfigComponent = computed(() => {
      const componentMap = {
        webhook: 'WebhookNodeConfig',
        http: 'HttpNodeConfig',
        agent: 'AgentNodeConfig',
        condition: 'ConditionNodeConfig',
        transform: 'TransformNodeConfig',
        scheduler: 'SchedulerNodeConfig',
        return: 'ReturnNodeConfig'
      };
      
      return componentMap[props.node.type] || null;
    });
    
    // Watch for changes in the node prop
    watch(
      () => props.node,
      (newNode) => {
        form.value = {
          name: newNode.name,
          config: { ...newNode.config }
        };
      },
      { deep: true }
    );
    
    // Update node
    const updateNode = () => {
      emit('update', {
        ...props.node,
        name: form.value.name,
        config: form.value.config
      });
    };
    
    // Update specific node configuration
    const updateNodeConfig = (newConfig) => {
      form.value.config = { ...newConfig };
      updateNode();
    };
    
    // Delete node
    const deleteNode = () => {
      if (confirm('Are you sure you want to delete this node?')) {
        emit('update', { ...props.node, _delete: true });
        emit('close');
      }
    };
    
    return {
      form,
      nodeConfigComponent,
      updateNode,
      updateNodeConfig,
      deleteNode
    };
  }
};
</script>

Copy

Apply

resources\js\Components\Workflow\Builder\NodeConfig.vue
Let's implement the AgentNode component for configuring AI agent nodes:

<template>
  <div class="agent-node-config">
    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1">
        Agent Configuration
      </label>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Select Agent
        </label>
        <select 
          v-model="localConfig.agentId" 
          class="w-full px-3 py-2 border rounded-md bg-white"
          @change="updateConfig"
        >
          <option value="" disabled>Select an agent</option>
          <option v-for="agent in agents" :key="agent.id" :value="agent.id">
            {{ agent.name }}
          </option>
        </select>
        <div v-if="!localConfig.agentId" class="mt-1 text-xs text-red-500">
          An agent is required
        </div>
        <div v-else class="mt-1 flex justify-end">
          <button 
            @click="editAgent" 
            class="text-xs text-blue-600 hover:text-blue-800"
          >
            Edit Agent
          </button>
        </div>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Input Template
        </label>
        <textarea 
          v-model="localConfig.input" 
          rows="3"
          placeholder="Enter input or use {{variables}} for dynamic values"
          class="w-full px-3 py-2 border rounded-md font-mono text-sm"
          @change="updateConfig"
        ></textarea>
        <div class="mt-1 text-xs text-gray-500">
          Use double curly braces to reference workflow variables
        </div>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Override System Prompt (Optional)
        </label>
        <textarea 
          v-model="localConfig.systemPrompt" 
          rows="4"
          placeholder="Leave empty to use the agent's default system prompt"
          class="w-full px-3 py-2 border rounded-md font-mono text-sm"
          @

Copy

Apply

resources\js\Components\Workflow\Nodes\AgentNode.vue
└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  AgentNode.vue and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 vue 




Context
— 13 new items
Let me continue implementing the AgentNode.vue which seems to have been cut off mid-implementation. I'll also create some additional Vue components from the structure:

Complete the AgentNode.vue component
Create the ChatInterface.vue component for streaming chat UI
Create the Workflows/Builder.vue page component that will use the Canvas and other workflow builder components
These should be good representations of the key functionalities of the workflow system.

Let me continue implementing the AgentNode.vue component and other important components from the structure:

<template>
  <div class="agent-node-config">
    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1">
        Agent Configuration
      </label>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Select Agent
        </label>
        <select 
          v-model="localConfig.agentId" 
          class="w-full px-3 py-2 border rounded-md bg-white"
          @change="updateConfig"
        >
          <option value="" disabled>Select an agent</option>
          <option v-for="agent in agents" :key="agent.id" :value="agent.id">
            {{ agent.name }}
          </option>
        </select>
        <div v-if="!localConfig.agentId" class="mt-1 text-xs text-red-500">
          An agent is required
        </div>
        <div v-else class="mt-1 flex justify-end">
          <button 
            @click="editAgent" 
            class="text-xs text-blue-600 hover:text-blue-800"
          >
            Edit Agent
          </button>
        </div>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Input Template
        </label>
        <textarea 
          v-model="localConfig.input" 
          rows="3"
          placeholder="Enter input or use {{variables}} for dynamic values"
          class="w-full px-3 py-2 border rounded-md font-mono text-sm"
          @change="updateConfig"
        ></textarea>
        <div class="mt-1 text-xs text-gray-500">
          Use double curly braces to reference workflow variables
        </div>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Override System Prompt (Optional)
        </label>
        <textarea 
          v-model="localConfig.systemPrompt" 
          rows="4"
          placeholder="Leave empty to use the agent's default system prompt"
          class="w-full px-3 py-2 border rounded-md font-mono text-sm"
          @change="updateConfig"
        ></textarea>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Temperature
        </label>
        <div class="flex items-center">
          <input 
            type="range" 
            v-model.number="localConfig.temperature" 
            min="0" 
            max="2" 
            step="0.1"
            class="w-full mr-2"
            @change="updateConfig"
          />
          <span class="text-sm w-12 text-right">{{ localConfig.temperature }}</span>
        </div>
        <div class="mt-1 text-xs text-gray-500">
          Lower values produce more focused, deterministic responses
        </div>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-600 mb-1">
          Use RAG Knowledge
        </label>
        <div class="flex items-center">
          <input 
            type="checkbox" 
            v-model="localConfig.useRag" 
            class="mr-2 h-4 w-4"
            @change="updateConfig"
          />
          <span class="text-sm">Enable retrieval augmented generation</span>
        </div>
      </div>
      
      <div v-if="localConfig.useRag" class="mb-4 ml-6 p-3 border-l-2 border-blue-200">
        <div class="mb-3">
          <label class="block text-sm font-medium text-gray-600 mb-1">
            Search Query Template
          </label>
          <textarea 
            v-model="localConfig.ragConfig.searchQuery" 
            rows="2"
            placeholder="Enter search query or use {{variables}}"
            class="w-full px-3 py-2 border rounded-md font-mono text-sm"
            @change="updateConfig"
          ></textarea>
        </div>
        
        <div class="mb-3">
          <label class="block text-sm font-medium text-gray-600 mb-1">
            Number of Results
          </label>
          <input 
            type="number" 
            v-model.number="localConfig.ragConfig.numResults" 
            min="1" 
            max="20"
            class="w-full px-3 py-2 border rounded-md"
            @change="updateConfig"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, reactive, computed, watch, onMounted } from 'vue';
import { useToast } from '@/Composables/useToast';
import { useRouter } from 'vue-router';

export default {
  props: {
    node: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    }
  },
  
  emits: ['update'],
  
  setup(props, { emit }) {
    const { showToast } = useToast();
    const router = useRouter();
    
    // Set default config values
    const defaultConfig = {
      agentId: '',
      input: '',
      systemPrompt: '',
      temperature: 0.7,
      useRag: false,
      ragConfig: {
        searchQuery: '',
        numResults: 5
      }
    };
    
    // Merge with existing config
    const localConfig = reactive({
      ...defaultConfig,
      ...props.config,
      ragConfig: {
        ...defaultConfig.ragConfig,
        ...(props.config.ragConfig || {})
      }
    });
    
    // Available agents
    const agents = ref([]);
    
    // Fetch available agents
    onMounted(async () => {
      try {
        const response = await axios.get('/api/agents');
        agents.value = response.data;
      } catch (error) {
        console.error('Error fetching agents:', error);
        showToast('Failed to load agents', 'error');
      }
    });
    
    // Update config
    const updateConfig = () => {
      emit('update', { ...localConfig });
    };
    
    // Edit agent
    const editAgent = () => {
      if (localConfig.agentId) {
        router.push({ name: 'agents.edit', params: { id: localConfig.agentId } });
      }
    };
    
    // Watch for external config changes
    watch(
      () => props.config,
      (newConfig) => {
        Object.assign(localConfig, {
          ...defaultConfig,
          ...newConfig,
          ragConfig: {
            ...defaultConfig.ragConfig,
            ...(newConfig.ragConfig || {})
          }
        });
      },
      { deep: true }
    );
    
    return {
      localConfig,
      agents,
      updateConfig,
      editAgent
    };
  }
};
</script>

Copy

Apply

resources\js\Components\Workflow\Nodes\AgentNode.vue
Now let's implement the ChatInterface component for streaming chat:

<template>
  <div class="chat-interface flex flex-col h-full">
    <!-- Chat messages -->
    <div 
      ref="messagesContainer"
      class="flex-1 overflow-y-auto p-4 space-y-4"
      :class="{ 'bg-gray-50': theme === 'light', 'bg-gray-900': theme === 'dark' }"
    >
      <!-- Welcome message -->
      <div v-if="messages.length === 0" class="text-center my-8">
        <div class="text-gray-500">
          <div class="mb-3">
            <svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M8 14C8 14 9.5 16 12 16C14.5 16 16 14 16 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M9 9H9.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M15 9H15.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <p class="text-lg font-medium">How can I assist you today?</p>
          <p class="mt-1">Send a message to start a conversation</p>
        </div>
        
        <div v-if="suggestedPrompts.length > 0" class="mt-6 flex flex-wrap justify-center gap-2">
          <button 
            v-for="(prompt, i) in suggestedPrompts" 
            :key="i"
            @click="sendMessage(prompt)"
            class="px-3 py-2 text-sm border rounded-full text-left hover:bg-blue-50 transition-colors"
            :class="{ 
              'bg-white text-gray-700 border-gray-200': theme === 'light',
              'bg-gray-800 text-gray-200 border-gray-700': theme === 'dark'
            }"
          >
            {{ prompt }}
          </button>
        </div>
      </div>
      
      <!-- Chat message bubbles -->
      <div 
        v-for="(message, index) in messages" 
        :key="index"
        class="message-bubble flex"
        :class="message.role === 'user' ? 'justify-end' : 'justify-start'"
      >
        <div 
          class="max-w-3xl rounded-lg px-4 py-2"
          :class="messageClasses(message)"
        >
          <div class="font-medium text-xs mb-1" :class="message.role === 'user' ? 'text-right' : ''">
            {{ message.role === 'user' ? 'You' : agentName }}
          </div>
          <div v-if="message.role === 'assistant' && message.isLoading" class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div v-else v-html="formatMessage(message.content)"></div>
          
          <!-- Message timestamp and actions -->
          <div class="mt-1 flex items-center justify-between text-xs">
            <span class="text-gray-500">{{ formatTime(message.timestamp) }}</span>
            <div class="space-x-2" v-if="message.role === 'assistant' && !message.isLoading">
              <button 
                @click="copyToClipboard(message.content)" 
                title="Copy to clipboard"
                class="text-gray-400 hover:text-gray-600"
              >
                <i class="fas fa-copy"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Citation section -->
      <div 
        v-if="citations.length > 0"
        class="p-3 rounded-lg mt-4"
        :class="{ 
          'bg-gray-100 border border-gray-200': theme === 'light',
          'bg-gray-800 border border-gray-700': theme === 'dark'
        }"
      >
        <div class="font-medium text-sm mb-2">Sources</div>
        <div class="space-y-2">
          <div 
            v-for="(citation, i) in citations" 
            :key="i"
            class="text-sm flex"
          >
            <span class="mr-2">[{{ i + 1 }}]</span>
            <div>
              <div class="font-medium">{{ citation.title }}</div>
              <div class="text-xs text-gray-500">{{ citation.source }}</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Input area -->
    <div 
      class="p-4 border-t"
      :class="{ 
        'bg-white border-gray-200': theme === 'light',
        'bg-gray-800 border-gray-700': theme === 'dark'
      }"
    >
      <form @submit.prevent="sendMessage" class="flex">
        <textarea
          ref="inputField"
          v-model="userInput"
          rows="1"
          :disabled="isProcessing"
          placeholder="Type your message..."
          class="flex-1 resize-none px-3 py-2 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          :class="{ 
            'bg-white border-gray-300': theme === 'light',
            'bg-gray-700 border-gray-600 text-white': theme === 'dark'
          }"
          @keydown.enter.exact.prevent="sendMessage"
          @input="autoGrow"
        ></textarea>
        <button 
          type="submit" 
          :disabled="isProcessing || !userInput.trim()"
          class="px-4 rounded-r-lg flex items-center justify-center"
          :class="isProcessing || !userInput.trim() 
            ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
            : 'bg-blue-600 text-white hover:bg-blue-700'"
        >
          <i class="fas fa-paper-plane"></i>
        </button>
      </form>
      
      <div v-if="isProcessing" class="mt-2 text-xs text-center text-gray-500">
        Processing message...
      </div>
    </div>
  </div>
</template>

<script>
import { ref, reactive, onMounted, nextTick, watch, computed } from 'vue';
import { useToast } from '@/Composables/useToast';
import { marked } from 'marked';
import DOMP

Copy

Apply

resources\js\Components\Agent\ChatInterface.vue
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  ChatInterface.vue  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
I need to complete the ChatInterface.vue component, which was cut off, and then add other key files from the structure. I'll focus on:

Completing the ChatInterface.vue
Creating the OpenAIAdapter.php service for LLM integration
Implementing the DocumentUploader.vue component for knowledge management
Creating the WorkflowBuilder.php for Filament (admin panel)
These components cover various important aspects of the system.

Let me complete the ChatInterface.vue component and continue with other key files:

<template>
  <div class="chat-interface flex flex-col h-full">
    <!-- Chat messages -->
    <div 
      ref="messagesContainer"
      class="flex-1 overflow-y-auto p-4 space-y-4"
      :class="{ 'bg-gray-50': theme === 'light', 'bg-gray-900': theme === 'dark' }"
    >
      <!-- Welcome message -->
      <div v-if="messages.length === 0" class="text-center my-8">
        <div class="text-gray-500">
          <div class="mb-3">
            <svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M8 14C8 14 9.5 16 12 16C14.5 16 16 14 16 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M9 9H9.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M15 9H15.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <p class="text-lg font-medium">How can I assist you today?</p>
          <p class="mt-1">Send a message to start a conversation</p>
        </div>
        
        <div v-if="suggestedPrompts.length > 0" class="mt-6 flex flex-wrap justify-center gap-2">
          <button 
            v-for="(prompt, i) in suggestedPrompts" 
            :key="i"
            @click="sendMessage(prompt)"
            class="px-3 py-2 text-sm border rounded-full text-left hover:bg-blue-50 transition-colors"
            :class="{ 
              'bg-white text-gray-700 border-gray-200': theme === 'light',
              'bg-gray-800 text-gray-200 border-gray-700': theme === 'dark'
            }"
          >
            {{ prompt }}
          </button>
        </div>
      </div>
      
      <!-- Chat message bubbles -->
      <div 
        v-for="(message, index) in messages" 
        :key="index"
        class="message-bubble flex"
        :class="message.role === 'user' ? 'justify-end' : 'justify-start'"
      >
        <div 
          class="max-w-3xl rounded-lg px-4 py-2"
          :class="messageClasses(message)"
        >
          <div class="font-medium text-xs mb-1" :class="message.role === 'user' ? 'text-right' : ''">
            {{ message.role === 'user' ? 'You' : agentName }}
          </div>
          <div v-if="message.role === 'assistant' && message.isLoading" class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div v-else v-html="formatMessage(message.content)"></div>
          
          <!-- Message timestamp and actions -->
          <div class="mt-1 flex items-center justify-between text-xs">
            <span class="text-gray-500">{{ formatTime(message.timestamp) }}</span>
            <div class="space-x-2" v-if="message.role === 'assistant' && !message.isLoading">
              <button 
                @click="copyToClipboard(message.content)" 
                title="Copy to clipboard"
                class="text-gray-400 hover:text-gray-600"
              >
                <i class="fas fa-copy"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Citation section -->
      <div 
        v-if="citations.length > 0"
        class="p-3 rounded-lg mt-4"
        :class="{ 
          'bg-gray-100 border border-gray-200': theme === 'light',
          'bg-gray-800 border border-gray-700': theme === 'dark'
        }"
      >
        <div class="font-medium text-sm mb-2">Sources</div>
        <div class="space-y-2">
          <div 
            v-for="(citation, i) in citations" 
            :key="i"
            class="text-sm flex"
          >
            <span class="mr-2">[{{ i + 1 }}]</span>
            <div>
              <div class="font-medium">{{ citation.title }}</div>
              <div class="text-xs text-gray-500">{{ citation.source }}</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Input area -->
    <div 
      class="p-4 border-t"
      :class="{ 
        'bg-white border-gray-200': theme === 'light',
        'bg-gray-800 border-gray-700': theme === 'dark'
      }"
    >
      <form @submit.prevent="sendMessage" class="flex">
        <textarea
          ref="inputField"
          v-model="userInput"
          rows="1"
          :disabled="isProcessing"
          placeholder="Type your message..."
          class="flex-1 resize-none px-3 py-2 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          :class="{ 
            'bg-white border-gray-300': theme === 'light',
            'bg-gray-700 border-gray-600 text-white': theme === 'dark'
          }"
          @keydown.enter.exact.prevent="sendMessage"
          @input="autoGrow"
        ></textarea>
        <button 
          type="submit" 
          :disabled="isProcessing || !userInput.trim()"
          class="px-4 rounded-r-lg flex items-center justify-center"
          :class="isProcessing || !userInput.trim() 
            ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
            : 'bg-blue-600 text-white hover:bg-blue-700'"
        >
          <i class="fas fa-paper-plane"></i>
        </button>
      </form>
      
      <div v-if="isProcessing" class="mt-2 text-xs text-center text-gray-500">
        Processing message...
      </div>
    </div>
  </div>
</template>

<script>
import { ref, reactive, onMounted, nextTick, watch, computed } from 'vue';
import { useToast } from '@/Composables/useToast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import hljs from 'highlight.js';

export default {
  props: {
    agentId: {
      type: [Number, String],
      required: true
    },
    agentName: {
      type: String,
      default: 'Assistant'
    },
    initialMessages: {
      type: Array,
      default: () => []
    },
    suggestedPrompts: {
      type: Array,
      default: () => []
    },
    theme: {
      type: String,
      default: 'light',
      validator: (value) => ['light', 'dark'].includes(value)
    }
  },
  
  emits: ['message-sent', 'message-received'],
  
  setup(props, { emit }) {
    const { showToast } = useToast();
    const messagesContainer = ref(null);
    const inputField = ref(null);
    const userInput = ref('');
    const isProcessing = ref(false);
    const messages = ref([...props.initialMessages]);
    const citations = ref([]);
    
    // Configure markdown renderer
    marked.setOptions({
      highlight: function(code, lang) {
        const language = hljs.getLanguage(lang) ? lang : 'plaintext';
        return hljs.highlight(code, { language }).value;
      },
      breaks: true,
      gfm: true
    });
    
    // Format message content with markdown
    const formatMessage = (content) => {
      if (!content) return '';
      const html = marked.parse(content);
      return DOMPurify.sanitize(html);
    };
    
    // Format time for message timestamp
    const formatTime = (timestamp) => {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };
    
    // Dynamic classes for message bubbles
    const messageClasses = (message) => {
      if (message.role === 'user') {
        return theme.value === 'light' 
          ? 'bg-blue-100 text-blue-900' 
          : 'bg-blue-900 text-blue-100';
      } else {
        return theme.value === 'light'
          ? 'bg-white border border-gray-200 text-gray-900'
          : 'bg-gray-800 border border-gray-700 text-gray-100';
      }
    };
    
    // Auto-grow textarea based on content
    const autoGrow = () => {
      if (!inputField.value) return;
      
      inputField.value.style.height = '42px'; // Reset height
      const scrollHeight = inputField.value.scrollHeight;
      inputField.value.style.height = `${Math.min(scrollHeight, 150)}px`; // Limit to 150px height
    };
    
    // Scroll to bottom of messages container
    const scrollToBottom = () => {
      nextTick(() => {
        if (messagesContainer.value) {
          messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
        }
      });
    };
    
    // Copy message to clipboard
    const copyToClipboard = async (text) => {
      try {
        await navigator.clipboard.writeText(text);
        showToast('Copied to clipboard', 'success');
      } catch (err) {
        showToast('Failed to copy', 'error');
        console.error('Failed to copy text: ', err);
      }
    };
    
    // Send user message and get AI response
    const sendMessage = async (text = null) => {
      const messageContent = text || userInput.value.trim();
      
      if (!messageContent || isProcessing.value) return;
      
      // Add user message to chat
      const userMessage = {
        role: 'user',
        content: messageContent,
        timestamp: new Date()
      };
      
      messages.value.push(userMessage);
      emit('message-sent', userMessage);
      
      // Clear input
      userInput.value = '';
      autoGrow();
      scrollToBottom();
      
      // Add loading message for assistant
      const assistantMessage = {
        role: 'assistant',
        content: '',
        isLoading: true,
        timestamp: new Date()
      };
      
      messages.value.push(assistantMessage);
      scrollToBottom();
      
      // Start processing
      isProcessing.value = true;
      
      try {
        // Setup SSE for streaming response
        const source = new EventSource(`/api/agents/${props.agentId}/chat?message=${encodeURIComponent(messageContent)}`);
        
        source.onmessage = (event) => {
          const data = JSON.parse(event.data);
          
          if (data.type === 'token') {
            // Append token to the message
            const lastIndex = messages.value.length - 1;
            if (lastIndex >= 0) {
              messages.value[lastIndex].content += data.content;
              messages.value[lastIndex].isLoading = false;
            }
            scrollToBottom();
          } else if (data.type === 'citations') {
            // Set citations if provided
            citations.value = data.citations || [];
          } else if (data.type === 'end') {
            // Processing complete
            source.close();
            isProcessing.value = false;
            
            // Emit the completed message
            const completedMessage = { ...messages.value[messages.value.length - 1] };
            emit('message-received', completedMessage);
          }
        };
        
        source.onerror = (error) => {
          console.error('SSE Error:', error);
          source.close();
          isProcessing.value = false;
          
          // Update last message to show error
          const lastIndex = messages.value.length - 1;
          if (lastIndex >= 0) {
            messages.value[lastIndex].content = 'Sorry, an error occurred while processing your request. Please try again.';
            messages.value[lastIndex].isLoading = false;
            messages.value[lastIndex].error = true;
          }
          
          showToast('Error connecting to the agent', 'error');
          scrollToBottom();
        };
      } catch (error) {
        console.error('Chat error:', error);
        isProcessing.value = false;
        
        // Update last message to show error
        const lastIndex = messages.value.length - 1;
        if (lastIndex >= 0) {
          messages.value[lastIndex].content = 'Sorry, an error occurred while processing your request. Please try again.';
          messages.value[lastIndex].isLoading = false;
          messages.value[lastIndex].error = true;
        }
        
        showToast('Failed to send message', 'error');
        scrollToBottom();
      }
    };
    
    // Focus input field when component mounts
    onMounted(() => {
      if (inputField.value) {
        inputField.value.focus();
      }
      scrollToBottom();
    });
    
    // Watch for theme changes
    const theme = computed(() => props.theme);
    
    return {
      messagesContainer,
      inputField,
      userInput,
      isProcessing,
      messages,
      citations,
      formatMessage,
      formatTime,
      messageClasses,
      autoGrow,
      sendMessage,
      copyToClipboard,
      theme
    };
  }
};
</script>

<style scoped>
.typing-indicator {
  display: flex;

Copy

Apply

resources\js\Components\Agent\ChatInterface.vue
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  ChatInterface.vue  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with key files from the structure. I'll focus on:

Completing the ChatInterface.vue that was cut off
Creating OpenAIAdapter.php service for LLM integration
DocumentUploader.vue for RAG knowledge management
The WorkflowBuilder.php Filament page
These files represent different aspects of the system that seem important based on the structure.

Let me continue completing the ChatInterface.vue styling section and then provide additional key files from the structure:

<style scoped>
.typing-indicator {
  display: flex;
  align-items: center;
  justify-content: flex-start;
}

.typing-indicator span {
  height: 8px;
  width: 8px;
  float: left;
  margin: 0 1px;
  background-color: #9e9ea1;
  display: block;
  border-radius: 50%;
  opacity: 0.4;
}

.typing-indicator span:nth-of-type(1) {
  animation: 1s blink infinite 0.3333s;
}

.typing-indicator span:nth-of-type(2) {
  animation: 1s blink infinite 0.6666s;
}

.typing-indicator span:nth-of-type(3) {
  animation: 1s blink infinite 0.9999s;
}

@keyframes blink {
  50% {
    opacity: 1;
  }
}

:deep(pre) {
  border-radius: 0.375rem;
  padding: 0.75rem;
  margin: 0.5rem 0;
  overflow-x: auto;
}

:deep(code) {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 0.875rem;
}

:deep(p) {
  margin-bottom: 0.5rem;
}

:deep(ul), :deep(ol) {
  padding-left: 1.5rem;
  margin-bottom: 0.5rem;
}

:deep(ul) {
  list-style-type: disc;
}

:deep(ol) {
  list-style-type: decimal;
}

:deep(a) {
  color: #3b82f6;
  text-decoration: underline;
}

:deep(table) {
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 1rem;
}

:deep(th), :deep(td) {
  border: 1px solid #e5e7eb;
  padding: 0.5rem;
  text-align: left;
}

:deep(th) {
  background-color: #f9fafb;
}
</style>

Copy

Apply

resources\js\Components\Agent\ChatInterface.vue
Now let's implement the OpenAIAdapter.php service for LLM integration:

<?php

namespace App\Services\LLM;

use Illuminate\Http\Client\PendingRequest;
use Illuminate\Http\Client\Response;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class OpenAIAdapter
{
    private string $apiKey;
    private string $baseUrl;
    private PendingRequest $client;
    private array $defaultOptions;

    public function __construct()
    {
        $this->apiKey = config('services.openai.key');
        $this->baseUrl = config('services.openai.base_url', 'https://api.openai.com/v1');
        
        $this->client = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
            'Content-Type' => 'application/json',
            'Accept' => 'application/json',
        ])->baseUrl($this->baseUrl);
        
        $this->defaultOptions = [
            'temperature' => 0.7,
            'max_tokens' => 1000,
            'model' => config('services.openai.default_model', 'gpt-4o'),
        ];
    }

    /**
     * Generate a text completion using the OpenAI API
     *
     * @param string $prompt The prompt to generate from
     * @param array $options Additional parameters for the API
     * @return array The completion response
     */
    public function complete(string $prompt, array $options = []): array
    {
        $options = array_merge($this->defaultOptions, $options);
        
        try {
            $response = $this->client->post('chat/completions', [
                'model' => $options['model'],
                'messages' => [
                    ['role' => 'system', 'content' => $options['system_message'] ?? 'You are a helpful assistant.'],
                    ['role' => 'user', 'content' => $prompt],
                ],
                'temperature' => $options['temperature'],
                'max_tokens' => $options['max_tokens'],
                'top_p' => $options['top_p'] ?? 1,
                'frequency_penalty' => $options['frequency_penalty'] ?? 0,
                'presence_penalty' => $options['presence_penalty'] ?? 0,
            ]);
            
            if ($response->successful()) {
                $data = $response->json();
                return [
                    'success' => true,
                    'content' => $data['choices'][0]['message']['content'],
                    'model' => $data['model'],
                    'usage' => $data['usage'] ?? null,
                ];
            } else {
                Log::error('OpenAI API error', [
                    'status' => $response->status(),
                    'body' => $response->body(),
                ]);
                
                return [
                    'success' => false,
                    'error' => $response->json()['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }

    /**
     * Generate a streaming chat completion
     *
     * @param array $messages The conversation messages
     * @param array $options Additional parameters for the API
     * @return \Closure A closure that yields tokens
     */
    public function streamChat(array $messages, array $options = []): \Closure
    {
        $options = array_merge($this->defaultOptions, $options);
        
        // Generate a random request ID for logging
        $requestId = Str::uuid()->toString();
        Log::info("Starting OpenAI stream request: {$requestId}");
        
        return function() use ($messages, $options, $requestId) {
            try {
                // Make the streaming request
                $response = $this->client->withOptions([
                    'stream' => true,
                    'read_timeout' => 120,
                ])->post('chat/completions', [
                    'model' => $options['model'],
                    'messages' => $messages,
                    'temperature' => $options['temperature'],
                    'max_tokens' => $options['max_tokens'],
                    'stream' => true,
                ]);
                
                // Process the streaming response
                $buffer = '';
                $response->throw()->toPsrResponse()->getBody()->rewind();
                
                while (!$response->toPsrResponse()->getBody()->eof()) {
                    $chunk = $response->toPsrResponse()->getBody()->read(1024);
                    if (empty($chunk)) continue;
                    
                    $buffer .= $chunk;
                    $lines = explode("\n", $buffer);
                    $buffer = array_pop($lines); // Keep the last incomplete line in the buffer
                    
                    foreach ($lines as $line) {
                        if (empty(trim($line))) continue;
                        if (str_starts_with($line, 'data: ')) {
                            $data = substr($line, 6); // Remove 'data: ' prefix
                            
                            if ($data === '[DONE]') {
                                Log::info("OpenAI stream completed: {$requestId}");
                                return;
                            }
                            
                            $json = json_decode($data, true);
                            if (json_last_error() === JSON_ERROR_NONE) {
                                if (isset($json['choices'][0]['delta']['content'])) {
                                    $token = $json['choices'][0]['delta']['content'];
                                    yield $token;
                                }
                            }
                        }
                    }
                }
            } catch (\Exception $e) {
                Log::error("OpenAI stream error: {$requestId}", [
                    'message' => $e->getMessage(),
                    'trace' => $e->getTraceAsString(),
                ]);
                
                yield "[Error: " . $e->getMessage() . "]";
            }
        };
    }

    /**
     * Generate embeddings for a text
     *
     * @param string $text The text to embed
     * @param string|null $model The embedding model to use
     * @return array The embedding response
     */
    public function getEmbedding(string $text, ?string $model = null): array
    {
        $model = $model ?? config('services.openai.embedding_model', 'text-embedding-3-small');
        
        try {
            $response = $this->client->post('embeddings', [
                'model' => $model,
                'input' => $text,
                'encoding_format' => 'float',
            ]);
            
            if ($response->successful()) {
                $data = $response->json();
                return [
                    'success' => true,
                    'embedding' => $data['data'][0]['embedding'],
                    'model' => $data['model'],
                    'usage' => $data['usage'] ?? null,
                ];
            } else {
                Log::error('OpenAI embedding error', [
                    'status' => $response->status(),
                    'body' => $response->body(),
                ]);
                
                return [
                    'success' => false,
                    'error' => $response->json()['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI embedding exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }

    /**
     * Get a list of available models from OpenAI
     *
     * @return array The models response
     */
    public function getModels(): array
    {
        try {
            $response = $this->client->get('models');
            
            if ($response->successful()) {
                $models = $response->json()['data'];
                
                // Filter to only include newer models
                $filteredModels = array_filter($models, function($model) {
                    $name = $model['id'];
                    return Str::startsWith($name, ['gpt-4', 'gpt-3.5-turbo', 'text-embedding']);
                });
                
                return [
                    'success' => true,
                    'models' => array_values($filteredModels),
                ];
            } else {
                return [
                    'success' => false,
                    'error' => $response->json()['error']['message'] ?? 'Unknown error',
                ];
            }
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }
}

Copy

Apply

app\Services\LLM\OpenAIAdapter.php
Now let's implement the DocumentUploader.vue component for knowledge management:

<template>
  <div class="document-uploader">
    <div 
      :class="{ 'border-blue-400 bg-blue-50': isDragging }"
      class="border-2 border-dashed rounded-lg p-6 transition-colors duration-200"
      @dragenter.prevent="isDragging = true"
      @dragover.prevent="isDragging = true"
      @dragleave.prevent="isDragging = false"
      @drop.prevent="handleFileDrop"
    >
      <div class="text-center">
        <svg 
          class="mx-auto h-12 w-12 text-gray-400" 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor" 
          aria-hidden="true"
        >
          <path 
            stroke-linecap="round" 
            stroke-linejoin="round" 
            stroke-width="1" 
            d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" 
          />
        </svg>
        
        <div class="mt-2">
          <p class="text-sm text-gray-500">
            Drag and drop files here, or
            <label 
              for="file-upload" 
              class="relative cursor-pointer text-blue-600 hover:text-blue-700"
            >
              <span>browse for files</span>
              <input 
                id="file-upload" 
                type="file" 
                multiple 
                class="sr-only" 
                @change="handleFileSelect"
                :accept="acceptedFileTypes"
              />
            </label>
          </p>
          <p class="text-xs text-gray-400 mt-1">
            Accepted file types: PDF, DOCX, TXT, MD, CSV
          </p>
          <p class="text-xs text-gray-400">
            Maximum file size: 10MB
          </p>
        </div>
      </div>
    </div>
    
    <div v-if="files.length > 0" class="mt-4">
      <h3 class="text-sm font-medium text-gray-700 mb-2">Selected Files</h3>
      
      <div class="space-y-2">
        <div 
          v-for="(file, index) in files" 
          :key="index"
          class="flex items-center justify-between p-3 border rounded-md"
        >
          <div class="flex items-center">
            <div class="shrink-0 mr-3">
              <svg 
                class="h-6 w-6 text-gray-400" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  stroke-linecap="round" 
                  stroke-linejoin="round" 
                  stroke-width="2" 
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293

Copy

Apply

resources\js\Components\Knowledge\DocumentUploader.vue
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  DocumentUploader.vue  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue implementing the DocumentUploader.vue which was cut off, and then also add another important component from the structure:

Complete the DocumentUploader.vue component for knowledge management
Implement the WorkflowBuilder.php for Filament admin panel
Create the EmbeddingService.php for vector embeddings in the RAG system
These files represent different aspects of the system that appear core to its functionality.

Let's continue with implementing the DocumentUploader.vue component and other key files from the structure:

<template>
  <div class="document-uploader">
    <div 
      :class="{ 'border-blue-400 bg-blue-50': isDragging }"
      class="border-2 border-dashed rounded-lg p-6 transition-colors duration-200"
      @dragenter.prevent="isDragging = true"
      @dragover.prevent="isDragging = true"
      @dragleave.prevent="isDragging = false"
      @drop.prevent="handleFileDrop"
    >
      <div class="text-center">
        <svg 
          class="mx-auto h-12 w-12 text-gray-400" 
          fill="none" 
          viewBox="0 0 24 24" 
          stroke="currentColor" 
          aria-hidden="true"
        >
          <path 
            stroke-linecap="round" 
            stroke-linejoin="round" 
            stroke-width="1" 
            d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" 
          />
        </svg>
        
        <div class="mt-2">
          <p class="text-sm text-gray-500">
            Drag and drop files here, or
            <label 
              for="file-upload" 
              class="relative cursor-pointer text-blue-600 hover:text-blue-700"
            >
              <span>browse for files</span>
              <input 
                id="file-upload" 
                type="file" 
                multiple 
                class="sr-only" 
                @change="handleFileSelect"
                :accept="acceptedFileTypes"
              />
            </label>
          </p>
          <p class="text-xs text-gray-400 mt-1">
            Accepted file types: PDF, DOCX, TXT, MD, CSV
          </p>
          <p class="text-xs text-gray-400">
            Maximum file size: 10MB
          </p>
        </div>
      </div>
    </div>
    
    <div v-if="files.length > 0" class="mt-4">
      <h3 class="text-sm font-medium text-gray-700 mb-2">Selected Files</h3>
      
      <div class="space-y-2">
        <div 
          v-for="(file, index) in files" 
          :key="index"
          class="flex items-center justify-between p-3 border rounded-md"
        >
          <div class="flex items-center">
            <div class="shrink-0 mr-3">
              <svg 
                class="h-6 w-6 text-gray-400" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  stroke-linecap="round" 
                  stroke-linejoin="round" 
                  stroke-width="2" 
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" 
                />
              </svg>
            </div>
            
            <div>
              <div class="text-sm font-medium text-gray-900 truncate max-w-xs">
                {{ file.name }}
              </div>
              <div class="text-xs text-gray-500">
                {{ formatFileSize(file.size) }}
              </div>
            </div>
          </div>
          
          <div class="flex items-center gap-2">
            <div v-if="fileStates[index].status === 'uploading'">
              <div class="w-20">
                <div class="bg-gray-200 rounded-full h-2.5">
                  <div 
                    class="bg-blue-600 h-2.5 rounded-full" 
                    :style="{ width: fileStates[index].progress + '%' }"
                  ></div>
                </div>
                <div class="text-xs text-center mt-1 text-gray-500">
                  {{ fileStates[index].progress }}%
                </div>
              </div>
            </div>
            
            <div v-else-if="fileStates[index].status === 'error'" class="text-red-500 text-xs">
              {{ fileStates[index].error }}
            </div>
            
            <div v-else-if="fileStates[index].status === 'success'" class="text-green-500">
              <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
              </svg>
            </div>
            
            <button 
              type="button" 
              @click="removeFile(index)"
              class="ml-1 text-gray-400 hover:text-gray-500"
            >
              <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      </div>
      
      <div class="mt-4 flex justify-end space-x-3">
        <button 
          type="button" 
          @click="clearFiles"
          class="px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
          :disabled="isUploading"
        >
          Clear All
        </button>
        <button 
          type="button" 
          @click="uploadFiles"
          class="px-3 py-1.5 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          :disabled="files.length === 0 || isUploading"
        >
          <span v-if="isUploading">Uploading...</span>
          <span v-else>Upload {{ files.length }} {{ files.length === 1 ? 'File' : 'Files' }}</span>
        </button>
      </div>
    </div>
    
    <div v-if="options.showConfigOptions" class="mt-4">
      <h3 class="text-sm font-medium text-gray-700 mb-2">Processing Options</h3>
      
      <div class="space-y-3 p-3 border rounded-md">
        <div>
          <label class="flex items-center">
            <input 
              type="checkbox" 
              v-model="processingOptions.extractMetadata" 
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <span class="ml-2 text-sm text-gray-700">Extract metadata</span>
          </label>
        </div>
        
        <div>
          <label class="flex items-center">
            <input 
              type="checkbox" 
              v-model="processingOptions.splitIntoChunks" 
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <span class="ml-2 text-sm text-gray-700">Split documents into chunks</span>
          </label>
          
          <div v-if="processingOptions.splitIntoChunks" class="mt-2 pl-6">
            <label class="block text-xs text-gray-700">Chunk size (characters)</label>
            <input 
              type="number" 
              v-model.number="processingOptions.chunkSize" 
              min="100" 
              max="4000"
              class="mt-1 block w-24 py-1 px-2 border border-gray-300 bg-white rounded-md text-sm"
            />
          </div>
        </div>
        
        <div>
          <label class="flex items-center">
            <input 
              type="checkbox" 
              v-model="processingOptions.generateEmbeddings" 
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <span class="ml-2 text-sm text-gray-700">Generate embeddings</span>
          </label>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, reactive, computed, watch } from 'vue';
import { useToast } from '@/Composables/useToast';

export default {
  props: {
    url: {
      type: String,
      default: '/api/knowledge/documents/upload'
    },
    options: {
      type: Object,
      default: () => ({
        showConfigOptions: true,
        maxFileSize: 10 * 1024 * 1024, // 10MB
        acceptedFileTypes: ['.pdf', '.docx', '.txt', '.md', '.csv']
      })
    },
    collectionId: {
      type: [Number, String],
      default: null
    }
  },
  
  emits: ['upload-success', 'upload-error', 'files-cleared'],
  
  setup(props, { emit }) {
    const { showToast } = useToast();
    const files = ref([]);
    const isDragging = ref(false);
    const isUploading = ref(false);
    
    // Track the status of each file
    const fileStates = ref([]);
    
    // Document processing options
    const processingOptions = reactive({
      extractMetadata: true,
      splitIntoChunks: true,
      chunkSize: 1000,
      generateEmbeddings: true
    });
    
    // Computed string of accepted file types for the file input
    const acceptedFileTypes = computed(() => {
      return props.options.acceptedFileTypes.join(',');
    });
    
    // Handle file select from input
    const handleFileSelect = (event) => {
      addFiles(Array.from(event.target.files));
      event.target.value = null; // Clear the input
    };
    
    // Handle file drop
    const handleFileDrop = (event) => {
      isDragging.value = false;
      addFiles(Array.from(event.dataTransfer.files));
    };
    
    // Add files to the list
    const addFiles = (newFiles) => {
      const validFiles = newFiles.filter(file => {
        // Check file size
        if (file.size > props.options.maxFileSize) {
          showToast(`File "${file.name}" exceeds the maximum file size of ${formatFileSize(props.options.maxFileSize)}`, 'error');
          return false;
        }
        
        // Check file type
        const extension = '.' + file.name.split('.').pop().toLowerCase();
        if (!props.options.acceptedFileTypes.includes(extension)) {
          showToast(`File "${file.name}" has an unsupported file type`, 'error');
          return false;
        }
        
        return true;
      });
      
      // Add valid files to the list
      validFiles.forEach(file => {
        files.value.push(file);
        fileStates.value.push({
          status: 'pending',
          progress: 0,
          error: null
        });
      });
    };
    
    // Remove file from the list
    const removeFile = (index) => {
      files.value.splice(index, 1);
      fileStates.value.splice(index, 1);
    };
    
    // Clear all files
    const clearFiles = () => {
      files.value = [];
      fileStates.value = [];
      emit('files-cleared');
    };
    
    // Format file size
    const formatFileSize = (bytes) => {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };
    
    // Upload files
    const uploadFiles = async () => {
      if (files.value.length === 0 || isUploading.value) return;
      
      isUploading.value = true;
      let uploadedCount = 0;
      let errorCount = 0;
      
      for (let i = 0; i < files.value.length; i++) {
        if (fileStates.value[i].status === 'success') {
          uploadedCount++;
          continue; // Skip already uploaded files
        }
        
        // Create form data
        const formData = new FormData();
        formData.append('file', files.value[i]);
        formData.append('options', JSON.stringify(processingOptions));
        
        if (props.collectionId) {
          formData.append('collection_id', props.collectionId);
        }
        
        // Update file status
        fileStates.value[i].status = 'uploading';
        fileStates.value[i].progress = 0;
        
        try {
          // Upload file with progress tracking
          const xhr = new XMLHttpRequest();
          
          xhr.open('POST', props.url, true);
          xhr.setRequestHeader('X-CSRF-TOKEN', document.querySelector('meta[name="csrf-token"]').getAttribute('content'));
          
          // Track upload progress
          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const progress = Math.round((event.loaded / event.total) * 100);
              fileStates.value[i].progress = progress;
            }
          };
          
          // Create a promise to handle the XHR response
          await new Promise((resolve, reject) => {
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                fileStates.value[i].status

Copy

Apply

resources\js\Components\Knowledge\DocumentUploader.vue
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  DocumentUploader.vue  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue with some key files that are part of the structure. I need to:

Complete the DocumentUploader.vue which was cut off
Implement the WorkflowBuilder.php in the Filament admin panel
Create the EmbeddingService.php for the RAG system
Add the ProcessDocument.php job for RAG document processing
These files represent different aspects of the system architecture.

Let me continue with the implementation of key files from the project structure:

<script>
import { ref, reactive, computed, watch } from 'vue';
import { useToast } from '@/Composables/useToast';

export default {
  props: {
    url: {
      type: String,
      default: '/api/knowledge/documents/upload'
    },
    options: {
      type: Object,
      default: () => ({
        showConfigOptions: true,
        maxFileSize: 10 * 1024 * 1024, // 10MB
        acceptedFileTypes: ['.pdf', '.docx', '.txt', '.md', '.csv']
      })
    },
    collectionId: {
      type: [Number, String],
      default: null
    }
  },
  
  emits: ['upload-success', 'upload-error', 'files-cleared'],
  
  setup(props, { emit }) {
    const { showToast } = useToast();
    const files = ref([]);
    const isDragging = ref(false);
    const isUploading = ref(false);
    
    // Track the status of each file
    const fileStates = ref([]);
    
    // Document processing options
    const processingOptions = reactive({
      extractMetadata: true,
      splitIntoChunks: true,
      chunkSize: 1000,
      generateEmbeddings: true
    });
    
    // Computed string of accepted file types for the file input
    const acceptedFileTypes = computed(() => {
      return props.options.acceptedFileTypes.join(',');
    });
    
    // Handle file select from input
    const handleFileSelect = (event) => {
      addFiles(Array.from(event.target.files));
      event.target.value = null; // Clear the input
    };
    
    // Handle file drop
    const handleFileDrop = (event) => {
      isDragging.value = false;
      addFiles(Array.from(event.dataTransfer.files));
    };
    
    // Add files to the list
    const addFiles = (newFiles) => {
      const validFiles = newFiles.filter(file => {
        // Check file size
        if (file.size > props.options.maxFileSize) {
          showToast(`File "${file.name}" exceeds the maximum file size of ${formatFileSize(props.options.maxFileSize)}`, 'error');
          return false;
        }
        
        // Check file type
        const extension = '.' + file.name.split('.').pop().toLowerCase();
        if (!props.options.acceptedFileTypes.includes(extension)) {
          showToast(`File "${file.name}" has an unsupported file type`, 'error');
          return false;
        }
        
        return true;
      });
      
      // Add valid files to the list
      validFiles.forEach(file => {
        files.value.push(file);
        fileStates.value.push({
          status: 'pending',
          progress: 0,
          error: null
        });
      });
    };
    
    // Remove file from the list
    const removeFile = (index) => {
      files.value.splice(index, 1);
      fileStates.value.splice(index, 1);
    };
    
    // Clear all files
    const clearFiles = () => {
      files.value = [];
      fileStates.value = [];
      emit('files-cleared');
    };
    
    // Format file size
    const formatFileSize = (bytes) => {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };
    
    // Upload files
    const uploadFiles = async () => {
      if (files.value.length === 0 || isUploading.value) return;
      
      isUploading.value = true;
      let uploadedCount = 0;
      let errorCount = 0;
      
      for (let i = 0; i < files.value.length; i++) {
        if (fileStates.value[i].status === 'success') {
          uploadedCount++;
          continue; // Skip already uploaded files
        }
        
        // Create form data
        const formData = new FormData();
        formData.append('file', files.value[i]);
        formData.append('options', JSON.stringify(processingOptions));
        
        if (props.collectionId) {
          formData.append('collection_id', props.collectionId);
        }
        
        // Update file status
        fileStates.value[i].status = 'uploading';
        fileStates.value[i].progress = 0;
        
        try {
          // Upload file with progress tracking
          const xhr = new XMLHttpRequest();
          
          xhr.open('POST', props.url, true);
          xhr.setRequestHeader('X-CSRF-TOKEN', document.querySelector('meta[name="csrf-token"]').getAttribute('content'));
          
          // Track upload progress
          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const progress = Math.round((event.loaded / event.total) * 100);
              fileStates.value[i].progress = progress;
            }
          };
          
          // Create a promise to handle the XHR response
          await new Promise((resolve, reject) => {
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                fileStates.value[i].status = 'success';
                uploadedCount++;
                resolve(JSON.parse(xhr.responseText));
              } else {
                let errorMessage = 'Upload failed';
                try {
                  const response = JSON.parse(xhr.responseText);
                  errorMessage = response.message || errorMessage;
                } catch (e) {
                  // If parsing fails, use the default error message
                }
                
                fileStates.value[i].status = 'error';
                fileStates.value[i].error = errorMessage;
                errorCount++;
                reject(new Error(errorMessage));
              }
            };
            
            xhr.onerror = () => {
              fileStates.value[i].status = 'error';
              fileStates.value[i].error = 'Network error';
              errorCount++;
              reject(new Error('Network error'));
            };
            
            xhr.send(formData);
          });
        } catch (error) {
          console.error(`Error uploading file ${files.value[i].name}:`, error);
          // Error is already handled in the promise
        }
      }
      
      isUploading.value = false;
      
      if (uploadedCount > 0) {
        showToast(`Successfully uploaded ${uploadedCount} ${uploadedCount === 1 ? 'file' : 'files'}`, 'success');
        emit('upload-success', uploadedCount);
      }
      
      if (errorCount > 0) {
        showToast(`Failed to upload ${errorCount} ${errorCount === 1 ? 'file' : 'files'}`, 'error');
        emit('upload-error', errorCount);
      }
    };
    
    return {
      files,
      isDragging,
      isUploading,
      fileStates,
      processingOptions,
      acceptedFileTypes,
      handleFileSelect,
      handleFileDrop,
      removeFile,
      clearFiles,
      uploadFiles,
      formatFileSize
    };
  }
};
</script>

<style scoped>
.document-uploader {
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

input[type="checkbox"] {
  cursor: pointer;
}

label {
  cursor: pointer;
}

button:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}
</style>

Copy

Apply

resources\js\Components\Knowledge\DocumentUploader.vue
Now let's implement the WorkflowBuilder.php file for the Filament admin panel:

<?php

namespace App\Filament\Pages;

use App\Models\Workflow;
use App\Models\WorkflowNode;
use App\Services\Workflow\NodeRegistry;
use Filament\Forms\Components\Hidden;
use Filament\Forms\Components\Section;
use Filament\Forms\Components\Select;
use Filament\Forms\Components\Tabs;
use Filament\Forms\Components\Textarea;
use Filament\Forms\Components\TextInput;
use Filament\Forms\Components\Toggle;
use Filament\Notifications\Notification;
use Filament\Pages\Page;
use Illuminate\Support\Facades\DB;
use Livewire\Features\SupportFileUploads\TemporaryUploadedFile;

class WorkflowBuilder extends Page
{
    protected static ?string $navigationIcon = 'heroicon-o-rectangle-stack';
    protected static ?string $navigationLabel = 'Workflow Builder';
    protected static ?string $title = 'Workflow Builder';
    protected static ?string $slug = 'workflow-builder';
    protected static ?int $navigationSort = 2;

    public ?Workflow $workflow = null;
    public array $workflowNodes = [];
    public array $availableNodeTypes = [];
    public array $connections = [];
    public array $selectedNode = [
        'id' => null,
        'type' => null,
        'name' => null,
        'config' => [],
    ];
    public array $canvas = [
        'scale' => 1,
        'position' => ['x' => 0, 'y' => 0],
    ];
    
    protected $listeners = [
        'nodeSelected' => 'handleNodeSelected',
        'nodeAdded' => 'handleNodeAdded',
        'nodeRemoved' => 'handleNodeRemoved',
        'nodeUpdated' => 'handleNodeUpdated',
        'connectionCreated' => 'handleConnectionCreated',
        'connectionRemoved' => 'handleConnectionRemoved',
        'canvasUpdated' => 'handleCanvasUpdated',
        'saveWorkflow' => 'handleSaveWorkflow',
    ];
    
    public function mount($workflowId = null)
    {
        if ($workflowId) {
            $this->workflow = Workflow::findOrFail($workflowId);
            $this->loadWorkflow();
        } else {
            $this->workflow = new Workflow();
            $this->workflow->name = 'New Workflow';
            $this->workflow->description = '';
            $this->workflow->is_active = false;
        }
        
        // Get available node types from registry
        $registry = app(NodeRegistry::class);
        $this->availableNodeTypes = $registry->getRegisteredNodes();
    }
    
    protected function loadWorkflow(): void
    {
        $this->workflowNodes = $this->workflow->nodes()
            ->with('connections')
            ->get()
            ->map(function ($node) {
                return [
                    'id' => $node->id,
                    'type' => $node->type,
                    'name' => $node->name,
                    'config' => $node->config,
                    'position' => $node->position,
                ];
            })
            ->toArray();
            
        $this->connections = $this->workflow->nodes()
            ->with('connections')
            ->get()
            ->flatMap(function ($node) {
                return $node->connections->map(function ($connection) use ($node) {
                    return [
                        'source' => $node->id,
                        'target' => $connection->target_node_id,
                        'sourceHandle' => $connection->source_handle,
                        'targetHandle' => $connection->target_handle,
                    ];
                });
            })
            ->toArray();
            
        if (isset($this->workflow->canvas)) {
            $this->canvas = $this->workflow->canvas;
        }
    }
    
    public function handleNodeSelected($nodeId): void
    {
        $node = collect($this->workflowNodes)->firstWhere('id', $nodeId);
        
        if ($node) {
            $this->selectedNode = [
                'id' => $node['id'],
                'type' => $node['type'],
                'name' => $node['name'],
                'config' => $node['config'] ?? [],
            ];
        } else {
            $this->selectedNode = [
                'id' => null,
                'type' => null,
                'name' => null,
                'config' => [],
            ];
        }
    }
    
    public function handleNodeAdded($node): void
    {
        $this->workflowNodes[] = $node;
        $this->handleNodeSelected($node['id']);
    }
    
    public function handleNodeRemoved($nodeId): void
    {
        // Remove node from workflowNodes
        $this->workflowNodes = collect($this->workflowNodes)
            ->filter(function ($node) use ($nodeId) {
                return $node['id'] !== $nodeId;
            })
            ->toArray();
            
        // Remove connections related to this node
        $this->connections = collect($this->connections)
            ->filter(function ($connection) use ($nodeId) {
                return $connection['source'] !== $nodeId && $connection['target'] !== $nodeId;
            })
            ->toArray();
            
        // Clear selected node if it was selected
        if ($this->selectedNode['id'] === $nodeId) {
            $this->selectedNode = [
                'id' => null,
                'type' => null,
                'name' => null,
                'config' => [],
            ];
        }
    }
    
    public function handleNodeUpdated($nodeData): void
    {
        // Update node in workflowNodes
        $this->workflowNodes = collect($this->workflowNodes)
            ->map(function ($node) use ($nodeData) {
                if ($node['id'] === $nodeData['id']) {
                    return array_merge($node, $nodeData);
                }
                return $node;
            })
            ->toArray();
            
        // Update selected node if it was updated
        if ($this->selectedNode['id'] === $nodeData['id']) {
            $this->selectedNode = array_merge($this->selectedNode, $nodeData);
        }
    }
    
    public function handleConnectionCreated($connection): void
    {
        $this->connections[] = $connection;
    }
    
    public function handleConnectionRemoved($connection): void
    {
        $this->connections = collect($this->connections)
            ->filter(function ($conn) use ($connection) {
                return !(
                    $conn['source'] === $connection['source'] &&
                    $conn['target'] === $connection['target'] &&
                    $conn['sourceHandle'] === $connection['sourceHandle'] &&
                    $conn['targetHandle'] === $connection['targetHandle']
                );

Copy

Apply

app\Filament\Pages\WorkflowBuilder.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  WorkflowBuilder.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue implementing the WorkflowBuilder.php file that was cut off, and then implement the EmbeddingService.php which is a key part of the RAG system according to the directory structure. I'll focus on completing these two files as they represent different important aspects of the system.

Let me continue the implementation of the WorkflowBuilder.php file and add the EmbeddingService.php:

    public function handleConnectionRemoved($connection): void
    {
        $this->connections = collect($this->connections)
            ->filter(function ($conn) use ($connection) {
                return !(
                    $conn['source'] === $connection['source'] &&
                    $conn['target'] === $connection['target'] &&
                    $conn['sourceHandle'] === $connection['sourceHandle'] &&
                    $conn['targetHandle'] === $connection['targetHandle']
                );
            })
            ->toArray();
    }
    
    public function handleCanvasUpdated($canvasData): void
    {
        $this->canvas = $canvasData;
    }
    
    public function handleSaveWorkflow(): void
    {
        DB::beginTransaction();
        
        try {
            // Save the workflow
            $this->workflow->canvas = $this->canvas;
            $this->workflow->save();
            
            // Delete existing nodes and connections
            if ($this->workflow->exists) {
                // Only delete nodes that are not in the current workflow nodes
                $existingNodeIds = collect($this->workflowNodes)->pluck('id')->filter()->toArray();
                
                // Delete nodes not in existingNodeIds
                WorkflowNode::where('workflow_id', $this->workflow->id)
                    ->whereNotIn('id', $existingNodeIds)
                    ->delete();
            }
            
            // Create or update nodes
            foreach ($this->workflowNodes as $nodeData) {
                $node = WorkflowNode::updateOrCreate(
                    [
                        'id' => $nodeData['id'] ?? null,
                        'workflow_id' => $this->workflow->id,
                    ],
                    [
                        'type' => $nodeData['type'],
                        'name' => $nodeData['name'],
                        'config' => $nodeData['config'] ?? [],
                        'position' => $nodeData['position'] ?? ['x' => 0, 'y' => 0],
                    ]
                );
                
                // If node ID was null, update it with the new ID
                if (empty($nodeData['id'])) {
                    foreach ($this->connections as &$connection) {
                        if ($connection['source'] === $nodeData['tempId']) {
                            $connection['source'] = $node->id;
                        }
                        if ($connection['target'] === $nodeData['tempId']) {
                            $connection['target'] = $node->id;
                        }
                    }
                }
            }
            
            // Delete all existing connections and recreate them
            DB::table('workflow_node_connections')->where('workflow_id', $this->workflow->id)->delete();
            
            // Create connections
            foreach ($this->connections as $connectionData) {
                DB::table('workflow_node_connections')->insert([
                    'workflow_id' => $this->workflow->id,
                    'source_node_id' => $connectionData['source'],
                    'target_node_id' => $connectionData['target'],
                    'source_handle' => $connectionData['sourceHandle'],
                    'target_handle' => $connectionData['targetHandle'],
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            }
            
            DB::commit();
            
            Notification::make()
                ->title('Workflow saved successfully')
                ->success()
                ->send();
                
            // Reload workflow to get fresh data
            $this->workflow = Workflow::find($this->workflow->id);
            $this->loadWorkflow();
        } catch (\Exception $e) {
            DB::rollBack();
            
            Notification::make()
                ->title('Error saving workflow')
                ->body($e->getMessage())
                ->danger()
                ->send();
        }
    }
    
    public function updateNodeConfig($config): void
    {
        if (!$this->selectedNode['id']) {
            return;
        }
        
        $this->handleNodeUpdated([
            'id' => $this->selectedNode['id'],
            'config' => $config,
        ]);
    }
    
    public function testWorkflow(): void
    {
        if (!$this->workflow->exists) {
            Notification::make()
                ->title('Please save the workflow first')
                ->warning()
                ->send();
            return;
        }
        
        redirect()->route('filament.admin.pages.test-workflow', ['workflowId' => $this->workflow->id]);
    }
    
    protected function getHeaderActions(): array
    {
        return [
            \Filament\Actions\Action::make('save')
                ->label('Save Workflow')
                ->color('primary')
                ->action(fn () => $this->dispatch('saveWorkflow')),
                
            \Filament\Actions\Action::make('test')
                ->label('Test Workflow')
                ->color('success')
                ->action(fn () => $this->testWorkflow())
                ->visible(fn () => $this->workflow->exists),
        ];
    }
    
    public function render()
    {
        return view('filament.pages.workflow-builder');
    }
}

Copy

Apply

app\Filament\Pages\WorkflowBuilder.php
Now let's implement the EmbeddingService.php for vector embeddings in the RAG system:

<?php

namespace App\Services\RAG;

use App\Services\LLM\OpenAIAdapter;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class EmbeddingService
{
    protected OpenAIAdapter $openAIAdapter;
    protected string $defaultModel;
    protected int $embeddingDimension;
    protected int $cacheTtl;

    public function __construct(OpenAIAdapter $openAIAdapter)
    {
        $this->openAIAdapter = $openAIAdapter;
        $this->defaultModel = config('services.openai.embedding_model', 'text-embedding-3-small');
        
        // Set dimension based on model
        $this->embeddingDimension = $this->getEmbeddingDimension($this->defaultModel);
        
        // Cache embeddings for 24 hours by default
        $this->cacheTtl = config('services.rag.embedding_cache_ttl', 86400); // 24 hours
    }

    /**
     * Generate embeddings for a text
     *
     * @param string $text The text to embed
     * @param string|null $model The embedding model to use
     * @param bool $useCache Whether to use the cache
     * @return array|null The embedding vector or null on failure
     */
    public function generateEmbedding(string $text, ?string $model = null, bool $useCache = true): ?array
    {
        $model = $model ?? $this->defaultModel;
        
        // Create a cache key based on the text and model
        $cacheKey = 'embedding_' . md5($text . '_' . $model);
        
        // Return from cache if available and cache is enabled
        if ($useCache && Cache::has($cacheKey)) {
            return Cache::get($cacheKey);
        }
        
        try {
            // Call the OpenAI API to generate the embedding
            $response = $this->openAIAdapter->getEmbedding($text, $model);
            
            if (!$response['success']) {
                Log::error('Failed to generate embedding', [
                    'error' => $response['error'] ?? 'Unknown error',
                    'text_length' => strlen($text)
                ]);
                return null;
            }
            
            $embedding = $response['embedding'];
            
            // Cache the embedding
            if ($useCache) {
                Cache::put($cacheKey, $embedding, $this->cacheTtl);
            }
            
            return $embedding;
        } catch (\Exception $e) {
            Log::error('Error generating embedding', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return null;
        }
    }
    
    /**
     * Generate embeddings for multiple texts in batch
     *
     * @param array $texts Array of texts to embed
     * @param string|null $model The embedding model to use
     * @param bool $useCache Whether to use the cache
     * @return array Array of embeddings or empty arrays for failed embeddings
     */
    public function generateEmbeddingsBatch(array $texts, ?string $model = null, bool $useCache = true): array
    {
        $model = $model ?? $this->defaultModel;
        $embeddings = [];
        
        foreach ($texts as $text) {
            $embedding = $this->generateEmbedding($text, $model, $useCache);
            $embeddings[] = $embedding ?? array_fill(0, $this->embeddingDimension, 0);
        }
        
        return $embeddings;
    }
    
    /**
     * Calculate cosine similarity between two vectors
     *
     * @param array $vec1 First vector
     * @param array $vec2 Second vector
     * @return float Cosine similarity (between -1 and 1)
     */
    public function cosineSimilarity(array $vec1, array $vec2): float
    {
        if (empty($vec1) || empty($vec2) || count($vec1) !== count($vec2)) {
            return 0.0;
        }
        
        $dotProduct = 0;
        $magnitude1 = 0;
        $magnitude2 = 0;
        
        for ($i = 0; $i < count($vec1); $i++) {
            $dotProduct += $vec1[$i] * $vec2[$i];
            $magnitude1 += $vec1[$i] * $vec1[$i];
            $magnitude2 += $vec2[$i] * $vec2[$i];
        }
        
        $magnitude1 = sqrt($magnitude1);
        $magnitude2 = sqrt($magnitude2);
        
        if ($magnitude1 == 0 || $magnitude2 == 0) {
            return 0.0;
        }
        
        return $dotProduct / ($magnitude1 * $magnitude2);
    }
    
    /**
     * Find most similar texts based on embeddings
     *
     * @param string $query Query text
     * @param array $documents Array of documents with 'text' and 'embedding' keys
     * @param int $topK Number of results to return
     * @return array Most similar documents with similarity scores
     */
    public function findSimilarTexts(string $query, array $documents, int $topK = 5): array
    {
        // Generate embedding for the query
        $queryEmbedding = $this->generateEmbedding($query);
        
        if (!$queryEmbedding) {
            return [];
        }
        
        $results = [];
        
        // Calculate similarity for each document
        foreach ($documents as $index => $document) {
            // Skip documents without embeddings
            if (empty($document['embedding'])) {
                continue;
            }
            
            $similarity = $this->cosineSimilarity($queryEmbedding, $document['embedding']);
            
            $results[] = [
                'document' => $document,
                'similarity' => $similarity,
                'index' => $index
            ];
        }
        
        // Sort by similarity (highest first)
        usort($results, function ($a, $b) {
            return $b['similarity'] <=> $a['similarity'];
        });
        
        // Return top K results
        return array_slice($results, 0, $topK);
    }
    
    /**
     * Get the embedding dimension for a given model
     *
     * @param string $model The embedding model
     * @return int The dimension
     */
    private function getEmbeddingDimension(string $model): int
    {
        $dimensions = [
            'text-embedding-ada-002' => 1536,
            'text-embedding-3-small' => 1536,
            'text-embedding-3-large' => 3072
        ];
        
        return $dimensions[$model] ?? 1536; // Default to 1536 if model not found
    }
    
    /**
     * Get the dimension of the embeddings generated by the current model
     *
     * @return int The dimension
     */
    public function getEmbeddingSize(): int
    {
        return $this->embeddingDimension;
    }
    
    /**
     * Get the current model being used
     *
     * @return string The model name
     */
    public function getCurrentModel(): string
    {
        return $this->defaultModel;
    }
}

Copy

Apply

app\Services\RAG\EmbeddingService.php
Now, let's implement the ProcessDocument.php job for document processing in the RAG system:

<?php

namespace App\Jobs;

use App\Models\KnowledgeDocument;
use App\Services\RAG\DocumentProcessor;
use App\Services\RAG\EmbeddingService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class ProcessDocument implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $timeout = 600; // 10 minutes
    public int $tries = 3;
    
    protected KnowledgeDocument $document;
    protected array $options;

    /**
     * Create a new job instance.
     *
     * @param KnowledgeDocument $document The document to process
     * @param array $options Processing options
     */
    public function __construct(KnowledgeDocument $document, array $options = [])
    {
        $this->document = $document;
        $this->options = array_merge([
            'extractMetadata' => true,
            'splitIntoChunks' => true,
            'chunkSize' => 1000,
            'generateEmbeddings' => true,
        ], $options);
    }

    /**
     * Execute the job.
     */
    public function handle(DocumentProcessor $processor, EmbeddingService $embeddingService): void
    {
        Log::info('Processing document', [
            'document_id' => $this->document->id,
            'filename' => $this->document->filename,
            'options' => $this->options,
        ]);
        
        try {
            // Update document status
            $this->document->status = 'processing';
            $this->document->save();
            
            // Get file path
            $filePath = Storage::disk('documents')->path($this->document->file_path);
            
            if (!file_exists($filePath)) {
                throw new \Exception("Document file not found: {$filePath}");
            }
            
            // Extract text content from document
            $content = $processor->extractText($filePath, $this->document->mime_type);
            
            if (empty($content)) {
                throw new \Exception("Failed to extract text from document");
            }
            
            // Save the raw content
            $this->document->content = $content;
            
            // Extract metadata if requested
            if ($this->options['extractMetadata'])

Copy

Apply

app\Jobs\ProcessDocument.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  ProcessDocument.php and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
I need to continue implementing the ProcessDocument.php job that I started but didn't finish, and then work on implementing some of the other core files in the project structure. Looking at the directory structure, some important files to implement would be:

Continue implementing ProcessDocument.php (Jobs)
Implement OpenAIAdapter.php (LLM integration)
Implement VectorStoreService.php (RAG system for Qdrant)
Implement KnowledgeDocumentResource.php (Filament admin panel)
These represent different aspects of the system and would give a good overview of the application's capabilities.

I'll continue implementing the key files from the structure, starting with completing the ProcessDocument.php job:

<?php

namespace App\Jobs;

use App\Models\KnowledgeDocument;
use App\Services\RAG\DocumentProcessor;
use App\Services\RAG\EmbeddingService;
use App\Services\RAG\VectorStoreService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class ProcessDocument implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $timeout = 600; // 10 minutes
    public int $tries = 3;
    
    protected KnowledgeDocument $document;
    protected array $options;

    /**
     * Create a new job instance.
     *
     * @param KnowledgeDocument $document The document to process
     * @param array $options Processing options
     */
    public function __construct(KnowledgeDocument $document, array $options = [])
    {
        $this->document = $document;
        $this->options = array_merge([
            'extractMetadata' => true,
            'splitIntoChunks' => true,
            'chunkSize' => 1000,
            'generateEmbeddings' => true,
        ], $options);
    }

    /**
     * Execute the job.
     */
    public function handle(DocumentProcessor $processor, EmbeddingService $embeddingService, VectorStoreService $vectorStore): void
    {
        Log::info('Processing document', [
            'document_id' => $this->document->id,
            'filename' => $this->document->filename,
            'options' => $this->options,
        ]);
        
        try {
            // Update document status
            $this->document->status = 'processing';
            $this->document->save();
            
            // Get file path
            $filePath = Storage::disk('documents')->path($this->document->file_path);
            
            if (!file_exists($filePath)) {
                throw new \Exception("Document file not found: {$filePath}");
            }
            
            // Extract text content from document
            $content = $processor->extractText($filePath, $this->document->mime_type);
            
            if (empty($content)) {
                throw new \Exception("Failed to extract text from document");
            }
            
            // Save the raw content
            $this->document->content = $content;
            
            // Extract metadata if requested
            if ($this->options['extractMetadata']) {
                $metadata = $processor->extractMetadata($filePath, $this->document->mime_type);
                $this->document->metadata = $metadata;
            }
            
            // Generate chunks if requested
            if ($this->options['splitIntoChunks']) {
                $chunks = $processor->splitIntoChunks($content, $this->options['chunkSize']);
                $this->document->chunks = $chunks;
                
                // Generate embeddings for each chunk if requested
                if ($this->options['generateEmbeddings'] && !empty($chunks)) {
                    Log::info('Generating embeddings for chunks', [
                        'document_id' => $this->document->id,
                        'chunks_count' => count($chunks),
                    ]);
                    
                    $chunkTexts = array_column($chunks, 'text');
                    $embeddings = $embeddingService->generateEmbeddingsBatch($chunkTexts);
                    
                    // Add embeddings to chunks
                    foreach ($chunks as $index => $chunk) {
                        if (isset($embeddings[$index])) {
                            $chunks[$index]['embedding'] = $embeddings[$index];
                        }
                    }
                    
                    $this->document->chunks = $chunks;
                    
                    // Store vectors in vector database
                    $vectorStore->upsertVectors(
                        $this->document->id,
                        $chunks,
                        [
                            'document_id' => $this->document->id,
                            'filename' => $this->document->filename,
                            'collection_id' => $this->document->collection_id,
                        ]
                    );
                }
            }
            
            // Update document status
            $this->document->status = 'processed';
            $this->document->processed_at = now();
            $this->document->save();
            
            Log::info('Document processed successfully', [
                'document_id' => $this->document->id,
                'filename' => $this->document->filename,
            ]);
        } catch (\Exception $e) {
            // Update document status to error
            $this->document->status = 'error';
            $this->document->error = $e->getMessage();
            $this->document->save();
            
            Log::error('Error processing document', [
                'document_id' => $this->document->id,
                'filename' => $this->document->filename,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            // Rethrow the exception to trigger the job's failed method
            throw $e;
        }
    }
    
    /**
     * Handle a job failure.
     *
     * @param \Throwable $exception
     * @return void
     */
    public function failed(\Throwable $exception): void
    {
        Log::error('Document processing job failed', [
            'document_id' => $this->document->id,
            'error' => $exception->getMessage(),
        ]);
        
        // Ensure document is marked as failed
        $this->document->status = 'error';
        $this->document->error = $exception->getMessage();
        $this->document->save();
    }
}

Copy

Apply

app\Jobs\ProcessDocument.php
Now let's implement the OpenAIAdapter.php for LLM integration:

<?php

namespace App\Services\LLM;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\Client\PendingRequest;
use Illuminate\Support\Str;

class OpenAIAdapter
{
    protected string $apiKey;
    protected string $baseUrl;
    protected string $defaultModel;
    protected array $supportedModels;
    protected float $defaultTemperature;
    protected int $maxTokens;
    protected PendingRequest $http;
    
    public function __construct()
    {
        $this->apiKey = config('services.openai.key');
        $this->baseUrl = config('services.openai.urls.base', 'https://api.openai.com/v1/');
        $this->defaultModel = config('services.openai.models.default', 'gpt-4o');
        $this->supportedModels = config('services.openai.models.supported', [
            'gpt-4o' => 'GPT-4o',
            'gpt-4-turbo' => 'GPT-4 Turbo',
            'gpt-3.5-turbo' => 'GPT-3.5 Turbo',
        ]);
        $this->defaultTemperature = config('services.openai.temperature', 0.7);
        $this->maxTokens = config('services.openai.max_tokens', 4000);
        
        $this->http = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
            'Content-Type' => 'application/json',
            'Accept' => 'application/json',
        ])->timeout(60);
    }
    
    /**
     * Get chat completion from OpenAI API
     * 
     * @param array $messages Array of message objects
     * @param array $options Options for the API call
     * @return array Response with success status and data/error
     */
    public function getChatCompletion(array $messages, array $options = []): array
    {
        $model = $options['model'] ?? $this->defaultModel;
        $temperature = $options['temperature'] ?? $this->defaultTemperature;
        $maxTokens = $options['max_tokens'] ?? $this->maxTokens;
        $stream = $options['stream'] ?? false;
        $tools = $options['tools'] ?? null;
        $responseFormat = $options['response_format'] ?? null;
        
        $payload = [
            'model' => $model,
            'messages' => $messages,
            'temperature' => $temperature,
            'max_tokens' => $maxTokens,
            'stream' => $stream,
        ];
        
        if ($tools) {
            $payload['tools'] = $tools;
            $payload['tool_choice'] = $options['tool_choice'] ?? 'auto';
        }
        
        if ($responseFormat) {
            $payload['response_format'] = $responseFormat;
        }
        
        try {
            $response = $this->http->post($this->baseUrl . 'chat/completions', $payload);
            
            if ($response->successful()) {
                $data = $response->json();
                
                return [
                    'success' => true,
                    'data' => $data,
                    'content' => $data['choices'][0]['message']['content'] ?? null,
                    'function_call' => $data['choices'][0]['message']['function_call'] ?? null,
                    'tool_calls' => $data['choices'][0]['message']['tool_calls'] ?? null,
                ];
            } else {
                $error = $response->json();
                
                Log::error('OpenAI API error', [
                    'status' => $response->status(),
                    'error' => $error,
                ]);
                
                return [
                    'success' => false,
                    'error' => $error['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }
    
    /**
     * Get streaming chat completion from OpenAI API
     * 
     * @param array $messages Array of message objects
     * @param callable $callback Callback function for each chunk
     * @param array $options Options for the API call
     * @return bool Success status
     */
    public function streamChatCompletion(array $messages, callable $callback, array $options = []): bool
    {
        $options['stream'] = true;
        
        try {
            $model = $options['model'] ?? $this->defaultModel;
            $temperature = $options['temperature'] ?? $this->defaultTemperature;
            $maxTokens = $options['max_tokens'] ?? $this->maxTokens;
            $tools = $options['tools'] ?? null;
            
            $payload = [
                'model' => $model,
                'messages' => $messages,
                'temperature' => $temperature,
                'max_tokens' => $maxTokens,
                'stream' => true,
            ];
            
            if ($tools) {
                $payload['tools'] = $tools;
                $payload['tool_choice'] = $options['tool_choice'] ?? 'auto';
            }
            
            if ($options['response_format'] ?? null) {
                $payload['response_format'] = $options['response_format'];
            }
            
            $response = $this->http->withOptions([
                'stream' => true,
            ])->post($this->baseUrl . 'chat/completions', $payload);
            
            $buffer = '';
            
            $response->throw()->toPsrResponse()->getBody()->rewind();
            
            $stream = $response->toPsrResponse()->getBody();
            
            while (!$stream->eof()) {
                $line = $this->readLine($stream);
                
                if (!empty($line)) {
                    // Handle SSE format
                    if (Str::startsWith($line, 'data: ')) {
                        $data = substr($line, 6);
                        
                        if ($data === '[DONE]') {
                            break;
                        }
                        
                        try {
                            $decodedData = json_decode($data, true);
                            
                            if (json_last_error() === JSON_ERROR_NONE) {
                                $callback($decodedData);
                            }
                        } catch (\Exception $e) {
                            Log::error('Error parsing OpenAI stream data', [
                                'error' => $e->getMessage(),
                                'data' => $data,
                            ]);
                        }
                    }
                }
            }
            
            return true;
        } catch (\Exception $e) {
            Log::error('OpenAI streaming API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Get embedding from OpenAI API
     * 
     * @param string $text Text to embed
     * @param string|null $model Embedding model to use
     * @return array Response with success status and embedding/error
     */
    public function getEmbedding(string $text, ?string $model = null): array
    {
        $model = $model ?? config('services.openai.embedding_model', 'text-embedding-3-small');
        
        try {
            $response = $this->http->post($this->baseUrl . 'embeddings', [
                'model' => $model,
                'input' => $text,
            ]);
            
            if ($response->successful()) {
                $data = $response->json();
                
                return [
                    'success' => true,
                    'embedding' => $data['data'][0]['embedding'],
                ];
            } else {
                $error = $response->json();
                
                Log::error('OpenAI Embedding API error', [
                    'status' => $response->status(),
                    'error' => $error,
                ]);
                
                return [
                    'success' => false,
                    'error' => $error['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI Embedding API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }
    
    /**
     * Read a line from a stream
     *

Copy

Apply

app\Services\LLM\OpenAIAdapter.php
│   │   ├── LLM/

│   │   │   ├── PrismAdapter.php             # Prism integration

│   │   │   └── OpenAIAdapter.php            # OpenAI integration

│   │   └── RAG/

│   │       ├── LlphantService.php           # llphant integration

│   │       ├── DocumentProcessor.php        # Process documents

│   │       ├── VectorStoreService.php       # Qdrant integration

│   │       └── EmbeddingService.php         # Embedding generation

│   ├── Filament/

│   │   ├── Resources/

│   │   │   ├── WorkflowResource.php         # Workflow management

│   │   │   ├── WorkflowNodeResource.php     # Node management

│   │   │   ├── AgentDynamicConfigResource.php  # Agent config management

│   │   │   └── KnowledgeDocumentResource.php  # Document management

│   │   └── Pages/

│   │       ├── WorkflowBuilder.php          # Custom builder page

│   │       ├── TestWorkflow.php             # Test workflow page

│   │       └── TestRagChat.php              # Test RAG chat

│   ├── Jobs/

│   │   ├── ExecuteWorkflow.php              # Run workflow

│   │   ├── ProcessDocument.php              # Process documents for RAG

│   │   └── ScheduledWorkflow.php            # Run scheduled workflows

│   └── Providers/

│       ├── LlphantServiceProvider.php       # RAG services

│       └── WorkflowServiceProvider.php      # Workflow components

├── database/

│   └── migrations/

│       ├── 2023_xx_xx_create_workflows_table.php

│       ├── 2023_xx_xx_create_workflow_nodes_table.php

│       ├── 2023_xx_xx_create_agent_dynamic_configs_table.php

│       ├── 2023_xx_xx_create_knowledge_documents_table.php

│       ├── 2023_xx_xx_create_workflow_executions_table.php

│       └── 2023_xx_xx_create_execution_logs_table.php

└── resources/

    ├── js/

    │   ├── Pages/

    │   │   ├── Workflows/

    │   │   │   ├── Index.vue                # List workflows

    │   │   │   ├── Create.vue               # Create workflow

    │   │   │   ├── Edit.vue                 # Edit workflow

    │   │   │   ├── Builder.vue              # Visual builder

    │   │   │   └── Execution.vue            # Execution history

    │   │   ├── Agents/

    │   │   │   ├── Index.vue                # List agents

    │   │   │   ├── Create.vue               # Create agent

    │   │   │   ├── Edit.vue                 # Edit agent

    │   │   │   └── Chat.vue                 # Chat with agent

    │   │   └── Knowledge/

    │   │       ├── Index.vue                # Doc management

    │   │       └── Upload.vue               # Upload documents

    │   └── Components/

    │       ├── Workflow/

    │       │   ├── Builder/

    │       │   │   ├── Canvas.vue           # Main builder canvas

    │       │   │   ├── NodeList.vue         # Available nodes

    │       │   │   ├── NodeConfig.vue       # Node configuration

    │       │   │   ├── SequenceView.vue     # Sequential node view

    │       │   │   └── NodeCard.vue         # Individual node

    │       │   ├── Nodes/                   # Node-specific components

    │       │   │   ├── WebhookNode.vue

    │       │   │   ├── HttpNode.vue

    │       │   │   ├── AgentNode.vue

    │       │   │   ├── ConditionNode.vue

    │       │   │   ├── TransformNode.vue

    │       │   │   ├── SchedulerNode.vue

    │       │   │   └── ReturnNode.vue

    │       │   └── Execution/

    │       │       ├── ExecutionView.vue    # Execution details

    │       │       └── NodeExecution.vue    # Node execution info

    │       ├── Agent/

    │       │   ├── AgentForm.vue            # Create/edit agent

    │       │   ├── ModelSelector.vue        # Select LLM model

    │       │   ├── ToolSelector.vue         # Select agent tools

    │       │   └── ChatInterface.vue        # Streaming chat UI

    │       └── Knowledge/

    │           ├── DocumentUploader.vue     # Upload documents

    │           ├── DocumentList.vue         # List documents

    │           └── RagTester.vue            # Test RAG          # OpenAI integration please continue with code generation for  openaiadapter.php and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
I'll continue implementing the OpenAIAdapter.php file that was cut off, and then implement the VectorStoreService.php for Qdrant integration. These seem to be core components of the system.

For the OpenAIAdapter.php, I need to finish the readLine method that was cut off in the previous response, and add any other necessary methods.

For the VectorStoreService.php, I need to implement methods for:

Connecting to Qdrant
Upserting vectors
Searching vectors
Deleting vectors
Managing collections
Let me continue implementing the OpenAIAdapter.php and then the VectorStoreService.php:

    /**
     * Read a line from a stream
     * 
     * @param \Psr\Http\Message\StreamInterface $stream The stream to read from
     * @return string|null The line read or null if EOF
     */
    private function readLine($stream): ?string
    {
        $buffer = '';
        
        while (!$stream->eof()) {
            $char = $stream->read(1);
            
            if ($char === "\n") {
                return $buffer;
            }
            
            $buffer .= $char;
        }
        
        return $buffer ?: null;
    }
    
    /**
     * Generate image from OpenAI API
     * 
     * @param string $prompt The prompt for image generation
     * @param array $options Options for the API call
     * @return array Response with success status and image data/error
     */
    public function generateImage(string $prompt, array $options = []): array
    {
        $model = $options['model'] ?? 'dall-e-3';
        $size = $options['size'] ?? '1024x1024';
        $quality = $options['quality'] ?? 'standard';
        $n = $options['n'] ?? 1;
        
        try {
            $response = $this->http->post($this->baseUrl . 'images/generations', [
                'model' => $model,
                'prompt' => $prompt,
                'size' => $size,
                'quality' => $quality,
                'n' => $n,
            ]);
            
            if ($response->successful()) {
                $data = $response->json();
                
                return [
                    'success' => true,
                    'data' => $data,
                    'images' => $data['data'],
                ];
            } else {
                $error = $response->json();
                
                Log::error('OpenAI Image API error', [
                    'status' => $response->status(),
                    'error' => $error,
                ]);
                
                return [
                    'success' => false,
                    'error' => $error['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI Image API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }
    
    /**
     * Get supported models
     * 
     * @return array Supported model options
     */
    public function getSupportedModels(): array
    {
        return $this->supportedModels;
    }
    
    /**
     * Get default model
     * 
     * @return string Default model
     */
    public function getDefaultModel(): string
    {
        return $this->defaultModel;
    }
    
    /**
     * Generate audio speech from text
     * 
     * @param string $text Text to convert to speech
     * @param array $options Options for the API call
     * @return array Response with success status and audio/error
     */
    public function generateSpeech(string $text, array $options = []): array
    {
        $model = $options['model'] ?? 'tts-1';
        $voice = $options['voice'] ?? 'alloy';
        $responseFormat = $options['response_format'] ?? 'mp3';
        
        try {
            $response = $this->http->post($this->baseUrl . 'audio/speech', [
                'model' => $model,
                'input' => $text,
                'voice' => $voice,
                'response_format' => $responseFormat,
            ]);
            
            if ($response->successful()) {
                return [
                    'success' => true,
                    'audio' => $response->body(),
                    'content_type' => 'audio/' . $responseFormat,
                ];
            } else {
                $error = $response->json();
                
                Log::error('OpenAI Speech API error', [
                    'status' => $response->status(),
                    'error' => $error,
                ]);
                
                return [
                    'success' => false,
                    'error' => $error['error']['message'] ?? 'Unknown error',
                    'status' => $response->status(),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI Speech API exception', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }
}

Copy

Apply

app\Services\LLM\OpenAIAdapter.php
Now let's implement the VectorStoreService.php for Qdrant integration:

<?php

namespace App\Services\RAG;

use App\Services\RAG\EmbeddingService;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class VectorStoreService
{
    protected string $baseUrl;
    protected string $apiKey;
    protected string $defaultCollection;
    protected EmbeddingService $embeddingService;
    protected int $vectorSize;

    public function __construct(EmbeddingService $embeddingService)
    {
        $this->baseUrl = rtrim(config('services.qdrant.url', 'http://localhost:6333'), '/');
        $this->apiKey = config('services.qdrant.api_key', '');
        $this->defaultCollection = config('services.qdrant.default_collection', 'documents');
        $this->embeddingService = $embeddingService;
        $this->vectorSize = $embeddingService->getEmbeddingSize();
    }

    /**
     * Get HTTP client for Qdrant API
     *
     * @return \Illuminate\Http\Client\PendingRequest
     */
    protected function client()
    {
        $client = Http::timeout(30)
            ->withHeaders([
                'Content-Type' => 'application/json',
                'Accept' => 'application/json',
            ]);
            
        if (!empty($this->apiKey)) {
            $client = $client->withHeaders([
                'api-key' => $this->apiKey,
            ]);
        }
        
        return $client;
    }

    /**
     * Create a new collection
     *
     * @param string $collectionName Collection name
     * @param array $options Collection options
     * @return bool Success
     */
    public function createCollection(string $collectionName, array $options = []): bool
    {
        try {
            $vectorSize = $options['vector_size'] ?? $this->vectorSize;
            $distance = $options['distance'] ?? 'Cosine';
            $onDisk = $options['on_disk'] ?? false;
            $shardNumber = $options['shard_number'] ?? null;
            $replicationFactor = $options['replication_factor'] ?? null;
            
            $payload = [
                'vectors' => [
                    'size' => $vectorSize,
                    'distance' => $distance,
                    'on_disk' => $onDisk,
                ],
            ];
            
            if ($shardNumber !== null) {
                $payload['shard_number'] = $shardNumber;
            }
            
            if ($replicationFactor !== null) {
                $payload['replication_factor'] = $replicationFactor;
            }
            
            // Define payload for optimizers if provided in options
            if (isset($options['optimizers'])) {
                $payload['optimizers_config'] = $options['optimizers'];
            }
            
            // Define payload for vector index if provided in options
            if (isset($options['hnsw_config'])) {
                $payload['hnsw_config'] = $options['hnsw_config'];
            }
            
            $response = $this->client()->put("{$this->baseUrl}/collections/{$collectionName}", $payload);
            
            if ($response->successful()) {
                // Check if we need to create any indexes
                if (isset($options['indexes']) && is_array($options['indexes'])) {
                    foreach ($options['indexes'] as $field) {
                        $this->createPayloadIndex($collectionName, $field);
                    }
                }
                
                return true;
            } else {
                Log::error('Failed to create Qdrant collection', [
                    'collection' => $collectionName,
                    'response' => $response->json(),
                    'status' => $response->status(),
                ]);
                
                return false;
            }
        } catch (\Exception $e) {
            Log::error('Exception creating Qdrant collection', [
                'collection' => $collectionName,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Delete a collection
     *
     * @param string $collectionName Collection name
     * @return bool Success
     */
    public function deleteCollection(string $collectionName): bool
    {
        try {
            $response = $this->client()->delete("{$this->baseUrl}/collections/{$collectionName}");
            
            return $response->successful();
        } catch (\Exception $e) {
            Log::error('Exception deleting Qdrant collection', [
                'collection' => $collectionName,
                'error' => $e->getMessage(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Check if a collection exists
     *
     * @param string $collectionName Collection name
     * @return bool Exists
     */
    public function collectionExists(string $collectionName): bool
    {
        try {
            $response = $this->client()->get("{$this->baseUrl}/collections/{$collectionName}");
            
            return $response->successful();
        } catch (\Exception $e) {
            return false;
        }
    }
    
    /**
     * Create a payload index for filtering
     *
     * @param string $collectionName Collection name
     * @param string $field Field name to index
     * @param string $fieldType Type of field ('keyword' or 'integer')
     * @return bool Success
     */
    public function createPayloadIndex(string $collectionName, string $field, string $fieldType = 'keyword'): bool
    {
        try {
            $payload = [
                'field_name' => $field,
                'field_schema' => $fieldType,
            ];
            
            $response = $this->client()->put(
                "{$this->baseUrl}/collections/{$collectionName}/index", 
                $payload
            );
            
            return $response->successful();
        } catch (\Exception $e) {
            Log::error('Exception creating Qdrant payload index', [
                'collection' => $collectionName,
                'field' => $field,
                'error' => $e->getMessage(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Upsert vectors into a collection
     *
     * @param string|int $documentId Document ID
     * @param array $chunks Document chunks with text and embeddings
     * @param array $metadata Additional metadata to store
     * @param string|null $collectionName Collection name (default from config if null)
     * @return bool Success
     */
    public function upsertVectors($documentId, array $chunks, array $metadata = [], ?string $collectionName = null): bool
    {
        $collectionName = $collectionName ?? $this->defaultCollection;
        
        // Ensure collection exists
        if (!$this->collectionExists($collectionName)) {
            if (!$this->createCollection($collectionName)) {
                return false;
            }
        }
        
        try {
            $points = [];
            
            foreach ($chunks as $index => $chunk) {
                if (empty($chunk['embedding'])) {
                    continue;
                }
                
                // Create a unique ID for this chunk
                $chunkId = "{$documentId}_{$index}";
                
                // Prepare the point data
                $point = [
                    'id' => $chunkId,
                    'vector' => $chunk['embedding'],
                    'payload' => array_merge([
                        'document_id' => $documentId,
                        'chunk_index' => $index,
                        'text' => $chunk['text'],
                    ], $metadata),
                ];
                
                $points[] = $point;
            }
            
            if (empty($points)) {
                Log::warning('No valid points to upsert into Qdrant', [
                    'document_id' => $documentId,
                    'collection' => $collectionName,
                ]);
                
                return false;
            }
            
            // Batch upsert in groups of 100 to avoid too large requests
            $batches = array_chunk($points, 100);
            
            foreach ($batches as $batch) {
                $response = $this->client()->put(
                    "{$this->baseUrl}/collections/{$collectionName}/points", 
                    ['points' => $batch]
                );
                
                if (!$response->successful()) {
                    Log::error('Failed to upsert vectors to Qdrant', [
                        'document_id' => $documentId,
                        'collection' => $collectionName,
                        'response' => $response->json(),
                        'status' => $response->status(),
                    ]);
                    
                    return false;
                }
            }
            
            return true;
        } catch (\Exception $e) {
            Log::error('Exception upserting vectors to Qdrant', [
                'document_id' => $documentId,
                'collection' => $collectionName,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Search for similar vectors
     *
     * @param string $query Query text
     * @param array $options Search options
     * @return array Search results
     */
    public function search(string $query, array $options = []): array
    {
        $collectionName = $options['collection'] ?? $this->defaultCollection;
        $limit = $options['limit'] ?? 5;
        $filters = $options['filters'] ?? null;
        $withPayload = $options['with_payload'] ?? true;
        
        try {
            // Generate embedding for the query
            $embedding = $this->embeddingService->generateEmbedding($query);
            
            if (empty($embedding)) {
                return [
                    'success' => false,
                    'error' => 'Failed to generate embedding for query',
                    'results' => [],
                ];

Copy

Apply

app\Services\RAG\VectorStoreService.php
please continue with code generation for VectorStoreService.php  and rest of the files as per the attached directory structure... 
.config.structure.ini
 
larafast1
 




Context
— 16 new items
Let me continue implementing the VectorStoreService.php and then move on to other key files from the directory structure. The VectorStoreService.php implementation was cut off in the middle of the search method, so I need to complete that first. After that, I'll implement some of the other important files in the structure, such as:

KnowledgeDocumentResource.php - A Filament admin resource for document management
ExecuteWorkflow.php - A job for running workflows
WorkflowEngine.php - Core logic for the workflow system
DocumentProcessor.php - Document processing for RAG
These should provide a good coverage of the system functionality.

I'll complete the VectorStoreService.php implementation and add more key files from the structure:

            if (empty($embedding)) {
                return [
                    'success' => false,
                    'error' => 'Failed to generate embedding for query',
                    'results' => [],
                ];
            }
            
            $payload = [
                'vector' => $embedding,
                'limit' => $limit,
                'with_payload' => $withPayload,
            ];
            
            // Add filter if provided
            if ($filters) {
                $payload['filter'] = $filters;
            }
            
            $response = $this->client()->post(
                "{$this->baseUrl}/collections/{$collectionName}/points/search", 
                $payload
            );
            
            if ($response->successful()) {
                $data = $response->json();
                
                // Format results for easier consumption
                $results = [];
                
                foreach ($data['result'] as $item) {
                    $results[] = [
                        'id' => $item['id'],
                        'score' => $item['score'],
                        'payload' => $item['payload'] ?? [],
                        'text' => $item['payload']['text'] ?? '',
                        'document_id' => $item['payload']['document_id'] ?? null,
                        'metadata' => array_diff_key($item['payload'] ?? [], ['text' => 1]),
                    ];
                }
                
                return [
                    'success' => true,
                    'results' => $results,
                ];
            } else {
                Log::error('Failed to search vectors in Qdrant', [
                    'collection' => $collectionName,
                    'response' => $response->json(),
                    'status' => $response->status(),
                ]);
                
                return [
                    'success' => false,
                    'error' => 'Failed to search vectors: ' . ($response->json()['status']['error'] ?? 'Unknown error'),
                    'results' => [],
                ];
            }
        } catch (\Exception $e) {
            Log::error('Exception searching vectors in Qdrant', [
                'collection' => $collectionName,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return [
                'success' => false,
                'error' => 'Exception searching vectors: ' . $e->getMessage(),
                'results' => [],
            ];
        }
    }
    
    /**
     * Delete vectors for a document
     *
     * @param string|int $documentId Document ID
     * @param string|null $collectionName Collection name
     * @return bool Success
     */
    public function deleteDocumentVectors($documentId, ?string $collectionName = null): bool
    {
        $collectionName = $collectionName ?? $this->defaultCollection;
        
        try {
            $filter = [
                'must' => [
                    [
                        'key' => 'document_id',
                        'match' => [
                            'value' => $documentId,
                        ],
                    ],
                ],
            ];
            
            $payload = [
                'filter' => $filter,
            ];
            
            $response = $this->client()->post(
                "{$this->baseUrl}/collections/{$collectionName}/points/delete", 
                $payload
            );
            
            if ($response->successful()) {
                return true;
            } else {
                Log::error('Failed to delete document vectors from Qdrant', [
                    'document_id' => $documentId,
                    'collection' => $collectionName,
                    'response' => $response->json(),
                    'status' => $response->status(),
                ]);
                
                return false;
            }
        } catch (\Exception $e) {
            Log::error('Exception deleting document vectors from Qdrant', [
                'document_id' => $documentId,
                'collection' => $collectionName,
                'error' => $e->getMessage(),
            ]);
            
            return false;
        }
    }
    
    /**
     * Get collection info
     *
     * @param string $collectionName Collection name
     * @return array|null Collection info or null on failure
     */
    public function getCollectionInfo(string $collectionName): ?array
    {
        try {
            $response = $this->client()->get("{$this->baseUrl}/collections/{$collectionName}");
            
            if ($response->successful()) {
                return $response->json()['result'];
            }
            
            return null;
        } catch (\Exception $e) {
            Log::error('Exception getting Qdrant collection info', [
                'collection' => $collectionName,
                'error' => $e->getMessage(),
            ]);
            
            return null;
        }
    }
    
    /**
     * List all collections
     *
     * @return array List of collections
     */
    public function listCollections(): array
    {
        try {
            $response = $this->client()->get("{$this->baseUrl}/collections");
            
            if ($response->successful()) {
                return $response->json()['result']['collections'] ?? [];
            }
            
            return [];
        } catch (\Exception $e) {
            Log::error('Exception listing Qdrant collections', [
                'error' => $e->getMessage(),
            ]);
            
            return [];
        }
    }
}

Copy

Apply

app\Services\RAG\VectorStoreService.php
Now let's implement the DocumentProcessor.php class:

<?php

namespace App\Services\RAG;

use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Symfony\Component\Process\Process;

class DocumentProcessor
{
    protected array $supportedMimeTypes;
    
    public function __construct()
    {
        $this->supportedMimeTypes = [
            'application/pdf' => 'extractPdf',
            'text/plain' => 'extractText',
            'text/markdown' => 'extractText',
            'text/csv' => 'extractText',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => 'extractDocx',
            'application/msword' => 'extractDoc',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation' => 'extractPptx',
            'application/vnd.ms-powerpoint' => 'extractPpt',
            'text/html' => 'extractHtml',
        ];
    }
    
    /**
     * Extract text from a document
     *
     * @param string $filePath Path to the document
     * @param string|null $mimeType Mime type of the document
     * @return string Extracted text
     */
    public function extractText(string $filePath, ?string $mimeType = null): string
    {
        // Detect mime type if not provided
        if ($mimeType === null) {
            $mimeType = mime_content_type($filePath);
        }
        
        // Find the appropriate extraction method
        $extractionMethod = $this->supportedMimeTypes[$mimeType] ?? null;
        
        if ($extractionMethod && method_exists($this, $extractionMethod)) {
            return $this->$extractionMethod($filePath);
        }
        
        // Default to treating as plain text
        return $this->extractPlainText($filePath);
    }
    
    /**
     * Extract text from a plain text file
     *
     * @param string $filePath Path to the file
     * @return string Extracted text
     */
    protected function extractPlainText(string $filePath): string
    {
        try {
            return file_get_contents($filePath);
        } catch (\Exception $e) {
            Log::error('Error extracting text from plain text file', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);
            
            return '';
        }
    }
    
    /**
     * Extract text from a PDF file
     *
     * @param string $filePath Path to the PDF file
     * @return string Extracted text
     */
    protected function extractPdf(string $filePath): string
    {
        try {
            // Check if pdftotext is available
            $process = new Process(['which', 'pdftotext']);
            $process->run();
            
            if ($process->isSuccessful()) {
                // Use pdftotext to extract text
                $outputFile = tempnam(sys_get_temp_dir(), 'pdf_');
                $process = new Process(['pdftotext', $filePath, $outputFile]);
                $process->setTimeout(60);
                $process->run();
                
                if ($process->isSuccessful()) {
                    $text = file_get_contents($outputFile);
                    unlink($outputFile);
                    return $text;
                }
            }
            
            // Fallback to PHP library
            $parser = new \Smalot\PdfParser\Parser();
            $pdf = $parser->parseFile($filePath);
            return $pdf->getText();
        } catch (\Exception $e) {
            Log::error('Error extracting text from PDF', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);
            
            return '';
        }
    }
    
    /**
     * Extract text from a DOCX file
     *
     * @param string $filePath Path to the DOCX file
     * @return string Extracted text
     */
    protected function extractDocx(string $filePath): string
    {
        try {
            $content = '';
            
            $zip = new \ZipArchive();
            if ($zip->open($filePath)) {
                if (($index = $zip->locateName('word/document.xml')) !== false) {
                    $data = $zip->getFromIndex($index);
                    $zip->close();
                    
                    $content = $this->stripDocxTags($data);
                }
            }
            
            return $content;
        } catch (\Exception $e) {
            Log::error('Error extracting text from DOCX', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);
            
            return '';
        }
    }
    
    /**
     * Strip XML tags from DOCX content
     *
     * @param string $data XML data
     * @return string Cleaned text
     */
    protected function stripDocxTags(string $data): string
    {
        $content = '';
        
        $dom = new \DOMDocument();
        $dom->loadXML($data, LIBXML_NOENT | LIBXML_XINCLUDE | LIBXML_NOERROR | LIBXML_NOWARNING);
        
        $paragraphs = $dom->getElementsByTagName('p');
        foreach ($paragraphs as $paragraph) {
            $content .= $paragraph->textContent . "\n";
        }
        
        return trim($content);
    }
    
    /**
     * Extract text from an HTML file
     *
     * @param string $filePath Path to the HTML file
     * @return string Extracted text
     */
    protected function extractHtml(string $filePath): string
    {
        try {
            $html = file_get_contents($filePath);
            
            // Remove scripts and styles
            $html = preg_replace('/<script\b[^>]*>(.*?)<\/script>/is', '', $html);
            $html = preg_replace('/<style\b[^>]*>(.*?)<\/style>/is', '', $html);
            
            // Use DOMDocument to extract text
            $dom = new \DOMDocument();
            @$dom->loadHTML($html);
            
            $text = $dom->textContent;
            
            // Clean up whitespace
            $text = preg_replace('/\s+/', ' ', $text);
            $text = trim($text);
            
            return $text;
        } catch (\Exception $e) {
            Log::error('Error extracting text from HTML', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);
            
            return '';
        }
    }
    
    /**
     * Extract metadata from a document
     *
     * @param string $filePath Path to the document
     * @param string|null $mimeType Mime type of the document
     * @return array Metadata
     */
    public function extractMetadata(string $filePath, ?string $mimeType = null): array
    {
        // Detect mime type if not provided
        if ($mimeType === null) {
            $mimeType = mime_content_type($filePath);
        }
        
        $metadata = [
            'mime_type' => $mimeType,
            'file_size' => filesize($filePath),
            'last_modified' => filemtime($filePath),
        ];
        
        // Add more metadata extraction based on file type
        if ($mimeType === 'application/pdf') {
            try {
                $parser = new \Smalot\PdfParser\Parser();
                $pdf = $parser->parseFile($filePath);
                $details = $pdf->getDetails();
                
                // Extract common PDF metadata
                $fields = ['Author', 'CreationDate', 'Creator', 'Keywords', 'ModDate', 'Producer', 'Subject', 'Title'];
                
                foreach ($fields as $field) {
                    if (isset($details[$field])) {
                        $metadata[strtolower($field)] = $details[$field];
                    }
                }
                
                // Add page count
                $metadata['page_count'] = count($pdf->getPages());
            } catch (\Exception $e) {
                Log::warning('Error extracting PDF metadata', [
                    'file' => $filePath,
                    'error' => $e->getMessage(),
                ]);
            }
        }
        
        return $metadata;
    }
    
    /**
     * Split text into chunks for processing
     *
     * @param string $text Text to split
     * @param int $chunkSize Maximum characters per chunk
     * @param int $overlap Overlap between chunks
     * @return array Chunks with metadata
     */
    public function splitIntoChunks(string $text, int $chunkSize = 1000, int $overlap = 200): array
    {
        if (empty($text)) {
            return [];
        }
        
        // Clean text - remove excessive whitespace
        $text = preg_replace('/\s+/', ' ', $text);
        $text = trim($text);
        
        $chunks = [];
        $sentences = $this->splitIntoSentences($text);
        
        $currentChunk = '';
        $currentPosition = 0;
        
        foreach ($sentences as $sentence) {
            // If adding this sentence would exceed chunk size and we already have content
            if (strlen($currentChunk) + strlen($sentence) > $chunkSize && !empty($currentChunk))

Copy

Apply

app\Services\RAG\DocumentProcessor.php
